/*
 *  Utility functions
 *  util_core.js was _util_frag.js
 *  These utility functions are for Homepage and Masterbrand bundles
 *  $Revision: 1.10 $
 */

/* jshint laxcomma: true */

if (window.cdc === undefined) { window.cdc = {}; }

if (window.cdc.context === undefined) {
  cdc.context = (function (window, undefined) {

    /**
     * Key returned for unknown environments
     * @type {string}
     */
    var UNKNOWN_ENVIRONMENT_KEY = "unknown";


    /**
     * Keys returned for known environments
     * @type {Array} of Strings
     */
    var KNOWN_ENVIRONMENT_KEYS = ["dev", "stage", "prod"];

    /**
     * List of "full-fledged" envs to check against for asset loading (US161000)
     * @type {Array} of Strings
     */
    var FULL_WEM_ENV_LIST = ["fdk-pstage", "fdk-stage", "fdk-devint", "fdk-author-pstage"];


    /**
     * Keys for known and unknown environments (concatenation of KNOWN_ENVIRONMENT_KEYS and UNKNOWN_ENVIRONMENT_KEY)
     * @type {Array}
     */
    var STANDARD_ENVIRONMENT_KEYS = KNOWN_ENVIRONMENT_KEYS.concat([UNKNOWN_ENVIRONMENT_KEY]);


    /**
     * Strings describing possible authentication statuses
     * @type {Array}
     */
    var USER_STATUSES = ["valid", "anonymous", "invalid"];


    /**
     * keys => environment description, values => Array holding strings to compare against hostnames
     * @type {Object}
     */
    var PATTERN_FRAGMENTS = {
      "prod": [
        "www[0-9]*"
        , "apps"
        , "cdx"
        , "cepx-active-prod[0-9]*"
        , "wemapp-(author|publish)-(prod[0-9]|nprd)[0-9]*-[0-9]*"
        , "www-(author|test|publish|author3)"
        , "www-(author|test|publish|author3)-nprd"
        , "wwwin-tools"
        , "cisco-apps"
        , "grs"
        , "investor"
        , "newsroom"
        , "origin-software"
        , "software"
        , "sso[0-9]*"
        , "cloudsso[0-9]*"
        , "tools"
        , "webapps"
        , "wwwin"
        , ".*\.cloudapps"
        , ".*\.cisco"
        , "^nic$"
      ],
      "stage": [
        "apps-lt"
        , "apps-stage"
        , "cdx-stage"
        , "(cepx|ecmx)-(active|staging|wip)-(lt|stage)[0-9]*"
        , "fdk-author-lt"
        , "fdk-author3-lt"
        , "fdk-author-stage"
        , "fdk-author3-stage"
        , "fdk-author-pstage"
        , "fdk-author3-pstage"
        , "fdk-author-pstage3"
        , "(www(in)?-)?fdk-(publish-)?lt[0-9]*"
        , "(www(in)?-)?fdk-(publish-)?.?stage[0-9]*"
        , "wemapp-(author|publish)-.?stage[0-9]*-[0-9]*"
        , "software-lt"
        , "software-stage"
        , "sso-nprd[0-9]*"
        , "cloudsso-test[0-9]*"
        , "tools-lt"
        , "tools-stage"
        , "www-lt[0-9]*"
        , "www-(author-|publish-)*stage[0-9]*"
        , "webapps-lt"
        , "webapps-stage"
        , "wwwin-tools-(dev|stage|lt)"
        , "wwwin-stage"
        , ".*\-stage\.cloudapps"
        , ".*\-lt\.cloudapps"
      ],
      "dev": [
        "apps-dev"
        , "cdx-dev"
        , "cepx-active-dev[0-9]*"
        , "ecmx-active-dev[0-9]*"
        , "fdk-(author-)?dev[0-9]*"
		, "fdk-(author3-)?dev[0-9]*"
        , "(www(in)?-)?fdk-(author-)?devint[0-9]*"
        , "(www(in)?-)?fdk-(author3-)?devint[0-9]*"
        , "wemapp-(author|publish)-(dev|devint|idev)[0-9]*-[0-9]*"
        , "software-dev"
        , "sso-idev[0-9]*"
        , "cloudsso-idev[0-9]*"
        , "tools-dev"
        , "www-(dev|idev)[0-9]*"
        , "localhost"
        , "webapps-dev"
        , "wwwin-dev"
        , ".*\-dev\.cloudapps"
        , ".*\.cisco.com:4502" // add sandboxes to 'dev' classification
      ]
    };

    /**
     * Configuration for public, read-only properties.
     * @type {Object}
     */
    var READ_ONLY = {
      writable: false,
      enumerable: false,
      configurable: false
    };


    /**
     * Queue of functions/callbacks to be executed upon valid authStatus
     * @type {Array}
     */
    var checkLoginQueue = [];


    /**
     * Default authentication status => "unready"
     * @type {String}
     */
    var authStatus = "unready";


    /**
     * Determines whether the environment is non-standard (by checking for a valid `cdcext.customEnvironment` property).
     * @return {Boolean} Indicates whether environment is custom or not.
     */
    var isCustomEnvironment = function() {
      var environmentsRegExp = new RegExp("^(" + STANDARD_ENVIRONMENT_KEYS.join("|").slice(0, -1) + ")$");
      return (
        typeof cdcext !== "undefined"
          && typeof cdcext.customEnvironment !== "undefined"
          && cdcext.customEnvironment.match(environmentsRegExp)
      )
    };

    /**
     * Determines whether or not the current host matches an env in FULL_WEM_ENV_LIST
     * @return {Boolean} whether or not the current host matches an env in FULL_WEM_ENV_LIST
     */
    var matchesTrueWemEnv = function () {
      var currentHost = window.location.host;
      var subdomain = currentHost.split('.')[0];
      return FULL_WEM_ENV_LIST.some(function(regexpToMatch){
        return subdomain.match(regexpToMatch) != null;
      })
    };


    /**
     * Returns a key to represent the current environment based on the hostname or `cdcext.customEnvironment`.
     * @return {String} A key to describe a known, unknown, or custom environment.
     */
    var findEnvironment = function() {
        if (isCustomEnvironment()) {
          return cdcext.customEnvironment;
        }
        else {
          return matchEnvironment(window.location.host);
        }
    };


    /**
     * Returns a compound regular expression to consolidate the provided fragments.
     * @param  {Array} patternFragments An array of strings to consolidate.
     * @return {RegExp}                 The compound regular expression object.
     */
    var getEnvironmentRegExp = function(patternFragments) {
      return new RegExp( "^(" + patternFragments.join("|") + ")(\\.|:|$)" )
    };


    /**
     * Determines if the provided hostname maps to a known environment (e.g., "dev", "stage", or "prod").
     * @param  {String} envToMatch The hostname to be tested.
     * @return {String}            A key to describe a known or unknown environment.
     */
    var matchEnvironment = function(envToMatch) {
        envToMatch = envToMatch.replace(/\.cisco\.com$|\.cisco$/i, ""); // Remove the top-level domain, if any
        var knownPatterns = {};
        KNOWN_ENVIRONMENT_KEYS.forEach(function (environmentKey) {
          knownPatterns[environmentKey] = getEnvironmentRegExp(PATTERN_FRAGMENTS[environmentKey]);
        });
        return (function (location) {
            var result = UNKNOWN_ENVIRONMENT_KEY;
            KNOWN_ENVIRONMENT_KEYS.forEach(function(environmentKey) {
              if (knownPatterns[environmentKey].test(location)) {
                result = (result === UNKNOWN_ENVIRONMENT_KEY) ? environmentKey : result;
              }
            });
            return result;
        }(envToMatch));
    };


    /**
     * Determines whether the user is on login page (by detecting presence of element matching `#login-form`).
     * @return {Boolean} Whether the user is on login page.
     */
    var isLoginPage = function() {
      return (document.querySelectorAll("#login-form").length) ? true : false;
    };


    /**
     * Indicates whether a key maps to a known user status.
     * @param  {String}  status The status of the user.
     * @return {Boolean}     Whether the user status is considered a ready status.
     */
    var isReadyStatus = function(status) {
      return USER_STATUSES.indexOf(status) !== -1
    };


    /**
     * Returns true when the argument is not a function.
     * @param  {Function} cb The callback function to be validated.
     * @return {Boolean}     Whether the argument is invalid.
     */
    var isInvalidCallback = function(cb) {
      if (typeof cb !== "function") { // Client code gave us a bad parameter
        if (console !== undefined && console.trace) {
          console.log(arguments.callee.caller.name + ": expecting a function, got a " + typeof callback);
          console.trace();
        }
        return true;
      }
      return false;
    };


    /**
     * Performs a callback when the auth status permits; otherwise, adds the callback to a queue to be handled later.
     * @param  {Function} callback The callback function to be executed.
     */
    var checkLogin = function(callback) {
      if (isInvalidCallback(callback)) {
        return;
      }
      else {
        if (isReadyStatus(cdc.context.authStatus)) {
          callback(cdc.context.authStatus);
        }
        else {
          checkLoginQueue.push(callback);
        }
      }
    };


    /**
     * Sets auth status manually and executes any queued callbacks with that value.
     * @param  {String} newStatus New auth status value.
     */
    var setAuthStatus = function(newStatus) {
        var oldStatus = cdc.context.authStatus;
        cdc.context.authStatus = newStatus;
        if (!isReadyStatus(oldStatus)) {
          checkLoginQueue.forEach(function(queuedCallback) {
            queuedCallback(newStatus);
          });
        }
    };

    /**
     * ensure that a specified namespace exists in the global scope
     * @param {String} namespaceStr: Namespace to ensure, in dot-notation, ex: "cdc.sso"
     */
    var ensureNamespace = function (namespaceStr) {
      if (!namespaceStr) { return; }
      var parts = namespaceStr.split(".");
      var o = window;
      var i;
      var aPart;
      for (i = 0; i < parts.length; i++) {
          aPart = parts[i];
          if (typeof (o[aPart]) != "object") {
              o[aPart] = {};
          }
          o = o[aPart];
      }
    };

    /**
     * generate URL with random number value for specified query param
     * @param {String} url URL to which to append the query string
     * @param {String} param the key to which to assign the random number
     * @return {String} generated url
     */
    var cacheBust = function (url, param) {
      if (!param) {
          param = 'cacheReset';
      }
      var delim = "?";
      // if url is ng-prod1(bam) or has ?, set param delimeter to &
      if (url.match(/(ng-prod1|\?)/)) {
          delim = "&";
      }
      var fullParam = delim + param + '=';
      return url + fullParam + cdc.context.randomNumber();
    };

    /**
     * generate string containing current time and random number
     * @param {Number} limit maximum limit for the random number
     * @return {String} current time and randum number, dash-separated
     */
    var randomNumber = function (limit) {
      if (!limit) {
          limit = 1000;
      }
      var sNum = Math.floor(Math.random() * limit) + 1;
      var sTime = (new Date()).getTime();
      var rNum = sTime + "-" + sNum;
      return rNum;
    };

    var ls = {
      /**
      * ls.getConfigInfo: get specified key from session OR localStorage
      * @param {String} storeName key to get from specified storage
      * @param {Boolean} session true: get from sessionStorage? false: get from localStorage
      * @return {Boolean} success => true, error => false
      */
      getConfigInfo: function (storeName, session) {
          try {
              if (session === true) {
                  return JSON.parse(sessionStorage[storeName]);
              } else {
                  return JSON.parse(localStorage[storeName]);
              }
          } catch (e) {
              return false;
          }
      },
      /**
      * ls.deleteConfigInfo: delete specified key from session OR localStorage
      * @param {String} storeName key to remove from specified storage
      * @param {Boolean} session true: delete sessionStorage? false: delete localStorage
      * @return {Boolean} success => true, error => false
      */
      deleteConfigInfo: function (storeName, session) {
          try {
              if (session === true) {
                  sessionStorage.removeItem(storeName);
              } else {
                  localStorage.removeItem(storeName);
              }
              return true;
          } catch (e) {
              return false;
          }
      }
    }

    /**
     * The public methods and properties to expose.
     * @type {Object}
     */
    var publicAPI = {
      checkLoginQueue: checkLoginQueue,
      authStatus: authStatus,
      findEnvironment: findEnvironment,
      matchEnvironment: matchEnvironment,
      isLoginPage: isLoginPage,
      checkLogin: checkLogin,
      setAuthStatus: setAuthStatus,
      randomNumber: randomNumber,
      ensureNamespace: ensureNamespace,
      cacheBust: cacheBust,
      ls: ls,
      UNKNOWN_ENVIRONMENT_KEY: UNKNOWN_ENVIRONMENT_KEY,
      KNOWN_ENVIRONMENT_KEYS: KNOWN_ENVIRONMENT_KEYS,
      STANDARD_ENVIRONMENT_KEYS: STANDARD_ENVIRONMENT_KEYS,
      USER_STATUSES: USER_STATUSES,
      PATTERN_FRAGMENTS: PATTERN_FRAGMENTS,
      FULL_WEM_ENV_LIST: FULL_WEM_ENV_LIST,
      matchesTrueWemEnv: matchesTrueWemEnv
    };


    /**
     * Updates public properties to be read-only.
     */
    Object.defineProperties(publicAPI, {
      "UNKNOWN_ENVIRONMENT_KEY": READ_ONLY,
      "KNOWN_ENVIRONMENT_KEYS": READ_ONLY,
      "STANDARD_ENVIRONMENT_KEYS": READ_ONLY,
      "USER_STATUSES": READ_ONLY,
      "PATTERN_FRAGMENTS": READ_ONLY
    })

    return publicAPI;

  })(window); // cdc.context
} // end existence check

cdc.util = {
    ensureNamespace: cdc.context.ensureNamespace,
    checkClear: function (input, defaultPhrase) {
        if (input.value == defaultPhrase) { input.value = ""; }
        if (input.id === "search-phrase" || input.id === "searchPhrase") {
            if (!document.querySelector('#search-drop-down.ready')) {
                cdc.search.setupTypeAhead();
            }

            if (document.getElementById("search-drop-down")) {
                cdc.search.typeAhead.show();
            }
        }
    },    // cache buster - puts a cache avoidance param on a url with a random number
    // invoke with:
    // cdc.util.cacheBust('http://www.cisco.com');          = YourUrl?cacheReset=rand#
    // cdc.util.cacheBust('http://www.cisco.com','foo');    = YourUrl?foo=rand#
    // cdc.util.cacheBust('http://ng-prod1/image');         = YourUrl&cacheReset=rand#
    // cdc.util.cacheBust('http://cisco.com/edit.pl?a=3');  = YourUrl&cacheReset=rand#
    cacheBust: cdc.context.cacheBust,
    // randum number generator
    // input: takes param limit to set random max, default is 1000
    // output: 'TimeInSeconds-RandNum'
    // invoke with: cdc.util.randomNumber(50); or cdc.util.randomNumber();
    randomNumber: cdc.context.randomNumber,
    /* DEPRECATED - isAuthenticated() -- will often be false negative after 5/13/2012 */
    isAuthenticated: function () {
        var loggedInCookieVal = cdc.cookie.getCookie('SMSESSION');
        var userAuthStatus = null;
        if (loggedInCookieVal && loggedInCookieVal != '' && loggedInCookieVal != 'LOGGEDOFF') {
            userAuthStatus = true;
        } else {
            userAuthStatus = false;
        }
        return userAuthStatus;
    },
    /* authStatus and checkLogin replace isAuthenticated() */
    // authStatus: cdc.context.authStatus,
    // checkLoginQueue: cdc.context.checkLoginQueue,
    checkLogin: cdc.context.checkLogin,
    notifyLoginQueue: cdc.context.setAuthStatus,
    netCheckTimer: null,
    netStatusExpired: null,
    netJqxhr: null,
    netCheckCancel: false,

    /*
     * Employee Menu Handler for Treenav and Mega Menu navigation layouts
     * Authored by: Dan Pisciottano (dpisciot)
     * Referenced by: cdc.util.inNetworkTest
     *                cdc.util.isInNetwork
     */
    handleEmpNav: function (inNetwork, data) {
        var hasTreenav = jQuery('#fw-treenavbutton');

        // Treenav logic
        // only fire if treenav exists (responsive template)
        if (hasTreenav.length > 0) {
            if (inNetwork) {
                cdc.treenav.showEmpTreenav(data);
            } else {
                cdc.treenav.notInNetwork();
            }
        }
        // Mega Menu logic
        // only fire if treenav is not being displayed (responsive template) or treenav doesnt exist (masterbrand template)
        if (hasTreenav.css("display") === "none" || hasTreenav.length === 0) {
            if (inNetwork) {
                cdc.util.mm.showEmpMegamenu(data);
            } else {
                cdc.util.mm.notInNetwork();
            }
        }
    },
    renewNetStatusCache: function (stat) {
        var namespace = 'emplink';
        cdc.debug.log(namespace, 'timestamp expired or null. renewing timestamp on network status cache');
        var nowstamp = new Date().getTime();
        var cacheObj = {};
        cacheObj[0] = stat;
        cacheObj[1] = {"timestamp" : nowstamp};
        cdc.util.ls.setConfigInfo("networkStatus", cacheObj);
        cdc.debug.log(namespace, 'end renew cache function. object now in cache is');
        cdc.debug.dir(namespace, cdc.util.ls.getConfigInfo("networkStatus"));
    },
    inNetworkTest: function () {
        var namespace = 'emplink';
        cdc.debug.log(namespace, 'in the in network test function in util_core');

        //define the ajax call functions and the timeout
        function inNetworkAjax() {
            cdc.debug.log(namespace, 'in the in network ajax function in util_core');
            var timeToCancel = 3000; //3,000 milliseconds = 3 seconds

            var abortAjax = function () {
                cdc.util.netJqxhr.abort();
                cdc.util.netJqxhr = null;
                cdc.util.netCheckCancel = true;
                clearTimeout(cdc.util.netCheckTimer);
                cdc.debug.log(namespace, 'cleared the timer from the aborted call');
            };

            var cancelInNetworkTest = function () {
                cdc.debug.log(namespace, 'timed out.');
                abortAjax();
                cdc.debug.log(namespace, 'cancelled ajax call from timeout');
                cdc.debug.log(namespace, 'running notInNetwork from timeout');
                cdc.util.handleEmpNav(false, null);
            };

            if (cdc.util.netJqxhr) {
                cdc.debug.log(namespace, 'there was another in-network call running. aborting it');
                abortAjax();
            }

            cdc.util.netStatusExpired = true;

            cdc.util.netCheckTimer = setTimeout(cancelInNetworkTest, timeToCancel); //this puts a time limit on the ajax call

            // ** this file simply has 1 line:  cdc.util.isInNetwork(true)  **
            cdc.util.netJqxhr = jQuery.ajax({
                url: "//wwwin.cisco.com/wem/is-in-network-test.js",
                type: "GET",
                dataType: "script",
                cache: false,
                error: function (netJqxhr, text_status, error_thrown) {
                    if (text_status !== "abort") {
                        clearTimeout(cdc.util.netCheckTimer);
                        cdc.debug.log(namespace, 'cleared the timer in error function');
                        cdc.debug.log(namespace, 'ajax error. error is ' + error_thrown);
                        cdc.debug.log(namespace, 'running notinnetwork from error function');
                        cdc.util.handleEmpNav(false, null);
                    }
                }
            });
        }

        //check if network status is in cache - use it if it exists and has not expired
        var net = cdc.util.ls.getConfigInfo("networkStatus");

        if (net == null || net == undefined || net == "") { //there is no network status in the cache at all yet
            cdc.debug.log(namespace, 'net status object is');
            cdc.debug.dir(net);
            inNetworkAjax();

        } else {  //something is in the network status cache
            cdc.debug.log(namespace, 'net status object is');
            cdc.debug.dir(namespace, net);
            var cachestamp = net[1].timestamp;
            var newnow = new Date().getTime();
            var diff = newnow - cachestamp;
            cdc.debug.log(namespace, 'current cache timestamp is ' + cachestamp);
            cdc.debug.log(namespace, 'the time difference is ' + diff);

            if (diff > 60000) {
                cdc.debug.log(namespace, 'cached network status is older than one minute. do new ajax call');
                inNetworkAjax();
            } else {
                cdc.debug.log(namespace, 'cached network status is less than one minute. use current status');
                cdc.debug.log(namespace, 'net status object is');
                cdc.debug.dir(namespace, net);
                cdc.util.netStatusExpired = false;
                var netstatus = net[0];
                cdc.util.isInNetwork(netstatus);
            }
        }
    },
    isInNetwork: function (data) {
        var namespace = 'emplink';
        cdc.debug.log(namespace, 'in the isInNetwork success function and data is ' + data);
        clearTimeout(cdc.util.netCheckTimer);
        if (cdc.util.netCheckCancel === true) {
           cdc.debug.log(namespace, 'netcheck is true. do not enable emp link');
        } else {
            cdc.debug.log(namespace, 'success function enables emp link');
            if (cdc.util.netStatusExpired === true) { cdc.util.renewNetStatusCache(data); }
            cdc.util.handleEmpNav(true, data);
        }
        cdc.debug.log(namespace, 'success function reset the cancel check flag');
        cdc.util.netCheckCancel = false; //reset for next attempt
    },
    openCdcPopup: function (url, width, height) {
        if (!url) {
            return true;
        } //where url is not supplied do nothing
        var windowControls = '';
        var windowOptions = '';
        var windowName = 'globalCDCpopup';

        if (typeof url == "object") {
            // create temp variables to function params map
            width = url.width;
            height = url.height;
            xtop = url.top !== undefined ? url.top : ''; //named "xtop" because "top" kills IE
            left = url.left !== undefined ? url.left : '';
            windowOptions = "top=" + xtop + ",left=" + left + ",";
            if (url.windowName !== undefined) { windowName = url.windowName; }

            if (url.controls != false) { //undefined = true
                if (url.location !== undefined && url.location == "no") {
                    windowControls = ",toolbar=yes,location=no,menubar=yes";
                } else {
                    windowControls = ",toolbar=yes,location=yes,menubar=yes";
                }
            }
            url = url.address; // doing this last because it nukes the url object
        }

        width = isNaN(parseInt(width)) ? 550 : parseInt(width);
        height = isNaN(parseInt(height)) ? 550 : parseInt(height);

        /* ie scrollbar behaviour adjustment */
        if (document.all) {
            width = width + 20;
        }

        windowOptions += "width=" + width + ",height=" + height + ",status=yes,scrollbars=yes,resizable=yes" + windowControls;
        var popup = window.open(url, windowName, windowOptions);
        if (popup) { popup.focus(); }
        return false;
    },
    /*
     * Grabs a parameter from the URL.  Returns an empty
     * string if parameter does not exist.
    */
    getParameter: function (param, url) {
    	param = param + "=";
        var qs;
        if (url) {
            qs = url.slice(url.indexOf('?') + 1);
        }
        qs = qs || window.location.search;
        var val = "";
        var start = qs.indexOf(param);
        if (start != -1) {
            start += param.length;
            var end = qs.indexOf("&", start);
            if (end == -1) {
                end = qs.length;
            }
            val = qs.substring(start,end);
        }
        return val;
    },
    onElementLoadById: (function () {
        var docReady = false;
        jQuery(document).ready(function () {
            docReady = true;
        });
        // pull some tricks to see if an element is fully parsed into dom
        function doneLoading(elmt) {
            if (docReady) {
                return true;
            }
            while (elmt) {
                if (elmt.nextSibling) {
                    return true;
                }
                elmt = elmt.parentNode;
            }
            return false;
        }
        return function (id, func) {
            var el = false;
            (function () {
                el = el || document.getElementById(id);
                if (el && doneLoading(el)) {
                    func.call(el);
                } else {
                    window.setTimeout(arguments.callee, 100);
                }
            }());
        };
    }()),
    logoutdialog: {
        show: function () {
            cdc.util.ensureNamespace('cdc.local.wpx');
            if (!jQuery('#logoutmsg').length) {

                // if other values were in RB bundle, those are used, otherwise here are defaults
                cdc.local.wpx = jQuery.extend({
                    LOGOUT_MODAL_TITLE: "Log Out",
                    LOGOUT_MODAL_QUERY: "You are about to log out of Cisco.com.<br />If your task is incomplete, please click Cancel to finish or save.",
                    LOGOUT_YES_BUTTON_TEXT: "Log Out",
                    LOGOUT_NO_BUTTON_TEXT: "Cancel"
                }, cdc.local.wpx);

                cdc.util.logoutdialog.url = this.href;

                cdc.util.logoutdialog.html = '<div id="logoutmsg"><span id="lm-corner-top"><span></span></span>' + '<h4>' + cdc.local.wpx.LOGOUT_MODAL_TITLE + '</h4>' + '<div>' + cdc.local.wpx.LOGOUT_MODAL_QUERY + '</div>' + '<a class="a00v1" id="logoutbtn" href="' + cdc.util.logoutdialog.url + '">' + cdc.local.wpx.LOGOUT_YES_BUTTON_TEXT + '</a>' + '<a id="logoutclose" class="a00v1" href="javascript:return false">' + cdc.local.wpx.LOGOUT_NO_BUTTON_TEXT + '</a>' + '<span id="lm-corner-bot"><span></span></span></div>';

                jQuery(this).append(cdc.util.logoutdialog.html);
            //  jQuery('.ft-logout a').append(cdc.util.logoutdialog.html); -- Only line that was different between home & not home version
                jQuery('#logoutmsg').jqm({
                    modal: true,
                    toTop: true
                }).jqmAddClose('#logoutmsg #logoutclose');
            }
            jQuery('#logoutmsg').css('left', jQuery('#fw-banner').offset().left + 240);
            jQuery('#logoutmsg').jqmShow();
            setTimeout(function () {jQuery("#logoutbtn").focus();},0);// set to focus on logout button

            // when focus on cancel button and press on tab key
            jQuery("#logoutclose").keydown(function (objEvent) {
                if (objEvent.keyCode == 9 ) {//tab pressed
                    jQuery("#logoutbtn").focus(); // focus on logout button
                    objEvent.preventDefault(); // prevent the default action
                }
            });

            // when focus on logout button and press on shift+tab keys
            jQuery("#logoutbtn").keydown(function (objEvent) {
                // checking for shif+tab key pressed(backward focus).
                if (objEvent.keyCode == 9 && objEvent.shiftKey == 1) {
                    jQuery("#logoutclose").focus(); // focus on cancel button
                    objEvent.preventDefault(); // prevent the default action
                }
            });
            return false;
        }
    },
    /* Local storage function wrappers */
    ls: {
        setConfigInfo: function (storeName, configObj, session) {
            try {
                if (session === true) {
                    sessionStorage[storeName] = JSON.stringify(configObj);
                } else {
                    localStorage[storeName] = JSON.stringify(configObj);
                }
                return true;
            } catch (e) {
                return false;
            }
        },
        getConfigInfo: cdc.context.ls.getConfigInfo,
        deleteConfigInfo: cdc.context.ls.deleteConfigInfo
        },
    /* ut specific API wrapper used in UT code, does it belong here or in livemanager.js? */
    ut: {
        setConfigInfo: function (configObj) {
            cdc.util.ls.setConfigInfo("utConfig", configObj);
        },
        getConfigInfo: function () {
            var config = cdc.util.ls.getConfigInfo("utConfig");
            var now = new Date();
            if (config && config.expiry < now.getTime()) {
                if (console) {
                    console.log("Deleting expired utConfig.  Values were:" + JSON.stringify(config) + "You must resave them if you need them.");
                }
                cdc.util.ut.deleteConfigInfo();
                config = false;
            }
            return config;
        },
        deleteConfigInfo: function () {
            cdc.util.ls.deleteConfigInfo("utConfig");
        }
    },
    /* Localization function wrappers */
    locale: {
        languageforTheatercode: {
            "ES" : "es_ES",
            "DE" : "de_DE",
            "FR" : "fr_FR",
            "PL" : "pl_PL",
            "BR" : "pt_BR",
            "RU" : "ru_RU",
            "JP" : "ja_JP",
            "KR" : "ko_KR",
            "CN" : "zh_CN",
            "CZ" : "cs_CZ",
            "IT" : "it_IT",
            "TH" : "th_TH",
            "TR" : "tr_TR",
            "VN" : "vi_VN",
            "LA" : "es_LA"
        },
        theatercodeforLanguage: {
            "es" : "es_ES",
            "de" : "de_DE",
            "fr" : "fr_CA",
            "vi" : "vi_VN",
            "pl" : "pl_PL",
            "pt" : "pt_BR",
            "ru" : "ru_RU",
            "ja" : "ja_JP",
            "ko" : "ko_KR",
            "zh" : "zh_CN",
            "cs" : "cs_CZ",
            "it" : "it_IT",
            "th" : "th_TH",
            "tr" : "tr_TR",
            "en" : "en_US"
        },
        /* CK:
         * Modification:
         * Also adds isCdc functionality to indicate if link is a Cisco.com recognized link.
         * Returns
            'isCdc':isCdc, // true | false
            'getLanguage':languageCode,  // en | false
            'getCountry':theaterCode, // CA | false
            'getLocale':languageCode+'_'+theaterCode, // en_CA | false
            'matchCountry':matchCountry,  // url | meta - future to include storage | browser, etc.
            'matchLanguage':matchLanguage // url | meta - future to include storage | browser, etc.
        */
        getLocale: function (url) {
            var langArr, languageCode, theaterCode, matchLanguage, matchCountry = "";
            if (!url || url == null || url === undefined) {
                if (document.referrer) {
                    url = document.referrer.toString();
                }
            }

            // CK: need to break these out into their own functions so that they are accessible to other scripts to run test off of.
            var isLocalStorage = cdc.util.ls.getConfigInfo("localeinfo"); // checking for localstorage
            //http://tools.cisco.com/getlocale/index.html?loginlocale=de_DE&filterId=1&type=all
            var isParameterLoginLocale = cdc.util.getParameter('loginlocale',url); // Checking for parameter loginlocale
            //http://tools.cisco.com/getlocale/index.html?loginlocale=de_DE&filterId=1&type=all
            var isParameterLocale = cdc.util.getParameter('locale',url); // Checking for Parameter locale
            //http://tools.cisco.com/search/JSP/search-results.get?strQueryText=routers&Search+All+cisco.com=cisco.com&language=en&country=US&thissection=f&accessLevel=Guest
            var isParameterCountry = cdc.util.getParameter('country',url.toLowerCase());
            var isParameterLanguage = cdc.util.getParameter('language',url.toLowerCase());
            // http://www.cisco.com/web/CH/fr/products/index.html
            var isLanguagePattern = url.match(/(\/web\/.*[A-Z]{2,3}\/[a-z]{2}\/)/g); //tweaked to max at 3
            // http://www.cisco.com/cisco/web/CA/support/index_fr.html
            var isTheaterFilePattern = url.match(/(\/web\/[A-Z]{2,3}\/.*\_[a-z]{2}[\.\/])/g); // tweaked to max 3, add / as possible end
            // http://www.cisco.com/web/CA/products/index.html
            var isTheaterPattern = url.match(/(\/web\/.*[A-Z]{2,3}\/)/g); //tweaked to max 3
            // http://www.cisco.com/web/siteassets/legal/global/privacy_statement_ca_fr.html
            var is1xTheaterFilePattern = url.match(/(\/web\/.*\/global\/.*\_[a-z]{2,3}[\.\/])/g); // add for old privacy_statement_br.html and  privacy_statement_ca_fr.html pattern match
            // http://www.cisco.com/web/siteassets/legal/terms_condition_fr.html
            var is1xLanguageFilePattern = url.match(/(\/web\/.*\_[a-z]{2,2}[\.\/])/g); // add for old terms_condition_fr.html pattern match
            // http://www.cisco.com/en/US/hmpgs/index.html
            var is1xUsaPattern = url.match(/(\/en\/US\/)/g); // new for en/US matches

            // step 1 : Check for Local Storage...
            if (isLocalStorage) {
                langArr = isLocalStorage.toString().split('_');
                languageCode = langArr[0];
                theaterCode = langArr[1];
                matchLanguage = "localstorage";
                matchCountry = "localstorage";
            } else if ((isParameterLoginLocale != "") || (isParameterLocale != "") || (isParameterLanguage != "") || (isParameterCountry != "")) {
                // step 2 : Check for Parameters ...
                //http://tools.cisco.com/getlocale/index.html?loginlocale=de_DE&filterId=1&type=all
                //http://tools.cisco.com/search/JSP/search-results.get?strQueryText=routers&Search+All+cisco.com=cisco.com&language=ja&country=JP&thissection=f&accessLevel=Guest
                if (isParameterLoginLocale || isParameterLocale) {
                    langArr = isParameterLoginLocale.toString().split('_');
                    if (langArr == "") {langArr = isParameterLocale.toString().split('_');}
                    languageCode = langArr[0];
                    theaterCode = langArr[1];
                }
                else if (isParameterLanguage && isParameterCountry) {
                    languageCode = isParameterLanguage;
                    theaterCode = isParameterCountry.toUpperCase();
                }
                matchLanguage = "parameter";
                matchCountry = "parameter";
            } else if (isLanguagePattern || isTheaterFilePattern || isTheaterPattern || is1xTheaterFilePattern || is1xLanguageFilePattern || is1xUsaPattern) {
                // step 3 : Check for URL Patterns  ...
                if (isLanguagePattern) {
                    langArr = isLanguagePattern.toString().split('/');
                    languageCode = langArr[langArr.length - 2];
                    theaterCode = langArr[langArr.length - 3];
                    matchLanguage = "url";
                    matchCountry = "url";
                } else if (isTheaterFilePattern) {
                    langArr = isTheaterFilePattern.toString().split('_');
                    languageCode = langArr[langArr.length - 1].replace(/[./]/g,''); // tweaked
                    theaterArr = isTheaterFilePattern.toString().split('/');
                    theaterCode = theaterArr[2];
                    matchLanguage = "url";
                    matchCountry = "url";
                } else if (isTheaterPattern) {
                    theaterArr = isTheaterPattern.toString().split('/');
                    theaterCode = theaterArr[theaterArr.length - 2];
                    languageCode = false;
                    // need to add the condition to veriy local  patterns ?????
                    if (theaterCode in cdc.util.locale.languageforTheatercode) {
                        languageCode = (cdc.util.locale.languageforTheatercode[theaterCode]).toString().split('_')[0];
                        matchLanguage = "url";
                        matchCountry = "url";
                    }
                } else if (is1xTheaterFilePattern) { // added
                    langArr = is1xTheaterFilePattern.toString().split('_');
                    if (langArr.length > 3) {
                        languageCode = langArr[langArr.length - 1].replace(/[./]/g,'');
                        theaterCode = langArr[langArr.length - 2].toUpperCase();
                        matchCountry ="url";
                        matchLanguage = "url";
                    } else {
                        theaterCode = langArr[langArr.length - 1].replace(/[./]/g,'').toUpperCase();
                        languageCode = false;
                        matchLanguage = false;
                        matchCountry ="url";
                    }
                } else if (is1xLanguageFilePattern) { // added
                    theaterCode = false;
                    matchCountry = false;
                    matchLanguage = "url";
                    langArr = is1xLanguageFilePattern.toString().split('_');
                    languageCode = langArr[langArr.length - 1].replace(/[./]/g,'');
                    // need to add the condition to verify theatre code patterns  for all  ?????
                    if (languageCode in cdc.util.theatercodeforLanguage) {
                        theaterCode = (cdc.util.theatercodeforLanguage[languageCode]).toString().split('_')[1];
                    }
                } else if (is1xUsaPattern) { // ck: added for identifying en/US
                  langArr = is1xUsaPattern.toString().split('/');
                  languageCode = langArr[1];
                  theaterArr = is1xUsaPattern.toString().split('/');
                  theaterCode = theaterArr[2];
                   matchLanguage = "url";
                  matchCountry = "url";
                }
            } else if (url == location.href && (!theaterCode || !languageCode)) {
                // step 4 was 5 : Check for Meta Data on the current Page..
                if ( !(theaterCode && languageCode) ) {
                    var getMeta = document.getElementsByTagName('meta');
                    for (var i in getMeta) {
                        if (getMeta[i].name == "language" && !languageCode) {
                            languageCode = getMeta[i].content;
                            matchLanguage = "meta";
                        }
                        if (getMeta[i].name == "country" && !theaterCode) {
                            theaterCode = getMeta[i].content;
                            matchCountry = "meta";
                        }
                    }
                }
            } else if (window.navigator.language) {
                // step 5 was 4 : Check for Browser Settings...
                langArr = (window.navigator.language).toString().split('-');
                languageCode = langArr[0];
                theaterCode = langArr[1];
                if (theaterCode) {theaterCode = theaterCode.toUpperCase();}
                if (languageCode in cdc.util.locale.theatercodeforLanguage && theaterCode === undefined) {
                    theaterCode = (cdc.util.locale.theatercodeforLanguage[languageCode]).toString().split('_')[1];
                }
                matchLanguage = "Browser";
                matchCountry = "Browser";
            } else {  //  NOT FOUND
                languageCode = false;
                theaterCode = false;
                matchLanguage = false;
                matchCountry = false;
            }
            // Can be rolled out into own function, if required.
            //var isCdc = (url.match(/(http)s?(:\/\/).*(cisco.com)/g)) ? true: false; // added to identify Cdc link patterns
            //if (debug) console.log('GETLOCALE: isCdc:'+isCdc+', getLanguage:'+languageCode+', getCountry:'+theaterCode+', getLocale:'+languageCode+'_'+theaterCode+', matchCountry:'+matchCountry+', matchLanguage:'+matchLanguage);

            return {
                  //'isCdc'        :isCdc,         // true | false
                  'getLanguage'  :languageCode,  // en | false
                  'getCountry'   :theaterCode,   // CA | false
                  'getLocale'    :languageCode+'_'+theaterCode, // en_CA | false
                  'matchCountry' :matchCountry,  // url | meta - future to include storage | browser, etc.
                  'matchLanguage':matchLanguage  // url | meta - future to include storage | browser, etc.
            };
        }
    },
    /************* USAGE ****************
        cdc.util.event.defer.queueEvent(element, eventFn, delay)
        element, is the DOM element which is passsed as an argument to eventFn
        eventFn, is expected to be a function that takes the passed element as an argument
        delay is an optional parameter to override the default setting of 300ms, delay must be a number
    ************************************/
    event: {
        defer: (function () {
            var timer = 0,
                // Set a default trigger time
                trigger = 300,
                pendingEvents = {}; // Map: elementId -> pending eventFn
            return { // The delay values use the trigger value unless overriden
                queueEvent: function (element, eventFn, delay) {
                    if (delay && typeof (delay) === 'number') trigger = delay; // look for optional delay time override parameter
                    if (timer && element.id in pendingEvents) {
                        delete pendingEvents[element.id]; // We just got an "cancellation" event on a pending menu item
                    } else {
                        pendingEvents[element.id] = eventFn; // Not a cancellation
                    }
                    if (timer) clearTimeout(timer); // Restart the timer
                    timer = setTimeout("cdc.util.event.defer.runPendingEvents()", trigger);
                },
                runPendingEvents: function () {
                    for (var elementId in pendingEvents) { // Timer expired, run all of the pending events
                        var eventFn = pendingEvents[elementId];
                        var eventElement = document.getElementById(elementId);
                        eventFn(eventElement);
                    }
                    pendingEvents = {}; // We've dealt with all pending events, so clear the list:
                }
            };
        }())
    },

    findEnvironment: cdc.context.findEnvironment,
    matchesTrueWemEnv: cdc.context.matchesTrueWemEnv,
    matchEnvironment: cdc.context.matchEnvironment,

    // *** mingle #8222
    // returns an environment based dev or stage subdomain
    getEnvSubdomain : function (platform, subdomain, forceStage) {
        target_subdom = (subdomain === '' || subdomain === null || subdomain === undefined) ? 'www' : subdomain;
        var environment = cdc.util.findEnvironment();
        if (environment === 'stage' || (environment === 'dev' && forceStage === 'force') ) {
            if (platform !== 'wp') {
                target_subdom = 'fdk-stage';
            } else {
                target_subdom = target_subdom + '-stage';
            }
        } else if (environment === 'dev') {
            if (platform !== 'wp') {
                target_subdom = 'fdk-devint';
            } else {
                target_subdom = target_subdom + '-dev';
            }
        }
        return target_subdom;
    },
    js: {
       extendProperties: function (object) {
            for (prop in this) {
                if (this.hasOwnProperty(prop)) {
                    if (prop == 'extendProperties') continue;

                    object[prop] = this[prop];
                }
            }

            return object;
        },

        //nextElementSibling as a function of the Object.
        nextElemSibling: function () {
            if (this.nextElementSibling) {
                return cdc.util.js.extendProperties(this.nextElementSibling);
            }

            var nextSibling = this.nextSibling;
            while(nextSibling && nextSibling.nodeType != 1) {
                nextSibling = nextSibling.nextSibling;
            }

            return cdc.util.js.extendProperties(nextSibling);

        },

        //previousElementSibling as a function of the Object.
        previousElemSibling: function () {
            if (this.previousElementSibling) {
                return cdc.util.js.extendProperties(this.previousElementSibling);
            }

            var prevSibling = this.previousSibling;
            while(prevSibling && prevSibling .nodeType != 1) {
                prevSibling = prevSibling.previousSibling;
            }

            return cdc.util.js.extendProperties(prevSibling);
        },

        //lastChild as a function of the Object.
        lastElemChild: function () {
            if (this.lastElementChild) {
                return cdc.util.js.extendProperties(this.lastElementChild);
            }

            var lastChild = this.lastChild;
            while(lastChild && lastChild.nodeType != 1) {
                lastChild = lastChild.previousSibling;
            }

            return cdc.util.js.extendProperties(lastChild);
        },

        removeClass: function (el, classname) {
            el.className = el.className.replace(new RegExp('(\\s|^)' + classname + '(\\s|$)'),' ').replace(/^\s+|\s+$/g, '');
        }
    },

    isLoginPage: cdc.context.isLoginPage,

    /*
     ** http://underscorejs.org/#throttle
     * Creates and returns a new, throttled version of the passed function, that, when invoked repeatedly, will only
     * actually call the original function at most once per every wait milliseconds. Useful for rate-limiting events
     * that occur faster than you can keep up with.
     * By default, throttle will execute the function as soon as you call it for the first time, and, if you call it
     * again any number of times during the wait period, as soon as that period is over. If you'd like to disable the
     * leading-edge call, pass {leading: false}, and if you'd like to disable the execution on the trailing-edge, pass
     * {trailing: false}.
     */
    throttle : function (func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) {
            options = {};
        }
        var later = function () {
            previous = options.leading === false ? 0 : new Date().getTime();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) {
                context = args = null;
            }
        };
        return function () {
            var now = new Date().getTime();
            if (!previous && options.leading === false) {
                previous = now;
            }
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) {
                    context = args = null;
                }
            }
            else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    },
    /*
     ** http://underscorejs.org/#debounce
     * Creates and returns a new debounced version of the passed function which will postpone its execution until after
     * wait milliseconds have elapsed since the last time it was invoked. Useful for implementing behavior that should
     * only happen after the input has stopped arriving. For example: rendering a preview of a Markdown comment,
     * recalculating a layout after the window has stopped being resized, and so on.
     * Pass true for the immediate argument to cause debounce to trigger the function on the leading instead of the
     * trailing edge of the wait interval. Useful in circumstances like preventing accidental double-clicks on a
     * "submit" button from firing a second time.
     */
    debounce : function (func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function () {
            var last = new Date().getTime() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            }
            else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) {
                        context = args = null;
                    }
                }
            }
        };

        return function () {
            context = this;
            args = arguments;
            timestamp = new Date().getTime();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    },

    //
    // jQuery replacement methods - initially implemented for chatController.js
    // (mhitchco, 8/05/2016)
    //

    // uses code straight from jQuery, with minor mods
    getScript: function (params) {
       var head   = document.getElementsByTagName("head")[0],
           script = document.createElement("script"),
           done   = false;

       script.src = params.url;
       if (params.scriptCharset) {
          script.charset = params.scriptCharset;
       }

       // Attach handlers for all browsers
       script.onreadystatechange = function(){
          if ( !done && (!this.readyState ||
               this.readyState === "loaded" ||
               this.readyState === "complete")
          ) {
               done = true;
               params.success();
               //complete();
               head.removeChild( script );
          }
       };
       script.onload = script.onreadystatechange; // jslint did not like chained assignments...

       head.appendChild(script);
    }, // end cdc.util.getScript()

    // define a simple XHR handler to gain independence from jQuery
    getJson: function (params) {
       var xhr  = false,
           resp = '';

       try { xhr = new XMLHttpRequest(); } // most browsers
       catch (ignore) {
          // must be IE
          try { xhr = new ActiveXObject("Msxml2.XMLHTTP"); } // IE
          catch (ignore) { // e2
             // must be _old_ IE
             try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } // try an older version
             catch (ignore) { // e3
                return false;
             }
          }
       }
       if (!xhr) { return false; }

       if (typeof params.success !== 'function') { params.success = function () {}; }
       if (typeof params.error   !== 'function') { params.error   = function () {}; }

       xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
             if (xhr.status === 200) {
                try { resp = JSON.parse(xhr.responseText); }
                catch (syntaxError) {
                   return params.error(xhr, 'parsererror', syntaxError.message);
                }
                return params.success(resp,xhr.statusText,xhr);
             }
             else {
                return params.error(xhr,xhr.statusText,'error');
             }
          }
       };

       xhr.open("GET", params.url, true);
       //xhr.open('GET', params.url + '?' + new Date().getTime(), true);

       if (params.hasOwnProperty('contentType')) {
          xhr.setRequestHeader('Content-Type', 'application/json');
       }

       if (params.hasOwnProperty('authority')) {
          xhr.setRequestHeader("Authority", params.authValue);
       }

       if (params.hasOwnProperty('withCredentials')) {
          xhr.withCredentials = true;
       }

       if (params.headers) {
          // jslint made me do this instead of 'for in'... *sigh*
          Object.keys(params.headers).forEach(
             function(key) {
                //chatlog("      -- cdc.util.getJson(): adding custom header [" + key + ": " + params.headers[key] + "]");
                xhr.setRequestHeader(key, params.headers[key]);
             }
          );
       }

       xhr.send(null);
       return xhr;
    }, // end cdc.util.getJson()

    // jQuery off() replacement...
    removeEvent: function(node, type, handler) {
       if (!type && node.length) {
          handler = node[2];
          type    = node[1];
          node    = node[0];
       }

       if (node.detachEvent) {
          node.detachEvent('on'+type, handler);
       }
       else {
          node.removeEventListener(type, handler);
       }
    },

    // jQuery on() replacement...
    addEvent: function(node, type, handler, state) {
       if (!type && node.length) {
          state   = node[3];
          handler = node[2];
          type    = node[1];
          node    = node[0];
       }

       if (node.attachEvent) {
          node.attachEvent('on'+type, handler);
       }
       else {
          node.addEventListener(type, handler);
       }

       if (state) {
          state.events.push([node,type,handler]);
       }
    },

    // containsFlash: look for flash movies on the page (or scoped down to the optional node param)
    containsFlash: function (node) {
       var ns = "containsFlash";
       var s;
       var selectors = [ // put high value selectors last, they get popped first
            'object param[name="movie"][value*=".f4v"]',
            'object param[name="src"][value*=".f4v"]',
            'embed[src*=".f4v"]',
            'object[data*=".f4v"]',
            'object param[name="movie"][value*=".flv"]',
            'object param[name="src"][value*=".flv"]',
            'embed[src*=".flv"]',
            'object[data*=".flv"]',
            'object param[name="movie"][value*=".swf"]',
            'object param[name="src"][value*=".swf"]',
            'embed[src*=".swf"]',
            'object[data*=".swf"]',
            'object[data*="brightcove.com"]',
            'object[id*="Brightcove"]',
            'object[type*="x-shockwave-flash"]'
       ];

       if (typeof node === "undefined") {
          node = document;
       }

       cdc.debug.log(ns, "begin cdc.util.containsFlash()...");
       while (s = selectors.pop()) {
           if (node.querySelectorAll(s).length) {
               cdc.debug.log(ns, "-- '" + s + "': MATCH");
               cdc.debug.log(ns, "end cdc.util.containsFlash()");
               return s;
           }
           cdc.debug.log(ns, "-- '" + s + "': no match");
       }
       cdc.debug.log(ns, "-- no matches at all");
       cdc.debug.log(ns, "end cdc.util.containsFlash()");
       return false;
   },

   // if there is any Adobe Flash on the page (in stage), use codebeacon to alert user
   needFlashCodeBeacon: function () {
       var ns = "needFlashCodeBeacon";
       var flashSelector = cdc.util.containsFlash();
       cdc.debug.log(ns, "begin cdc.util.needFlashCodeBeacon()...");
       if (flashSelector) {
           cdc.debug.log(ns, "-- found Adobe flash in page, now firing codebeacon");
           cdc.debug.codeBeacon({
               message: "<p><strong>Note: this warning will only happen on non-Production pages. It will NOT impact Production.</strong></p><p><strong>Warning!</strong> Page contains Adobe Flash at selector '" + flashSelector + "' -- it needs to be removed or converted to HTML5.</p><p>For more information please refer to this <a href=\"https://cisco.jiveon.com/docs/DOC-1826689\">Jive document</a>.</p>",
               signature: 'cdc.framework.adobeFlashWarning',
               warnUserInStage: true,
               warnUserInProd: false,
               warnUserInProdAuthor: true,
               beaconInStage: true,
               beaconInProd: false,
               beaconInProdAuthor: true,
               density: 1, // always report
               showEachTime: true // always fire
           });
           cdc.debug.log(ns, "end cdc.util.needFlashCodeBeacon()...");
           return true;
       }
       cdc.debug.log(ns, "end cdc.util.needFlashCodeBeacon()...");
       return false;
    },
    /* Below method to give warning message on pages if they have references to
     *  /web/fw/tools/mbox/mbox.js or /web/fw/tools/mbox/mbox-home.js
     */
     mboxFileExist: function (node) {
            var s;
            var fileSelectors = [ // put list of mbox files requires validation
                 '/web/fw/tools/mbox/mbox-home.js',
                 '/web/fw/tools/mbox/mbox.js',
     			'//www.cisco.com/web/fw/tools/mbox/mbox-home.js',
                 '//www.cisco.com/web/fw/tools/mbox/mbox.js',
     			'//www.static-cisco.com/web/fw/tools/mbox/mbox-home.js',
                 '//www.static-cisco.com/web/fw/tools/mbox/mbox.js'
            ];

            if (typeof node === "undefined") {
               node = document;
            }

            cdc.debug.log("begin cdc.util.mboxFileExist()...");
            while (s = fileSelectors.pop()) {
                if (node.querySelector('script[src="'+s+'"]')) {
                    return true;
                }
                cdc.debug.log("-- '" + s + "': no match");
            }
            cdc.debug.log("-- no matches at all");
            cdc.debug.log("end cdc.util.mboxFileExist()");
            return false;
        },
     // if there is any reference to /web/fw/tools/mbox/mbox.js or /web/fw/tools/mbox/mbox-home.js, use codebeacon to alert user
        needMBoxCodeBeacon: function () {
            var ns = "needMBoxCodeBeacon";
            var fileExist = cdc.util.mboxFileExist();
            cdc.debug.log(ns, "begin cdc.util.needMBoxCodeBeacon()...");
            if (fileExist) {
                cdc.debug.log(ns, "-- found WP mbox file references in page, now firing codebeacon");
                cdc.debug.codeBeacon({
                    message: "<p><strong>Warning!</strong> An HTML component on this page contains a reference to \"/web/fw/tools/mbox/mbox.js\" or \"/web/fw/tools/mbox/mbox-home.js\".</p><p> These files have been deprecated and will not work. You will need to do ONE of the following:</p><p><ul><li> (1) convert the mbox HTML code to the \"Mbox, DG Banner\" component OR</li><li>(2) locate the mbox.js or mbox-home.js reference on the page and change the file path to \"/c/dam/cdc/j/at.js\" OR</li><li>(3) delete the mbox code if it is no longer required.</li></ul></p><p><strong>This warning is not visible on live pages.</strong></p>",
                    signature: 'cdc.framework.needMBoxCodeBeacon',
                    warnUserInStage: true,
                    warnUserInProd: false,
                    warnUserInProdAuthor: true,
                    density: 1, // always report
                    showEachTime: true // always fire
                });
                cdc.debug.log(ns, "end cdc.util.needMBoxCodeBeacon()...");
                return true;
            }
            cdc.debug.log(ns, "end cdc.util.needMBoxCodeBeacon()...");
            return false;
         }
};


// CK: should be merged with cdc.util.locale.getLocale's is1xUsaPattern
cdc.util.is1x = (window.location.href.indexOf("/en/US/") > 1);

// mingle #8408 - updated to test for multiple responsive class + bug fix
cdc.util.testResponsive = function () {
    var responsiveRegex = new RegExp('fw-res|fw-satellite');
    return document.body ? responsiveRegex.test(document.body.className) : false;
};
cdc.util.isResponsive = cdc.util.testResponsive();

//IE information object
cdc.util.ieInfo = {
    isIE: false,//flag to verify whether it is IE browser or not
    ieVersion: 0 // Variable to hold IE version
};
//Function to retrieve the IE specific information
/************* USAGE ****************
 cdc.util.getIEinfo.isIE--- returns boolean value,
 cdc.util.getIEinfo.ieVersion -- returns currently used IE version
************************************/
cdc.util.getIEinfo = (function () {
    if (document.attachEvent) { //using feature detection to detect IE Browser
        cdc.util.ieInfo.isIE = true; //setting the IE flag to true
    }

    if (cdc.util.isResponsive) { //Checking for responsive pages
        if ((jQuery('html').is('#ie6,#ie7,#ie8,#ie9'))) {  //Verifying html tag attributes with IE conditional comments
            cdc.util.ieInfo.ieVersion = parseInt(jQuery('html').attr('id').replace(/[^\d]/g, "")); //getting version-returns digit from ids like ie7, ie8, ie9
        }
    } else {// for other 1.x and 2.0 pages
        jQuery('div.ie').each(function () {
            if (jQuery(this).is('#ie6,#ie7,#ie8,#ie9,#gte-ie9')) { //Verifying 'div.ie' tag attributes with IE conditional comments
                cdc.util.ieInfo.ieVersion = parseInt(jQuery(this).attr('id').replace(/[^\d]/g, "")); //getting version-returns digit from ids like ie7, ie8, ie9
            }
        });
    }
    /**** Incase of IE version not retrieved from above steps, which means that page is accessed in standards mode,
    where IE conditional comments won't be applicable and hence using 'navigator.userAgent' to detect version of IE ***/
    if ((cdc.util.ieInfo.isIE) && (cdc.util.ieInfo.ieVersion == 0)) {
        if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) { //test for MSIE x.x;
            cdc.util.ieInfo.ieVersion = new Number(RegExp.$1) // capture x.x portion and store as a number
        }
    }
    return cdc.util.ieInfo;
}());

// why is this here and not in its own or a different file?
cdc.mru = {
    ignore: function () {},
    serviceHost: cdc.util.findEnvironment() != 'prod'?"//www-stage.cisco.com":"//www.cisco.com",
    serviceUrl: "/cisco/web/cdc/psa/mru?command=update&callbackFunctionName=cdc.mru.ignore",

    // this is the request when it is sent from a page
    addToMruList: function (mdfId, locale) {
        // errors if this returns login page
        cdc.util.checkLogin( function () {
            if (cdc.util.authStatus == "valid") {
                var updateUrl = cdc.mru.serviceHost + cdc.mru.serviceUrl + "&task=default&nodeId=" + mdfId + "&type=product&locale=" + locale;
                jQuery("head").append("<script src='" + updateUrl + "'></script>");
            }
        });
    },
    // legacy request from psa, one search, and support home page
    // only for sites that don't have their own model pages
    // theoretically eventually deletable
    makeMruRequest: function (anchor, args) {
        // errors if this returns login page
        cdc.util.checkLogin( function () {
            if (cdc.util.authStatus == "valid" ) {
                var updateUrl = cdc.mru.serviceHost + cdc.mru.serviceUrl;
                if (args) {
                    updateUrl += args;
                } else if (anchor.mruExpando) {
                    updateUrl += anchor.mruExpando;
                } else if (anchor.rel) {
                    updateUrl += anchor.rel;
                }
                jQuery("head").append("<script src='" + updateUrl + "'></script>");
            }
        });
    }
};


/* logout dialog box gets shown to all platforms except IE 6, when logout clicked, if js is enabled. */
//if (!(jQuery.browser.msie && jQuery.browser.version < "7")) jQuery('.ft-logout a[href]').live('click', cdc.util.logoutdialog.show);
if (!(cdc.util.getIEinfo.isIE && (cdc.util.getIEinfo.ieVersion < 7))) jQuery(document).on('click','.ft-logout a[href]', cdc.util.logoutdialog.show); //updated replacement of .browser property and .live() for jquery version 1.10.2.

// When the DOM is ready, see if there is any Adobe Flash in the page - if so, trigger a codebeacon
// -- if the first call does not set a beacon, delay one second and try again to catch any AJAXed content
jQuery(document).ready(function () {
   cdc.debug.log("onReady", "begin flash codebeacon...");
   if (!cdc.util.needFlashCodeBeacon()) {
      cdc.debug.log("onReady", "-- codebeacon did not trigger, adding setTimeout for 1000 ms...");
      setTimeout(cdc.util.needFlashCodeBeacon, 2000);
   }
   cdc.debug.log("onReady", "end flash codebeacon...");
});

//When the DOM is ready, see if there is any references to /web/fw/tools/mbox/mbox.js or /web/fw/tools/mbox/mbox-home.js in the page - if so, trigger a codebeacon
//-- if the first call does not set a beacon, delay one second and try again to catch any AJAXed content
jQuery(document).ready(function () {
cdc.debug.log("onReady", "begin WP Mbox codebeacon...");
if (!cdc.util.needMBoxCodeBeacon()) {
 cdc.debug.log("onReady", "-- codebeacon did not trigger, adding setTimeout for 1000 ms...");
 setTimeout(cdc.util.needMBoxCodeBeacon, 2000);
}
cdc.debug.log("onReady", "end WP Mbox codebeacon...");
});

//Mingle 10075/10469 - Find root relative WEM links and replace with absolute links
cdc.util.wwwin_subdomain = function (obj) {
    var csi;
    for (csi = 0; csi < obj.length; csi++) {
        currentSubdomain = obj[csi].currentSubdomain;
        var host = window.location.host;
        var currentSubdomainString = new RegExp(currentSubdomain);

        // executes below steps further if the condition satisfies.
        if (currentSubdomainString.test(host) === false) {
            continue;
        }

        var sendingRules = obj[csi].sendingRules;
        var sendtourl, currentSelector = "";
        var sendWhen, matchWithin = [];

        for (var sr = 0; sr < sendingRules.length; sr++) {
            //assigning to temp variables
            sendtourl = sendingRules[sr].sendTo;
            sendWhen = sendingRules[sr].sendWhen;
            matchWithin = sendingRules[sr].matchWithin;
            // Looping matchWithin
            jQuery(matchWithin).each(function (key, matchWithinElement) {
                // Looping sendWhen
                jQuery(sendWhen).each(function (key1, sendWhenLinkStartsWith) {
                    currentSelector = matchWithinElement + " a[href^='" + sendWhenLinkStartsWith + "']";
                    jQuery(currentSelector).each(function (linkN, linkToUpdate) {
                        jQuery(linkToUpdate).attr('href', sendtourl + jQuery(linkToUpdate).attr('href'));
                    });
                });
                //End sendWhen..
            });
            // End matchWithin
        } // end for...sr( sendrules)
    } // end for csi..( current subdomainindex)
};

// start cdc.debug object

cdc.debug = (function () {
    var namespace = "debug",
        debugOn,
        debugLibs = [],
        currentEnv = cdc.util.findEnvironment();

    if (window.console === undefined) {
        console = { log: function () { return; } };
    }

    /**
    Use the codebeacon when you want to report on the usage or impact of a given piece of code, and/or when you want to warn people that a deprecated piece of code is going away

    Typical usage:

    cdc.debug.codeBeacon ({
        message: componentId,
        signature: "cdc.cl.componentSurvey",
        warnUserInStage: false,
        warnUserInProd: false,
        warnUserInProdAuthor: false,
        beaconInStage: true
        beaconInProd: false,
        beaconInProdAuthor: false,
        dateFrom: '2016-06-23', //'2016-06-01T00:00:00',
        dateTo: '2016-06-25', //'2016-06-22T23:59:59',
        density: 0,
        showEachTime: false
    });

    Description of fields:
        signature: "use this to distinguish this particular usage from other purposes for which beacon is used",
        message: "use this to indicate further information about this particular call to the beacon (note that time of day and URL of calling page are automatically captured)"
        warnUserInStage: "boolean, set to true to give the user a modal warning when this method is called in a non-prod page view.",
        warnUserInProd: "boolean, set to true to give the user's modal warning when this method is called in a prod page view.",
        warnUserInProdAuthor: "boolean, set to true to give the user's modal warning when this method is called in a prod-author page view.",
        beaconInStage: "boolean, set to true to have data sent to the mongo DB"
        beaconInProd: "boolean, no matter what you set it to it won't do anything because we don't have prod logging",
        beaconInProdAuthor: "boolean, set to true to have data sent to the mongo DB from prod-author pages"
        dateFrom: "Date string, set to enable warnings and beacon between two dates. Format: '2016-06-23' or '2016-06-01T00:00:00'",
        dateTo: "Date string, set to enable warnings and beacon between two dates. Format: '2016-06-23' or '2016-06-01T00:00:00'",
        density: "0/1/.5, set 1 to always fire beacon, 0 to never fire beacon, .5 to fire beacon half the time",
        showEachTime: "if set 'true', will fire each time despite local storage caching of page url"

    **/

    function codeBeacon(configObj) {
       var bDateFlag = true;
       var wDateFlag = true;
       var bDensityFlag = false;
       var wShowFlag = true;
       var signature = configObj.signature;

       if (configObj.dateFrom !== null && new Date(configObj.dateFrom).toString() !== "Invalid Date" && configObj.dateTo !== null && new Date(configObj.dateTo).toString() !== "Invalid Date") { // checking if from and to dates are set
          var dateCheck = new Date().getTime();
          var dateFrom = new Date(configObj.dateFrom).getTime();
          var dateTo = new Date(configObj.dateTo).getTime();

          if (dateFrom > dateCheck || dateCheck > dateTo) { // checking if current date falls outside of from and to dates
             bDateFlag = false; // setting bDateFlag and wDateFlag to false if current date is outside from and to dates
             wDateFlag = false;
          }
       }

       if (configObj.density > 0) { // checking if density is greater than 0 and setting density flag to true incase Storage is not supported
          bDensityFlag = true;
       }

       if (typeof(Storage) !== "undefined") {
          var currentPage = window.location.href;
          var cbStorage = localStorage;
          var retrievedSignatures = JSON.parse( cbStorage.getItem('beacon_signatures') ); // retrieve the already stored object from storage

          if (retrievedSignatures == null) { //initialing if retrievedObject is null
             retrievedSignatures = {};
          }

          if (retrievedSignatures[signature] === undefined) {
             retrievedSignatures[signature] = {};
          }

          if (retrievedSignatures[signature].warningurls === undefined) {
             retrievedSignatures[signature].warningurls = new Array;
          }

          /** code to show warning to the user only once */
          if (jQuery.inArray(currentPage, retrievedSignatures[signature].warningurls) === -1) { // checking if current page is in storage
             wShowFlag = true; // redundant, was initialized as true...
             retrievedSignatures[signature].warningurls.push(currentPage); // add new page to retrivedObject
          } else if (! configObj.showEachTime) {
             wShowFlag = false;
          }

          /** code to fire beacon if density is between 0-1 */
          if (configObj.density !== null) {
             var cdensity   = Math.round( (configObj.density * 10) );
             var density    = retrievedSignatures[signature].density;
             var visitCount = retrievedSignatures[signature].visitCount;
             var densityArr = retrievedSignatures[signature].densityArr;

             if (density === undefined || density != cdensity) {
                density    = cdensity;
                visitCount = undefined;
                densityArr = undefined;
             }

             if (visitCount === undefined || visitCount > 10) {
                visitCount = 1;
             }

             if (densityArr === undefined || visitCount === 1) {
                densityArr =  [0,0,0,0,0,0,0,0,0,0];

                var i = 1;
                while (i <= density) {
                   var x = Math.floor(Math.random()* 10);
                   if (densityArr[x] !== 1) {
                      densityArr[x] = 1;
                      i++;
                   }
                }
             }

             if (densityArr[visitCount-1] === 1) {
                bDensityFlag = true;
             } else {
                bDensityFlag = false;
             }

             //console.log(densityArr);
             //console.log("Signature: "+ signature + "Visit:" + visitCount + " ShowFlag: " + bDensityFlag);

             retrievedSignatures[signature].density    = density;
             retrievedSignatures[signature].visitCount = visitCount+1;
             retrievedSignatures[signature].densityArr = densityArr;
          }

          cbStorage.setItem('beacon_signatures', JSON.stringify(retrievedSignatures));
       }

       if (window.location.hostname.match(/wemapp-author-prod[0-9][0-9]*-[0-9]*.cisco.com|www-author.cisco.com/)) {
          if (configObj.warnUserInProdAuthor && wDateFlag && wShowFlag) { cdc.debug.beaconModal(configObj); }
          if (configObj.beaconInProdAuthor && bDateFlag && bDensityFlag) { cdc.debug.callBeacon(configObj); }
       } else if (currentEnv === "stage" || currentEnv === "dev") {
          if (configObj.warnUserInStage && wDateFlag && wShowFlag) { cdc.debug.beaconModal(configObj); }
          if (configObj.beaconInStage && bDateFlag && bDensityFlag) { cdc.debug.callBeacon(configObj); }
       } else {
          if (configObj.warnUserInProd && wDateFlag && wShowFlag) { cdc.debug.beaconModal(configObj); }
          if (configObj.beaconInProd && bDateFlag && bDensityFlag) { cdc.debug.callBeacon(configObj); }
       }

    } // end codeBeacon()

    /**
     *  Utility functions to store the codebeacons in to mongodb
     *  will be called on methods to store
     *  These utility functions will be used by pages developed using masterbrand, responsive, and satellite framework
     *  $Revision: 1.0 $
     *
     * callBeacon is a utility function used by the function codeBeacon
     */
    function callBeacon(configObj) {
        var beaconUrl = "//hoth.cisco.com/api/codebeacons/create"; // use hoth until codebeacon1 is provisioned and set up
        var ns = 'codeBeacon';
        var beaconData = {
           'message'  : configObj.message,
           'signature': configObj.signature,
           'url'      : window.location.href || '',
           'hostname' : window.location.hostname || '',
           'referrer' : document.referrer || '',
           'date'     : Date()
        }

        cdc.debug.log(ns, "Begin cdc.debug.callBeacon()...");
        cdc.debug.log(ns, "-- svc url: " + beaconUrl);
        cdc.debug.log(ns, "-- post params: " + JSON.stringify(beaconData));

        jQuery.ajax({
            type: "POST",
            url: beaconUrl,
            dataType: 'json',
            data: beaconData,
            crossDomain: true,
            success: function (data, status, jqXHR) {
                cdc.debug.log(ns, "-- Ajax Success");
                cdc.debug.log(ns, "End cdc.debug.callBeacon()");
            },
            error: function (jqXHR, status) {
                cdc.debug.log(ns, "-- Ajax Failure; Message: " + status.code);
                cdc.debug.log(ns, "End cdc.debug.callBeacon()");
            }
        });
    } // end callBeacon()

    /**
     *  Utility functions to report jquery deprecated features
     *  used on specific page on model window
     *  These utility functions will be used by pages developed using masterbrand, responsive, and satellite framework
     *  $Revision: 1.0 $
    */
    function beaconModal(configObj) {
        var ns = 'beaconModal';

        if (cdc.debug.beaconModalActive) {
            cdc.debug.log(ns, "appending to existing beacon modal");
            var modalMessages = document.getElementById('codebeacon-messages');
            var modal = document.createElement('div');
            modalMessages.appendChild(modal);
            modal.innerHTML = '<div style="border-top:1px solid #888">' + configObj.message + '</div>';
            return;
        }

        if (configObj.signature=="cdc.framework.ieWarning") {
            cdc.debug.log(ns, "creating and inserting IE warning beacon modal");
            var cssReset = "margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-size:100%;font-family:inherit;color:inherit;line-height:1.5;",
            innerModalStyle = cssReset + 'height: 40px;font-size:12px;text-align:center;margin:0px;padding:5px;' + 'overflow:auto;background:#fefdde;',
            body = document.getElementsByTagName('body')[0],
            modal = document.createElement('div'),
            buttonCss="color:#ffffff;font-size:13px;background-color:#999999;font: bold 11px Arial; width:80px;height:18px;text-decoration: none;margin:0px 0px 0px 10px;padding: 6px 6px 6px 6px;border: 1px solid #CCCCCC;border-radius:6px;position:relative;top:-5px";

            modal.id = 'ie-modal';
            $("body").prepend(modal);
            modal.style.cssText = cssReset + 'text-align:left;letter-spacing:0;' + 'z-index:1999999;' + 'font:12px/13px \'Helvetica Neue\', Verdana, Arial, sans serif;' + 'width:100%;';
            modal.innerHTML = '<div style="' + innerModalStyle + '"><div><span style=\"background:url(/etc/designs/cdc/fw/w/cl/a03/alert_30x30.png) no-repeat;display:inline-block;width:51px;height:30px\"></span><span style=\"display:inline-block;height:30px;margin-left:15px;vertical-align:middle;color:#999999;\"> ' + configObj.message + ' </span> <a target="_blank" href="http://windows.microsoft.com/en-us/internet-explorer/download-ie" style="' + buttonCss + '"> ' + 'Upgrade Now' + '</a>' + ' </div></div>';
            if ($('body').css('background-image') != 'none') {
                $("body").css("background-position","0 -1676px")
            }
        } else {
            cdc.debug.log(ns, "creating and inserting inital beacon modal");
            var cssReset = "margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-size:100%;font-family:inherit;vertical-align: baseline;color:inherit;line-height:inherit;",
            innerModalStyle = 'max-height:400px;margin:10px;padding:10px;overflow:auto;' + 'background:#fff;border:2px solid #abcdef;' + 'box-shadow: 0px 2px 40px rgba(0,0,0,0.5);' + '-webkit-box-shadow: 0px 2px 40px rgba(0,0,0,0.5);' + '-webkit-transition:-webkit-transform ease-out 0.3s;' + 'border-radius:9px;-moz-border-radius:9px;-webkit-border-radius:9px;',
            body = document.getElementsByTagName('body')[0],
            closeButton = '<div style="float: right;cursor:pointer" onclick="var r=document.getElementById(\'jquery-modal\');r.parentNode.removeChild(r);"><img src="//www.cisco.com/etc/designs/cdc/fw/i/close-button.gif" /></div>',
            closeLink = '<span style="color:#888;font-size:10px;text-decoration:underline;cursor:pointer" onclick="var r=document.getElementById(\'jquery-modal\');r.parentNode.removeChild(r);">' + 'Close</span>',
            modal = document.createElement('div');

            modal.id = 'jquery-modal';
            body.appendChild(modal);
            modal.style.cssText = cssReset + 'text-align:left;z-index:1000000;letter-spacing:0;' + 'position:fixed;top:20%;left:20%;width:60%;color:#444;' + 'font:12px/13px \'Helvetica Neue\', Verdana, Arial, sans serif';
            // populate modal
            modal.innerHTML = '<div style="' + innerModalStyle + '">' + closeButton + '<div id="codebeacon-messages" style="clear: both;"><div><p>Please contact Cisco.com\'s front end team at <b>id-only@cisco.com</b> for details or to answer questions.</p></div><div>' + configObj.message + '</div></div><div>' + closeLink + '</div></div>';
            cdc.debug.beaconModalActive = true;
        }
    } // end beaconModal()

    function warningIe() {
        if (!window.atob) {
            var modalData = "Upgrade your <a target=\"_blank\" href=\"http://windows.microsoft.com/en-us/internet-explorer/download-ie\">Internet Explorer </a>  browser for a better Cisco.com experience"
            var beaConfigObj = {
                message: modalData,
                signature: 'cdc.framework.ieWarning',
                warnUserInStage: true,
                warnUserInProd: true,
                warnUserInProdAuthor: true,
                beaconInStage: true,
                beaconInProd: false,
                density: 1, // always log
                beaconInProdAuthor: false
            };
            if (modalData.length > 0) { cdc.debug.codeBeacon(beaConfigObj); }
        } // call to cdc.debug.codeBeacon...
    }

    /**
     * Turns debug mode on by parsing the url and looking for the following get variables:
     *          debugJS - boolean
     *          debugLibs - string with specified libraries separated by commas that the developer wants shown (i.e. debugLibs=mqo,mm)
     *          secret - string only used for production environments that needs to contain the appropriate value in order to enable debug operations
     *
     * @returns {boolean} returns true if debug mode is on
     */
    function debugModeOn() {
        // Only want to run the logic operations once
        if (debugOn === undefined) {
            var sha1 = 'da39a3ee5e6b4b0d3255bfef95601890afd80709',
                secret;
            //  Note: IE8 does not have array method forEach, using jQuery.each() instead
            jQuery.each(location.search.substr(1).split('&'), function (idx, item) {
                var keyval = item.split('=');
                switch (keyval[0]) {
                case 'debugJS':
                    debugOn = (keyval[1] === 'true');
                    break;
                case 'debugLibs':
                    if (keyval[1] !== '') { debugLibs = keyval[1].split(','); }
                    break;
                case 'secret':
                    secret = keyval[1];
                    break;
                default:
                    break;
                }
            });
            // Allow production use of debugJS only if the secret matches
            if (currentEnv === 'prod' && sha1 !== secret) { debugOn = false; }
            if (debugOn) {
                var msg = 'console log statements on';
                if (debugLibs.length > 0) { msg += ' for these namespaces: ' + debugLibs.toString(); }
                cdc.debug.log(namespace, msg);
            }
        }
        return debugOn;
    }

    /**
     * If debug mode on, this function will echo the msg param via the specified console method in two scenarios:
     *      1. debugLibs is null - meaning all .log requests will be printed to the console
     *      2. A lib that matches an array value of defaultlibs
     *
     * @param consoleMethod - corresponds to the console method that is to be used by consoleHandler
     * @param lib {string} - corresponds to the library the message is being sent from
     * @param msg {string or object} - corresponds to the message to be printed to the console
     */
    function consoleHandler(consoleMethod, lib, msg) {
        // Note: IE8 does not allow you to use .indexOf for searching for values in arrays, using jQuery.inArray instead
        var isDebugModeOn = debugModeOn(),
            includedInWhiteList = (debugLibs.length === 0 || jQuery.inArray(lib, debugLibs) >= 0);

        // if conditions are met, log the msg parameter using the appropriate console method
        if (isDebugModeOn && includedInWhiteList && msg !== undefined) {
            console.log(lib, ':');
            consoleMethod(typeof msg === "object" ? JSON.parse(JSON.stringify(msg)) : msg);
        }
    }

    /**
     * Wrapper function that invokes the console.log method
     *
     * @param lib {string} - corresponds to the library the message is being sent from
     * @param msg {string or object} - corresponds to the message to be printed to the console
     */
    function log(lib, msg) {
        var logPointer;
        if (console.log.bind !== undefined) {
            logPointer = console.log.bind(console);
        } else {
            logPointer = function (m) { return console.log(m); };
        }
        consoleHandler(logPointer, lib, msg);
    }

    /**
     * Wrapper function that invokes the console.dir method via consoleHandler method
     * Note: console.dir is not supported by IE8 therefore, any references to cdc.debug.dir are redirected to cdc.debug.log
     *
     * @param lib {string} - corresponds to the library the message is being sent from
     * @param msg {string or object} - corresponds to the message to be printed to the console
     */
    function dir(lib, msg) {
        if (console.dir !== undefined) {
            consoleHandler(console.dir.bind(console), lib, msg);
        } else {
            log(lib, msg);
        }
    }

    return {
        codeBeacon: codeBeacon,
        callBeacon: callBeacon, // See the implementation of this function above
        beaconModal: beaconModal,
        warningIe: warningIe,
        debugModeOn: debugModeOn,
        log: log,
        dir: dir,
        dump: function () { return; },
        alert: function () { return; }
    };
}());

cdc.util.linkreplacement_genericrules = {
    "CECPaths": ["/c/cec", "/employee"],
    "CDCPaths": ["/c/en/us", "/c/cdc", "/web", "/cisco", "/content/en/us","/c/login"],
    "matchWithin": ["#fw-search", "#fw-fatfooter", "#ff", "#fw-banner", "#framework-column-left", ".nn11v1", "#nn08v1", "#fw-utility"]
};
cdc.util.linkreplacement_object = [
{
    "currentSubdomain": "www.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//support.cisco.com",
        "sendWhen": ["/support"],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
}, {
    "currentSubdomain": "wwwin.cisco.com",
    "sendingRules": [{
        "sendTo": "https://www.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//support.cisco.com",
        "sendWhen": ["/support"],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "https://www.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
}, {
    "currentSubdomain": "garlic.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "https://www.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "https://www.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//support.cisco.com",
        "sendWhen": ["/support"],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
}, {
    "currentSubdomain": "www-stage.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-stage.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "wwwin-stage.cisco.com",
    "sendingRules": [{
        "sendTo": "//www-stage.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//fdk-stage.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "www-dev.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-fdk-devint.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "wwwin-dev.cisco.com",
    "sendingRules": [{
        "sendTo": "//fdk-devint.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//fdk-devint.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "fdk-devint.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-fdk-devint.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "wwwin-fdk-devint.cisco.com",
    "sendingRules": [{
        "sendTo": "//fdk-devint.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//fdk-devint.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "www-fdk-pstage.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-fdk-stage.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "www-fdk-stage.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-fdk-stage.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "wwwin-fdk-stage.cisco.com",
    "sendingRules": [{
        "sendTo": "//www-fdk-stage.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//www-fdk-stage.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "www-fdk-lt.cisco.com",
    "sendingRules": [{
        "sendTo": "//wwwin-fdk-lt.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CECPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
},{
    "currentSubdomain": "wwwin-fdk-lt.cisco.com",
    "sendingRules": [{
        "sendTo": "//www-fdk-lt.cisco.com",
        "sendWhen": cdc.util.linkreplacement_genericrules['CDCPaths'],
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }, {
        "sendTo": "//www-fdk-lt.cisco.com",
        "sendWhen": ["/c/dam/global"], // megamenu content
        "matchWithin": cdc.util.linkreplacement_genericrules['matchWithin']
    }]
}

]; // End linkreplacement_object array..

jQuery(window).ready(function () {
    if (cdc.debug) {
        cdc.util.wwwin_subdomain(cdc.util.linkreplacement_object);
        cdc.debug.warningIe();
    }
});

Object.defineProperty(cdc.util, "authStatus", {
  get: function () {
    return cdc.context.authStatus;
  },
  set: function(val) {
    cdc.context.authStatus = val;
  },
  enumerable: true,
});

Object.defineProperty(cdc.util, "checkLoginQueue", {
  get: function () {
    return cdc.context.checkLoginQueue;
  },
  set: function(val) {
    cdc.context.checkLoginQueue = val;
  },
  enumerable: true,
});

/*
*
* userInfoDispatcher.js
*
*   (c) 1992-2011 Cisco Systems, Inc. All rights reserved.
*   Terms and Conditions: http://cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
*
*

Example API Call
//cdc.userInfoDispatcher.clearCache();

cdc.userInfoDispatcher.getUserProfile ({
"listOfDataFields": [
'cps.city_name',
'vps.cisco_interfaces_and_modules',
'locale.country_code'
],
"callback": function (userProfile) {
console.log(userProfile.cps.city_name);
console.log(userProfile.locale.country_code);
}
});
*/

if(typeof cdc == 'undefined') var cdc = {};


if(typeof cdc.userInfoDispatcher === 'undefined') {

  /**
  * Provides a unified API for interacting with multiple services for user data and makes cacheing of user data transparent to the consumer.
  * @type {object}
  */
  cdc.userInfoDispatcher = new function() {

    // Uncomment the 3 lines below if you want debug logging
    // cdc.debug.log = function () {
    //     console.log.apply (console, ["cdc.debug.log"].concat (arguments));
    // }


    /** Authentication status of user: Will be one of "unknown", "loggedIn" or "anonymous". */
    var _loggedInState = 'unknown';


    /** Object containing service URLs to retrieve user information for known environments. */
    var SERVICE_URLS = {
      dev: {
        CPS_AUTH_URL: '//mktcs-dev.cloudapps.cisco.com/visitor/profile',
        VPS_AUTH_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile',
        VPS_GUEST_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/virtualprofile',
        CINF_AUTH_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=wem',
        CINF_GUEST_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=wem',
        PHL_AUTH_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=partnerhelpline',
        PHL_GUEST_URL: '//cdcvps-dev.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=partnerhelpline',
        BLUEKAI: '//tags.bluekai.com/site/27647?ret=js&limit=1&jscb=bluekaiCallback',
        LOCALE_GUEST_URL: '//www.cisco.com/web/fw/co/i/s.gif?t=' + Math.random(),
        PROFOUND_URL: 'https://bapi.profound.net/?key=cisco-at-0e8a181c345311e&callback=profoundCallback'
      },
      stage: {
        CPS_AUTH_URL: '//mktcs-stage.cloudapps.cisco.com/visitor/profile',
        VPS_AUTH_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile',
        VPS_GUEST_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/virtualprofile',
        CINF_AUTH_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=wem',
        CINF_GUEST_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=wem',
        PHL_AUTH_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=partnerhelpline',
        PHL_GUEST_URL: '//cdcvps-stage.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=partnerhelpline',
        BLUEKAI: '//tags.bluekai.com/site/27647?ret=js&limit=1&jscb=bluekaiCallback',
        LOCALE_GUEST_URL: '//cloudsso-test.cisco.com/web/fw/co/i/s.gif?t=' + Math.random(),
        PROFOUND_URL: 'https://bapi.profound.net/?key=cisco-at-0e8a181c345311e&callback=profoundCallback'
      },
      prod: {
        CPS_AUTH_URL: '//mktcs.cloudapps.cisco.com/visitor/profile',
        VPS_AUTH_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile',
        VPS_GUEST_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/virtualprofile',
        CINF_AUTH_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=wem',
        CINF_GUEST_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=wem',
        PHL_AUTH_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/psn/virtualprofile?groupName=partnerhelpline',
        PHL_GUEST_URL: '//cdcvps.cloudapps.cisco.com/support/cdcvps/virtualprofile?groupName=partnerhelpline',
        BLUEKAI: '//tags.bluekai.com/site/27647?ret=js&limit=1&jscb=bluekaiCallback',
        LOCALE_GUEST_URL: '//www.cisco.com/web/fw/co/i/s.gif?t=' + Math.random(),
        PROFOUND_URL: 'https://bapi.profound.net/?key=cisco-at-0e8a181c345311e&callback=profoundCallback'
      }
    };


    /** The current environment. */
    var environ = cdc.context.findEnvironment();
    if (SERVICE_URLS[environ] == null) environ = 'prod';                        // Unknown environment, don't cause an error


    // /** Number of milliseconds to wait for requested data because jQuery < 1.5 cannot detect 500 server error codes on JSONP requests. */
    // var CATCHALL_TIMEOUT_MSEC = 3000; // TODO: DELETE


    /** Number of milliseconds to wait for response to request for data from a known service. */
    var TIMEOUT_MSEC = 3000;


    /**
    * Object mapping country codes to language codes.
    *
    * @constant
    * @type {object}
    */
    var COUNTRY2LANG = {
      AE: 'en',
      AR: 'es',
      AT: 'de',
      AU: 'en',
      BE: 'en',
      BR: 'pt',
      CA: 'en',
      CH: 'de',
      CL: 'es',
      CN: 'zh',
      CO: 'es',
      CR: 'es',
      CU: 'es',
      CZ: 'cs',
      DE: 'de',
      DK: 'da',
      DO: 'es',
      EC: 'es',
      EG: 'ar',
      ES: 'es',
      FI: 'fi',
      FR: 'fr',
      GB: 'en',
      GR: 'en',
      GT: 'es',
      HK: 'en',
      HN: 'es',
      HU: 'hu',
      ID: 'en',
      IL: 'en',
      IN: 'en',
      IT: 'it',
      JP: 'ja',
      KR: 'ko',
      LU: 'fr',
      MX: 'es',
      MY: 'en',
      NI: 'es',
      NL: 'nl',
      NO: 'no',
      NZ: 'en',
      PA: 'es',
      PE: 'es',
      PH: 'en',
      PL: 'pl',
      PR: 'es',
      PT: 'pt',
      PY: 'es',
      RO: 'ro',
      RU: 'ru',
      SA: 'en',
      SE: 'sv',
      SG: 'en',
      SV: 'es',
      TH: 'th',
      TR: 'tr',
      TW: 'zh',
      UA: 'ru',
      US: 'en',
      UY: 'es',
      VE: 'es',
      VN: 'vi',
      ZA: 'en'
    };


    /**
    * Object containing instances of the `Service` or `ServiceResponseHeader` objects, keyed by the names of known services.
    *
    * @constant
    * @type {object}
    */
    var _KNOWN_SERVICES = {
      cps: new Service('cps', SERVICE_URLS[environ].CPS_AUTH_URL, SERVICE_URLS[environ].CPS_AUTH_URL, 'contact'),
      vps: new Service('vps', SERVICE_URLS[environ].VPS_AUTH_URL, SERVICE_URLS[environ].VPS_GUEST_URL, 'response/attributes'),
      contactInfo: new Service('contactInfo', SERVICE_URLS[environ].CINF_AUTH_URL, SERVICE_URLS[environ].CINF_GUEST_URL, 'response/attributes'),
      locale: new ServiceResponseHeader('locale', SERVICE_URLS[environ].LOCALE_GUEST_URL, 'X-Akamai-Edgescape'),
      phl: new Service('phl', SERVICE_URLS[environ].PHL_AUTH_URL, SERVICE_URLS[environ].PHL_GUEST_URL, 'response/attributes'),
      bluekai: new JsonpRequest('bluekai', SERVICE_URLS[environ].BLUEKAI),
      eloqua: new CacheUpdate('eloqua'),
      profound:new JsonpRequest('profound', SERVICE_URLS[environ].PROFOUND_URL)
    };


    /**
     * Marks performance when supported by browser.
     *
     * @param  {String}  label  The unique key that identifies the performance mark.
     */
    var markPerformance = function(label) {
      if(typeof performance !== 'undefined' && typeof performance.mark !== 'undefined') {
        performance.mark(label);
      };
    };


    /**
     * Persists profile updates that have been passed as arguments to local storage without making any service requests.
     *
     * @param  {String}  namespace  The name/key for the service.
     */
    function CacheUpdate(namespace) {
      this.callService = function(state, callback) {
        if (state.requiresWrappedResponse) {
          state.params.profileUpdates.forEach(function (profileUpdate) {
            if (profileUpdate.key === namespace) {
             var data = {};
              data[profileUpdate.key] = profileUpdate.value;
              callback(data);
            };
          });
        } else {
          console.warn('WARNING: `getUserProfile` does not support requests for ', namespace, '.')
        };
      };
    };


    /**
     * Loads BlueKai tag which declares a global `bk_results` variable to deliver data.
     *
     * @param  {String}  namespace  The name/key for the service.
     * @param  {String}  url        The third-party tag URL to call, which we expect to assign data to a global variable.
     */
    function JsonpRequest(namespace, url) {

      this.callService = function(state, callback) {

        if (state.requiresWrappedResponse) {

          var that = {
            state: state,
            callback: callback
          };
          var catchAll;

          var synchronicity = state.params.delayForData ? '' : ' async';

          var callBackFunction = function (obj) {
            var response = {};
            var parserFunction = that.state.params.parserFunctions[namespace];
            var hasParserFunction = typeof parserFunction !== 'undefined';
            response[namespace] = hasParserFunction ? parserFunction(obj) : obj; // here when required we execute a parser function to shape the service results
            that.state.params.callbackFunctions[namespace](response); // calls the callback specified for this service request
            that.callback(response); // pass data back in response
            if (state.params.async) clearTimeout(catchAll);
          };

          var injectScript = function() {
            var scripts = document.getElementsByTagName('script')[0];
            var s = document.createElement('script');
            s.classList.add('asyncScript');
            s.src = url;
            s.id = namespace;
            scripts.parentNode.appendChild(s, scripts);
          };

          window[namespace + 'Callback'] = callBackFunction;

          markPerformance(namespace + ' injected');
          if (!state.params.async) {
            document.write('<script id="' + namespace + '" type="text/javascript" src="' + url + '"' + synchronicity + '></script>');
          } else {
            injectScript();
            var remaining = state.params.timeoutPoint - Date.now();
            var timeoutValue = (remaining > 0) ? remaining : 1;
            catchAll = setTimeout(function() {
              var obj = {};
              that.callback(obj);
              markPerformance('UID timed out for ' + namespace);
            }, timeoutValue);
          }

        } else {
          console.warn('WARNING: `getUserProfile` does not support requests for ', namespace, '.')
        };

      };
    };


// ----------------------------------------------------------------------


    /**
    * Vanilla JS version to replace `jQuery.extend()`.
    *
    * @returns  {Object}  result of merging of objects
    */
    var _extend = function () {
      // Variables
      var extended = {};
      var deep = false;
      var i = 0;
      var length = arguments.length;
      // Check if a deep merge
      if ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {
        deep = arguments[0];
        i++;
      }
      // Merge the object into the extended object
      var merge = function (obj) {
        for ( var prop in obj ) {
          if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {
            // If deep merge and property is an object, merge properties
            if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {
              extended[prop] = extend( true, extended[prop], obj[prop] );
            } else {
              extended[prop] = obj[prop];
            }
          }
        }
      };
      // Loop through each object and conduct a merge
      for ( ; i < length; i++ ) {
        var obj = arguments[i];
        merge(obj);
      }
      return extended;
    };


    /**
    * The object mapping each service name to its queue of pending requests.
    *
    * @type {Object}
    */
    var _pendingRequests = {};


// ----------------------------------------------------------------------


    /** Object responsible for handling requests for profile data. */
    var RequestHandler = new function() {

      /**
      * Determines service to be invoked (because their data is stale or unavailable in cache).
      *
      * @param   {Object}  profile                         The user data object.
      * @param   {String}  loginState                      The user's authentication status.
      * @param   {Object}  requestParameters               The parameter packet for this invocation.
      * @param   {Array}   requestParameters.serviceNames  The service names necessary to fulfill the request.
      * @returns {Array}                                   The names of services that require fresh data.
      */
      var _getServicesToCall = function(profile, loginState, requestParameters) {
        var servicesToCall = [];
        if (_cache.isStale(loginState)) {
          servicesToCall = requestParameters.serviceNames;
        }
        else {
          requestParameters.serviceNames.forEach(function(serviceName) {
            if (profile == null || profile[serviceName] == null) {
              servicesToCall.push(serviceName);
            }
          });
        }
        return servicesToCall;
      };


      /**
      * Responds if all data is available and populates the request queue if it isn't.
      *
      * @param  {Object}  requestParameters  The parameter packet for this invocation.
      * @param  {String}  loginState         The user's authentication status.
      */
      var _handleProfileRequest = function (requestParameters, loginState) {

        // USECASE 2 - step 2 and 3 - get local storage and compare with cookie value
        if (localStorage.getItem('userInfoDispatcher') != null) {
            var info = JSON.parse(localStorage.getItem('userInfoDispatcher'));
        }

        cookieInfo = (document.cookie.match(/^(?:.*;)? cdcUniqueKey=([^;]+)(?:.*)?$/) || [, null])[1];

        if (info != null) {
            if (cookieInfo == info.token && cookieInfo!='none') {

            } else {
                _cache.clear();
            }
        }

        /** Make sure we have the current login state of the user. */
        _loggedInState = loginState;


        /**
        * The persisted user data.
        *
        * @type {object}
        */
        var profile = _cache.getProfile(_loggedInState);


        /**
        * The list of service names for which we have no persisted data.
        *
        * @type {Array}
        */
        var requests = _getServicesToCall(profile, loginState, requestParameters);

        var state = {
            params: requestParameters,
            loginStatus: {
              value: loginState
            },
            response: {
              profileData: {},
              requests: {
                queuedServices: requests,
                completed: []
              }
            },
            requiresWrappedResponse: false
        };
        state.params.async = true;

        if (requests.length > 0) { // first populate the request queue then respond later because data is missing.
          _queueRequests(state);
        } else { // respond now with the previously persisted data.
          _respondWith(
            profile,
            requestParameters.listOfDataFields,
            requestParameters.callback
          );
        }
      };


      /**
      * Retrieves persisted profile information and determines what additional data must be requested from services. TODO: FIX JSDOC BLOCK
      *
      * @param  {object}    requestParameters                   Configuration object having four keys: serviceNames, listOfDataFields, callback, delayForData.
      * @param  {object}    requestParameters.serviceNames      The service names necessary to fulfill the request.
      */
      this.process = function (requestParameters) {
        var loginStatus = _getLoginState();
        if (loginStatus.requiresLoginCheck) {
          cdc.context.checkLogin(function() {
            _handleProfileRequest(requestParameters, loginStatus.value);
          });
        }
        else {
          _handleProfileRequest(requestParameters, loginStatus.value);
        }
      };

    };



// ----------------------------------------------------------------------
// Code within this block taken from ResponseHandler

    /**
    * Determines what services must be called to satisfy the given list of field names.
    *
    * @param  {array}  fieldNames  List of field names to retrieve, formatted using dot syntax.
    */
    function _getNeededServiceNames(fieldNames) {
      var result = [];
      fieldNames.forEach(function(fieldName) { // use the namespace as a key
        var parts = fieldName.split('.');
        var serviceKey = parts && parts.length > 0 ? parts[0] : '';
        if (serviceKey in _KNOWN_SERVICES) result.push(serviceKey);
      });
      return result;
    };


    /**
     * Determines authentication status for known users, and whether a login check is required.
     *
     * @return  {Object}  Object containing login status properties.
     */
    function _getLoginState() {

      var result = {
         value: null,
         requiresLoginCheck: false
       };

      _loggedInState = cdc.context.authStatus === 'valid' ? 'loggedIn': _loggedInState;

      if (_loggedInState !== 'unknown') {
        result.value = _loggedInState;
      }
      /** Handles unknown users as anonymous on login pages. */
      else if (cdc.context.isLoginPage()) {
        result.value = 'anonymous';
      }
      /** Handles unknown users as indicated by `cdc.context.authStatus` for non-login pages. */
      else {
        result.value = cdc.context.authStatus === 'valid' ? 'loggedIn' : 'anonymous';
        result.requiresLoginCheck = true;
      }
      return result;
    };

    /**
     * Merges newly retrieved service data into existing profile object.
     *
     * @param   {Object}  profileData  The user profile data.
     * @param   {String}  serviceName  The name of the service associated with the new data.
     * @param   {Object}  serviceData  The data object retrieved from the named service.
     * @return  {Object}               The profile object merged with the new data.
     */
    var _extendProfileData = function(profileData, serviceName, serviceData) {


      /**
       * Whether the provided parameters would cause data to be lost (in the case of non-responsive services and/or hitting the safety timeout for service requests).
       *
       * @param   {Object}   profileData  The user profile data.
       * @param   {String}   serviceName  The name of the service associated with the new data.
       * @param   {Object}   serviceData  The data object retrieved from the named service.
       * @return  {Boolean}               Whether the `serviceName` key references a non-empty object for `profileData` and an empty object for `serviceData`.
       */
      var causesDataLoss = function(profileData, serviceName, serviceData) {
        return (
          !!profileData &&
          !!profileData[serviceName] &&
          profileData[serviceName].constructor === Object &&
          !!serviceData &&
          !!serviceData[serviceName] &&
          Object.keys(serviceData[serviceName]).length === 0 &&
          serviceData[serviceName].constructor === Object
        )
      };

      serviceData = _validateServiceData(serviceName, serviceData);

      if (!causesDataLoss(profileData, serviceName, serviceData)) { // data can't be lost ...
        return _extend(profileData || {}, serviceData); // ... so we extend the profile with service data
      } else { // data can be lost ...
        return profileData // ... so we return the (guaranteed fresh) profile data
      }
    };


    /**
    * Calls a specified service, updates response object as required, then passes the data received to a callback function.
    *
    * @param  {String}   serviceName                             The name of the service.
    * @param  {Object}   state                                   Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
    * @param  {Boolean}  state.requiresWrappedResponse           Whether the response will be wrapped with metadata (required by `cdc.targeter` and calls to `request()` but not legacy calls to `getUserProfile()`).
    * @param  {Object}   state.response                          Response object having four keys: hasData, isComplete, profileData, requests.
    * @param  {Object}   state.response.profileData              The user data to return for the request.
    * @param  {Object}   state.response.hasData                  Whether data was available for the request.
    * @param  {Object}   state.response.isComplete               Whether all data was available for the request.
    * @param  {Object}   state.response.requests                 Object with data about requests that were received and whether/how they have been handled.
    * @param  {Array}    state.response.requests.queuedServices  The list of keys for services that must be called.
    * @param  {Boolean}  isLastCall                              Whether this is the last item to invoke in the list of queued services.
    */
    function _invokeService(serviceName, state, isLastCall) {
      _KNOWN_SERVICES[serviceName].callService(state, function(serviceData) {
        if (state.requiresWrappedResponse) {
          state.response.profileData = _extendProfileData(state.response.profileData, serviceName, serviceData);
          state.response.hasData = true;
          if (isLastCall) state.response.isComplete = true;
        };
        _serviceCallComplete(serviceName, serviceData, state);
      });
    };


    /**
     * Ensures that service data object is valid and properly keyed.
     *
     * @param   {String}  serviceName  The name or key of the service.
     * @param   {Object}  serviceData  The data object returned from the service, which may be invalid.
     * @return  {Object}               The valid data object.
     */
    function _validateServiceData(serviceName, serviceData) {
      if (serviceData == null || _isEmptyObject(serviceData)) { // We must initialize the service object.
        serviceData = {};
        serviceData[serviceName] = {};
      };
      return serviceData;
    };


    /**
     * Iterates through a loop until the queue clears before firing a response.
     *
     * @param  {String}  serviceName  The name of the service.
     * @param  {Object}  profile      The user data.
     * @param  {Object}  state        Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
     */
    var _respondWhenQueueClears = function(serviceName, profile, state) {
      var requestParameters = _pendingRequests[serviceName] || []; // list of parameter requestParameters that have been queued for a service name/key; reverse the array so that requestParameters added last are handled first

     if (state.response.requests.completed.length > 0) {
        state.response.requests.completed.forEach(function (completedRequest) {
          var completedServiceKey = _getRootKey(completedRequest);
          requestParameters.forEach(function(packet) { // { listOfDataFields, serviceNames: ["a", "b"] }
            var index = packet.serviceNames.indexOf(completedServiceKey); // TODO: handle multiples
            packet.serviceNames.splice(completedServiceKey, 1);
          });
        });
      };

      var _processThis = function(requestParameters) {
        var packet = requestParameters[requestParameters.length - 1]; // get the last packet
        var index = packet.serviceNames.indexOf(serviceName);
        if (index !== -1) { // the specificied service is included in this parameter packet (can appear multiple times in `requestParameters.serviceNames` queue)
            packet.serviceNames.splice(index, 1); // remove it (there may be others)
            if (packet.serviceNames.length === 0) { // no more service names remain so remove this parameter packet from
              requestParameters.pop(); // remove this, the last packet
              if (state.requiresWrappedResponse) {
                _respond(state, state.params.listOfDataFields.join(', '));
              } else {
                _respondWith(profile, state.params.listOfDataFields, packet.callback);
              };
              if (requestParameters.length > 0) _processThis(requestParameters);
            }
            else {
              _processThis(requestParameters);
            };
        };
      };
      if (requestParameters.length > 0) _processThis(requestParameters);
    };


    /**
    * Extends persisted profile data with newly-fetched data from a service (when possible).
    *
    * @param  {String}  serviceName  The name or key of the service.
    * @param  {Object}  serviceData  The data object retrieved from the named service.
    * @param  {Object}  state        Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
    * @param  {Object}  result       Data fetched via call to the named service.
    */
    function _serviceCallComplete(serviceName, serviceData, state) {
      var profile = _cache.getProfile(_loggedInState); // Creates an object of known profile data.
      profile = _extendProfileData(profile, serviceName, serviceData); // Extends profile with new data from the service.
      _cache.saveProfile(profile, _loggedInState); // Updates profile in the cache.
      _respondWhenQueueClears(serviceName, profile, state); // We know we have called the service so we wait for all pending service request queues to clear before responding.
    };


    /**
    * Creates or updates the queue of pending requests for known services if necessary, invokes services when they are first queued, and responds immediately if no queueing is required.
    *
    * @param  {Object}  state                                   Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
    * @param  {Object}  state.response                          Response object having four keys: hasData, isComplete, profileData, requests.
    * @param  {Object}  state.response.requests                 Object with data about requests that were received and whether/how they have been handled.
    * @param  {Array}   state.response.requests.queuedServices  The list of keys for services that must be called because we have no persisted data.
    * @param  {Object}  state.params                            The parameter packet for this invocation.
    * @param  {Object}  state.params.delayForData               Whether to delay response until service calls have responded with missing data.
    */
    var _queueRequests = function(state) {
      var queuedServices = state.response.requests.queuedServices;
      if (queuedServices.length === 0) { // There is no need to queue requests ...
        _respond(state, 'no queued services'); // ... so respond immediately.
      } else { // There is a need to queue requests.
        queuedServices.forEach(function(serviceName, index) {
          var isLastCall = (index === queuedServices.length - 1);
          if (_pendingRequests[serviceName] == null) { // The service has not yet been invoked from this page.
            _pendingRequests[serviceName] = [state.params]; // Creates a service-specific pending request queue, and add the full request parameter packet to it.
            if (typeof(state.params.delayForData) !== 'undefined') { // This filters out calls from the `.getUserProfile()` pipeline.
              if (!state.params.delayForData) { // For calls that use `.request()` pipeline with no delay ...
                _respond(state, serviceName); // ... we short-circuit here and respond immediately.
              };
            };
            _invokeService(serviceName, state, isLastCall); // Invokes the service.
          } else { // The service has already been invoked.
            _pendingRequests[serviceName].push(state.params); // Add the full request parameter packet the service-specific pending request queue, then wait for it to return.
          }
        });
      }
    };


    /**
    * Returns boolean indicating if provided object is null or empty (lacking custom properties)
    *
    * @param  {object}  o  Any object
    */
    function _isEmptyObject(o) {
      if (o == null) return true;
      for (k in o) {
        if (o.hasOwnProperty(k)) return false;
      }
      return true;
    };


    /**
    * Extracts a subset of requested data fields and passes them to a callback function.
    *
    * @param  {Object}    profile     Available profile data for user.
    * @param  {Array}     fieldNames  List of field selectors using dot-notation syntax.
    * @param  {Function}  callback    Function to handle the shaped response object.
    */
    function _respondWith(profile, fieldNames, callback) {
      var response = {};
      if (profile) {
        if (fieldNames instanceof Array && fieldNames.length > 0) {
          response = _extractObjectElements(profile, fieldNames);
        }
      }
      callback(response);
    }


    /**
    * Creates and returns a data object with properly nested keys and values.
    *
    * @param  {Object}  profileData  The source data.
    * @param  {Array}   keyStrings   Collection of fully qualified key names for the return object (using dot syntax).
    */
    function _extractObjectElements (profileData, keyStrings) {
      keyStrings = keyStrings || [];
      profileData = profileData || {};
      var result = {};
      keyStrings.forEach(function(keyString) {
        var keys = keyString.split(/\./);
        result[keys[0]] = profileData[keys[0]];
      });
      return result;
    };


// ----------------------------------------------------------------------


    /**
    * Consolidates parameters required to request profile and passes them to `RequestHandler`.
    *
    * @param  {Object}    parameterPacket                   The configuration object.
    * @param  {Array}     parameterPacket.listOfDataFields  Collection of fully qualified names for requested data (using dot syntax).
    * @param  {Function}  parameterPacket.callback          Callback function.
    */
    this.getUserProfile = function(parameterPacket) {
      parameterPacket = parameterPacket || {};
      if (typeof parameterPacket.callback !== 'function') { // Validate the parameter type
        if (console) console.log('cdc.userInfoDispatcher.getUserProfile: second parameter must be a function, but it is a ' + typeof(callback));
        return;
      }
      var requestParams = _extend(parameterPacket, { // Extend the provided parameter packet with additional, derived parameter
        serviceNames: _getNeededServiceNames(parameterPacket.listOfDataFields)
      });
      RequestHandler.process(requestParams);
    };


    /** Clears persisted user profile data. */
    this.clearCache = function() {
      _cache.clear();
    };


    /**
     * Updates response object by walking through cached profile data.
     *
     * @param   {Object}  profileData                        The user data.
     * @param   {Object}  state.params                       Configuration object having four keys: serviceNames, listOfDataFields, callback, delayForData.
     * @param   {Array}   state.params.listOfDataFields      The list of key strings used to select profile data.
     * @param   {Object}  state.response                     Response object having four keys: hasData, isComplete, profileData, requests.
     * @param   {Object}  state.response.profileData         The user data to return for the request.
     * @param   {Object}  state.response.hasData             Whether data was available for the request.
     * @param   {Object}  state.response.isComplete          Whether all data was available for the request.
     * @param   {Object}  state.response.requests            Object with data about requests that were received and whether/how they have been handled.
     * @param   {Object}  state.response.requests.completed  The list of keystrings for completed requests.
     * @param   {Object}  state.response.requests.queued     The list of keystrings for requests whose (root) service key will be added to the request queue.
     */
    function _updateResponseFromCache(profileData, state) { // Constructs response object with available profile data and a flag indicating whether response is complete.
      var result = state.response;
      state.params.listOfDataFields.forEach(function(keyString) { // Iterates through requested keystrings.
        var value = _getValueFromKeyString(profileData, keyString);
        if (typeof value !== 'undefined') { // The key exists **but** the associated data may be partial or complete
          result.hasData = true; // a resolved key means response will have data
          _setValueFromKeyString(result.profileData, keyString, value); // if key resolves, add whatever data is available for it to the response
          //result.requests.completed.push(keyString); // TODO: ideally here we would only push to completed when data data is complete
          result.requests.queued.push(keyString); // TODO: ideally here we would only push to queued when data is partial
        }
        else { // The key does not exist.
          result.isComplete = false; // an unresolved key means response is not complete
          result.requests.queued.push(keyString);
        }
      });
      return result;
    };


    /**
     * Gets the value of an object property using a keystring.
     *
     * @param   {Object}  sourceObject  The data source.
     * @param   {String}  keyString     The path to data formatted as a string of keys with dot notation.
     * @return  {*}                     The value found using the `keyString` selector.
     */
    var _getValueFromKeyString = function (sourceObject, keyString) {
      var currentNode = sourceObject;
      var result;
      var keyArray = keyString.split('.');
      var finalKey = keyArray[keyArray.length - 1];
      keyArray.forEach(function (key) {
        if (key === finalKey) {
          result = currentNode[key];
        } else {
          currentNode = currentNode[key];
        }
      })
      return result;
    };


    /**
     * Sets the value of an object property using a keystring.
     *
     * @param   {Object}  sourceObject  The data source.
     * @param   {String}  keyString     The path to data formatted as a string of keys with dot notation.
     * @param   {*}       newValue      The value to assign using the `keyString` selector.
     * @return  {*}                     The value added using the `keyString` selector.
     */
    function _setValueFromKeyString(sourceObject, keyString, newValue) {
        keyString = keyString.split('.');
        while (keyString.length > 1)
            sourceObject = sourceObject[keyString.shift()];
        return sourceObject[keyString.shift()] = newValue;
    };


    /**
     * Extracts the keystring for every nested property, formatted with dot notation.
     *
     * @param   {Object}  sourceObject  The object to parse.
     * @param   {String}  rootKey       The root key of the key string.
     * @return  {Array}                 The list of keystrings extracted from the object (using dot notation).
     */
    function _extractKeyStrings(sourceObject, rootKey) {
      var response = [];

      function flattenObject(sourceObject, rootKey) {
        rootKey = rootKey || '';
        var keyString = rootKey;
        Object.keys(sourceObject).forEach(function(key) {
          if(typeof sourceObject[key] !== 'object') {
            keyString = rootKey + '.' + key;
            keyString = (keyString[0] === '.') ? keyString.slice(1) : keyString;
            response.push(keyString);
          } else {
            flattenObject(sourceObject[key], rootKey + '.' + key);
          }
        });
      };

      flattenObject(sourceObject, rootKey);
      return response;
    };


    /**
     * Returns the root key of a keystring.
     *
     * @param   {String}  keyString  The key string formatted with dot notation (e.g., 'root.first.second').
     * @return  {String}             The root key.
     */
    function _getRootKey(keyString) {
        return keyString.split('.')[0];
    };


    /**
     * Updates the response object with services that should be queued to provide missing data.
     *
     * @param  {Object}  response                          Response object containing user profile data and whether this data is complete or partial.
     * @param  {Array}   response.requests.queued          The keystrings that were requested but not available in cache.
     * @param  {Array}   response.requests.queuedServices  The names of services with missing data that must be queued.
     * @return {Object}                                    The provided response with an additional key for `queuedServices`.
     */
    function _updateQueuedServices(response) {
      var result = response;
      result.requests.queued.forEach(function (keyString) {
        var serviceName = _getRootKey(keyString);
        if (result.requests.queuedServices.indexOf(serviceName) === -1) { // service not yet queued so add it
          result.requests.queuedServices.push(serviceName);
        }
      });
      return result;
    };


    /**
     * Executes or passes a callback based on whether the user requires a login check.
     *
     * @param  {Object}    state.loginStatus                     Information about user authentication.
     * @param  {String}    state.loginStatus.requiresLoginCheck  Whether the user authentication status requires that we make a login check.
     * @param  {Function}  callback                              The callback function to pass or execute.
     */
    var _handleLoginCheck = function (state, callback) {
      if (state.loginStatus.requiresLoginCheck) {
        cdc.context.checkLogin(function() {
          callback(state);
        });
      } else {
        callback(state);
      }
    };


    /**
    * Makes request for specific data to be retrieved from the cache and/or service calls, which may be returned with or without delay.
    *
    * @param  {Object}    state                          Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
    * @param  {Object}    state.params                   Configuration object having four keys: serviceNames, listOfDataFields, callback, delayForData.
    * @param  {Array}     state.params.listOfDataFields  The list of key strings used to select profile data.
    * @param  {Array}     state.params.serviceNames      The list of service names extracted from `params.listOfDataFields`.
    */
    this.request = function(params) {
      markPerformance('UID request for ' + params.listOfDataFields.join(', '));

      /** Initializes state. **/
      var state = {
        params: params,
        loginStatus: _getLoginState(),
        response: {
          hasData: false,
          isComplete: true, // defaults to true; later any missing data will set this to false
          profileData: {},
          requests: {
            queuedServices: [],
            received: params.listOfDataFields,
            completed: [],
            queued: []
          }
        },
        requiresWrappedResponse: true
      };

      state.params.serviceNames = _getNeededServiceNames(state.params.listOfDataFields);

      var callback = function() {
        _loggedInState = state.loginStatus.value;
        if (_cache.isStale(state.loginStatus.value)) { // Responds differently based on status of cache.
          _respondForStaleCache(state); // Queues all requests and immediately returns the response packet.
        } else {
          _respondForFreshCache(state); // Returns data that was persisted and queues requests for any missing data.
        };
      };

      _handleLoginCheck(state, callback);
    }


    /**
     * Executes the callback provided in params after adding needed service calls to the queue.
     *
     * @param  {String}    originString             The information to indicate the call's origin.
     * @param  {Object}    state                    Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
     * @param  {Object}    state.params             The configuration object having four keys: serviceNames, listOfDataFields, callback, delayForData.
     * @param  {Function}  state.params.callback    The callback function provided in the request parameters.
     * @param  {Object}    state.response           The profile data and related information about the complete-ness of the response.
     */
    var _respond = function(state, originString) {
      markPerformance('UID responded for ' + originString)
      state.params.callback(state.response);
    };


    /**
     * Retrieves available data from a fresh cache, updates the queue of services with missing data, then responds immediately or after missing service data has been retrieved.
     *
     * @param  {Object}  state                      Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
     * @param  {Object}  state.loginStatus          Information about user authentication.
     * @param  {String}  state.loginStatus.value    The user's authentication status.
     * @param  {Object}  state.response             Response object containing user profile data and whether this data is complete or partial.
     */
    function _respondForFreshCache(state) {
      var profileData = _cache.getProfile(state.loginStatus.value); // Retrieves persisted profile data.
      state.response = _updateResponseFromCache(profileData, state); // Updates the response object with cached data.
      state.response = _updateQueuedServices(state.response); // Updates the response object with services to call.
      _queueRequests(state); // `_respond` will be called downstream with `response.isComplete` set to `true` because `response.profileData` will have been updated with missing data from service calls
    };


    /**
     * Queues all service requests and responds with updated response object.
     *
     * @param  {Object}  state                           Object representing internal state with four keys: params, loginStatus, response, and requiresWrappedResponse.
     * @param  {Object}  state.params                    Configuration object having four keys: serviceNames, listOfDataFields, callback, delayForData.
     * @param  {Array}   state.params.serviceNames       The list of service names extracted from `params.listOfDataFields`.
     * @param  {Object}  state.response                  Response object containing user profile data and whether this data is complete or partial.
     * @param  {Object}  state.response.hasData          Whether data was available for the request.
     * @param  {Object}  state.response.isComplete       Whether all data was available for the request.
     * @param  {Object}  state.response.requests         Object with data about requests that were received and whether/how they have been handled.
     * @param  {Object}  state.response.requests.queued  The list of keystrings for requests whose (root) service key will be added to the request queue.
     */
    function _respondForStaleCache(state) {
      state.response.hasData = false;
      state.response.isComplete = false;
      state.response.requests.queued = state.params.serviceNames.slice(0);
      state.response = _updateQueuedServices(state.response);
      _queueRequests(state);
    }


// ----------------------------------------------------------------------


    /**
     * Manages persistance of profile data using local storage in the browser.
     */
    var _cache = new function() {


      /**
      * Key used to manage profile data in local storage.
      * @type {String}
      */
      var STORE_KEY = 'userInfoDispatcher';


      /**
      * Number of minutes after which the cache is considered stale.
      * @type {number}
      */
      var MINS_TO_STALENESS = 6 * 60;


      /**
       * Creates a timestamped object from parameters and persists it as a string.
       *
       * @param  {Object}  profile     Object representing known properties for the user.
       * @param  {String}  loginState  The authentication status of the user.
       */
      this.saveProfile = function(profile, loginState) {
          var cookieName = 'cdcUniqueKey';
          var uid_cookie = (document.cookie.match(/^(?:.*;)? cdcUniqueKey=([^;]+)(?:.*)?$/) || [, null])[1];
          if (uid_cookie == null || uid_cookie == 'none') {
              uid_cookie = Math.random().toString(20).slice(2);
              document.cookie = cookieName + '=' + uid_cookie + ';domain=.cisco.com;path=/';
          }

          try { // Save the info into the store
              var obj = JSON.stringify({
                  profile: profile,
                  authState: loginState,
                  created: new Date().getTime(),
                  token: uid_cookie
              });
              localStorage.setItem(STORE_KEY, obj);
          } catch (e) { // No session storage available (old browser, perhaps?)
          }
      };


      /**
       * Returns persisted profile information for user when available, and `null` otherwise.
       *
       * @param {string} currentLoginState The authentication status of the user.
       */
      this.getProfile = function(currentLoginState) {
          try {
              var info = JSON.parse(localStorage.getItem(STORE_KEY));
              return (info && !_isStale(info, currentLoginState)) ? info.profile : null;
          } catch (e) { // No session storage available (old browser, perhaps?)
              return null;
          }
      };


      /**
      * Returns boolean value indicating whether persisted profile information for user is missing or outdated.
      *
      * @param  {string}  currentAuthState  The authentication status of the user.
      */
      this.isStale = function(currentAuthState) {
        var result = true;
        try {
          var info = JSON.parse(localStorage.getItem(STORE_KEY));
          result = info == null || _isStale(info, currentAuthState);
        } catch (e) { // No session storage available (old browser, perhaps?)
        }
        return result;
      };


      /** Removes persisted data based on key. */
      this.clear = function() {
        try {
          localStorage.removeItem(STORE_KEY);
        } catch (e) { // No session storage available (old browser, perhaps?)
        }
      };


      /**
      * Returns boolean indicating whether the provided profile is absent, expired, or keyed to a different authentication status.
      *
      * @param  {object}  profileInfo       Object representing known properties for the user.
      * @param  {string}  currentAuthState  The authentication status of the user.
      */
      function _isStale(profileInfo, currentAuthState) {
        if (!profileInfo || profileInfo.authState != currentAuthState) {
          return true; // It's stale if there's no profile, or if the profile is for a different authentication state.
        }
        if (profileInfo.created < new Date().getTime() - MINS_TO_STALENESS * 60000) {
          return true; // It's stale if it's too old.
        }
        return false; // Otherwise, it's not stale.
      }
    };


// ----------------------------------------------------------------------


    /**
     *
     * Service Object
     * The service object is instatiated for every service defined. It handles calling the service, flattening the returned object, cleaning up the keys, and namespacing the attributes
       * It exposes one public method, callService();
     *
     */
    function Service(namespace, authUrl, anonUrl, attributesObjKey) {

      this.callService = function(state, callback) {
        var result = {};
        var url = (state.loginStatus.value === 'anonymous') ? anonUrl : authUrl;
        var remaining;
        var timeoutValue;
        var catchAll;
        var xhr = new XMLHttpRequest();

        if (!state.params.async) {
          xhr.open('GET', url, false);
        } else {
          remaining = state.requiresWrappedResponse ? (state.params.timeoutPoint - Date.now()) : TIMEOUT_MSEC;
          timeoutValue = (remaining > 0) ? remaining : 1;
          catchAll = setTimeout(moveOn, timeoutValue); // this is a catchall timeout since jquery < 1.5 cannot detect 500 server error codes on jsonp requests
          xhr.open('GET', url, true);
          xhr.timeout = timeoutValue;
       };
       xhr.withCredentials = true;

       xhr.onreadystatechange = function () {
         var DONE = 4; // readyState 4 means the request is done.
         var OK = 200; // status 200 is a successful return.
         if (xhr.readyState === DONE) {
           clearTimeout(catchAll);
           if (xhr.status === OK) {
             var responseObj = JSON.parse(xhr.responseText)
             _addNamespacePrefixes(responseObj, result);
             callback(result);
           } else {
             _addNamespacePrefixes(null, result);
             callback({});
           }
         };
       };

       try {
         xhr.send(null); // asynchronous requests from `getUserProfile()` return immediately; synchronous requests from `request()` return when response arrives
       }
       catch(ex) { // synchronous requests can fail and we need to send a callback with an empty object
         callback({});
       }

       function moveOn() { // Since we can't detect server errors with jsonp and we haven't heard back in time, we're over it, we're moving on.
         markPerformance('UID timed out for ' + namespace);
         xhr.abort();
         _addNamespacePrefixes(null, result);
         callback(result);
       };

      };

      function _addNamespacePrefixes(attributesObj, resultObj) {
        if (attributesObj == null) { //  nothing to do if we have returned a null object
          return true;
        }

        // split the attributesObjKey by / if present, allowing to navigate into the object to find the attributes object
        var parts = attributesObjKey.split ('/');
        for (var i = 0, n = parts.length; i < n && attributesObj != null; i++) {
          attributesObj = attributesObj[parts[i]];
        }
        if (attributesObj == null) return; // Nothing to add to resultsObj

        // ensure that our keyed object is not null
        // If the call returned no attributes, create an empty entry in the attributes object, and return it, so that the service is not called again
        // var atr = attributesObj; // [attributesObjKey];
        _flattenAttributes(namespace, attributesObj, resultObj);
        return true;
      }

      function _flattenAttributes(namespace, attributesObj, resultObj) {
        if (typeof attributesObj === 'object' && attributesObj.hasOwnProperty('name')) {
          _determineNameValuePair(namespace, attributesObj, resultObj);
        }
        else if(typeof attributesObj === 'object') {
          for(var k in attributesObj) {
            _determineNameValuePair(namespace, attributesObj[k], resultObj);
          }
        }
      }

      function _determineNameValuePair(namespace, nameAndValueObj, resultObj) {
        // verify that the object exists and set the appropiate depth
        resultObj = _makeAndReturnObject(resultObj, namespace);
        // if the the values are in the expected format
        if (nameAndValueObj.name !== undefined && nameAndValueObj.value !== undefined) {
          // if the value is a string name and store it
          if(typeof nameAndValueObj.value === 'string') {
            // _nameAndStoreAttribute(nameAndValueObj, resultObj);
            resultObj[_cleanKey (nameAndValueObj.name)] = nameAndValueObj.value;
          }
          else if(nameAndValueObj.value.constructor === Array) {
            // otherwise, if it is an array, check to see what of
            var array = nameAndValueObj.value;
            for(var x = 0, l = array.length; x < l; x++) {
              // if the array has something other than just strings, flatten it
              if(typeof array[x] != 'string') {
                _flattenAttributes(_cleanKey(nameAndValueObj.name), nameAndValueObj.value, resultObj);
              }
              else {
                // if the value is a string name and store it
                // _nameAndStoreAttribute(nameAndValueObj, resultObj);
                resultObj[_cleanKey (nameAndValueObj.name)] = nameAndValueObj.value;
              }
            }
          }
          else if (typeof nameAndValueObj.value === 'object') {
            // if the value is not a a string or an array flatten it
            _flattenAttributes(_cleanKey(nameAndValueObj.name), nameAndValueObj.value, resultObj);
          }
        }
        else {
          // if the value is not in the expected format, log it.
        }
      }

      // ensure that there is an object were expected in the result object
      function _makeAndReturnObject(object, string) {
        if(typeof object !== 'object') object = {};
        if(typeof object[string] !== 'object') object[string] = {};
        return object[string];
      }

      // clean up the attributed key to promote uniformity
      function _cleanKey(keyString) {
        return keyString.toLowerCase().replace(/\s/g, '_');
      }
    };


// ----------------------------------------------------------------------


    /**
     * Calls the requested service, then structures information from the response header into the userProfile object.
     *
     * @param  {string}  namespace         The namespace of the service.
     * @param  {string}  serviceUrl        The service URL used for anonymous users.
     * @param  {string}  attributesObjKey  The name of the header key that returns the desired value.
     */
    function ServiceResponseHeader(namespace, serviceUrl, attributesObjKey) {
      var catchAll;

      var _getAjaxObject = function() {

        var req;
        var xdr;

        // set up ajax object for modern browsers
        if (window.XMLHttpRequest) {
          req = new XMLHttpRequest();
          // setting xdr object for reference, but it doesn't appear to able to handle custom response headers
          if (req.withCredentials === undefined && window.XDomainRequest) {
            xdr = new XDomainRequest();
          }
        }

        // set up ajax object for old IE browsers
        else if (window.ActiveXObject) {
          try {
            req = new ActiveXObject('Msxml2.XMLHTTP');
          } catch (ex0) {
            try {
              req = new ActiveXObject('Msxml3.XMLHTTP');
            } catch (ex1) {
              try {
                req = new ActiveXObject('Microsoft.XMLHTTP');
              } catch (ex2) {
                throw new Error('XML HTTP request not implemented');
              }
            }
          }
        }

        // throw error for unsupported browsers
        else {
          throw new Error('XML HTTP request not implemented');
        }

        return req;
      };


      /**
       * Performs AJAX call to determine locale information.
       *
       * @param  {string}    loginState  The authentication status of the user.
       * @param  {function}  callback    Function to process the response header object which will be empty for exceptions or have properties with locale data
       * (`locale.country_code`, `locale.language_code`, and [optionally] `locale.lang_unknown`.)
       */
      this.callService = function(state, callback) {

        var loginState = state.loginStatus.value;

        var req = _getAjaxObject();

        // get response headers when ready
        req.onreadystatechange = function() {
          if (req.readyState) {
            if (req.readyState === 4) {
              clearTimeout(catchAll);
              if (req.status === 200) {
                var responseHeaderObject = parseResponseHeader(req, attributesObjKey);
                // Tack on the language code
                if (responseHeaderObject && responseHeaderObject.locale) {
                  var countryCode = responseHeaderObject.locale.country_code;
                  var langCode = COUNTRY2LANG[countryCode];
                  if (!langCode) {
                    responseHeaderObject.locale.lang_unknown = true;
                    langCode = 'en';
                  }
                  responseHeaderObject.locale.language_code = langCode;
                }
                callback(responseHeaderObject);
              }
            }
            else if (req.status > 0) {}
            else { // readyState=4 and status=0
              callback({}); // we send an empty object (note: empty objects will never be allowed to overwrite existing data in cache)
            }
          }
          else {}
        } // end onreadystatechange


        /**
        * Converts response header string into a JSON object.
        *
        * @param  {object}  req                The XMLHttpRequest object.
        * @param  {string}  responseHeaderKey  The name of the header key that returns the desired value.
        */
        function parseResponseHeader(req, responseHeaderKey) {
          // note: IE9 and below are unable to get response headers across domains.
          // Several ID projects are looking for a solution for this at this time.
          try {
            responseHeader = req.getResponseHeader(responseHeaderKey);
            responseHeader = responseHeader.split(',');
            var responseHeaderObject = {};
            responseHeaderObject[namespace] = {};
            for (i in responseHeader) {
              var currItem = responseHeader[i];
              var currPair = responseHeader[i].split('=');
              var currItem = currPair[0].toString();
              responseHeaderObject[namespace][currItem] = currPair[1];
            }
            return responseHeaderObject;
          }
          catch (e) {
            return null;
          }
        } // end parseResponseHeader()

        // call file
        try {
         if (!state.params.async) {
            req.open('GET', serviceUrl + '?t=' + Math.random(), false);
          }
          else {
            var remaining = state.requiresWrappedResponse ? (state.params.timeoutPoint - Date.now()) : TIMEOUT_MSEC;
            var timeoutValue = (remaining > 0) ? remaining : 1;
            catchAll = setTimeout(function() { // this is a catchall timeout since jquery < 1.5 cannot detect 500 server error codes on jsonp requests
              markPerformance('UID timed out for ' + namespace);
              req.abort();
              callback({});
            }, timeoutValue);
            req.open('GET', serviceUrl + '?t=' + Math.random());
            req.timeout = timeoutValue;
          };
          req.send(null);
        } catch (ex) {
            callback({});
        }

      }; // end callService()
    }; // end ServiceResponseHeader()


  }();

};

/*
 * cors.js
 * $Revision: 1.4 $

 * Cross-Origin Resource Sharing library
*/

cdc.util.ensureNamespace('cdc.util.cors');

cdc.util.cors.CORS = (function(){

/*

cors.js - cross-origin XHR

 - supports native CORS-aware XHR.
 - otherwise looks for IE8+ XDomainRequest.
 - otherwise uses native non-CORS XMLHttpRequest.
 - failing native XHR, looks for ActiveX.
 - fails utterly in absence of any XHR capability.
 - avoids IE's XDomainRequest in same-origin scenarios.
 - supports fragment fetch.
 - optionally caches the results of a fetch.
 - no library dependencies.
 - exposes CORS

################################################################################
USE CASE OUTLINE

var cors = new CORS();
cors.setHandlers({
	failBeforeSetup: function(err){...},
	setup: function(){...},
	failAfterSetup: function(err){...},
	success: function(data){...}
});
cors.open(method, url);
cors.send();

################################################################################
CONSTRUCTOR

var cors = new CORS();

 - throws error unless you use the "new" keyword.
 - throws error on browsers with zero XHR support.

################################################################################
CALLBACK API

cors.setHandlers(args);

 - args is object containing callback functions.
 - all functions are optional.
 - one or more of these will be executed upon calling the send() method.
 - there are guaranteed to be only three possible execution sequences for these functions:
    1. setup() => success()
    2. setup() => failAfterSetup()
    3. failBeforeSetup()

args.failBeforeSetup(errorMessage)

 - called if there is a failure before the http request is sent.
 - mainly this will happen for cross-origin requests on non-CORS browsers.
 - therefore use this as a graceful degradation path for non-CORS browsers in cross-origin scenarios.
 - note: same-origin scenarios should never invoke this function, even in non-CORS browsers.
 - an error message is passed to this function, but may not be meaningful.

args.setup()

 - called immediately after the send() method is invoked internally on the private request object.
 - use this to show a spinner and/or build a placeholder ui, for example.
 - no parameters are passed to this function.

args.failAfterSetup(errorMessage)

 - called if there is a failure after the request has been sent.
 - for example, a 404 response, or a cross-origin-denied error on CORS-aware browsers.
 - use this to revert actions performed in setup().
 - an error message is passed to this function, but may not be meaningful.

args.success(responseText)

 - called when the request successfully returns, exposing response data to your program.

################################################################################
OPEN METHOD

cors.open(method, url);

 - only 'GET' is currently supported for method, throws error otherwise.
 - however, for forward compatibility, method must be provided, throws error otherwise.
 - method is case insensitive.
 - if url has fragment id, string passed to success() contains only that element's HTML.
 - if url has fragment id, and no corresponding fragment is found in the response, failAfterSetup() is called.

################################################################################
SEND METHOD

cors.send();

 - caching is transparent to your program, however it may cause setup() and success() to be called in rapid succession.
 - no parameters.
 - does not throw any errors. rely on callback functions instead.

*/

var CORJAX = (function(){ // begin cors library

	// resolve urls using client's native resolver
	var resolveUrl = (function(){
		var link = document.createElement('a');
		return function(url) {
			link.href = url;
			return link.href;
		};
	})();

	// return <scheme>://<host>:<port>
	var getOrigin = (function(){
		var pattern = /^(.*\/\/[^\/]*).*$/;
		return function(url, die){
			die = !!die;
			var matches = url.match(pattern);
			if (!matches && die) { return ''; }
			return matches ? matches[1] : getOrigin(location.href, true);
		};
	})();

	// takes a string of HTML and an id, returns the
	// html for just that id. (supports frag fetch)
	var div = false;
	var getFrag = function(data, fragId) {
		div = div || document.createElement('div');
		div.innerHTML = data;
		var targetEl = false;
		if (div.querySelector) {
			targetEl = div.querySelector('#'+fragId);
		} else {
			targetEl = search(div, fragId);
		}
		if (targetEl) {
			var ohtml = targetEl.outerHTML;
			if (ohtml) { return ohtml; }
			div.innerHTML = '';
			div.appendChild(targetEl);
			return div.innerHTML;
		}
		return null;
	};

	// search for an id in a dom tree the old-fashioned way
	function search(el, id) {
		var q = [el];
		while (q.length) {
			el = q.shift();
			if (el.id && el.id === id) { return el; }
			for (var i=0; i<el.childNodes.length; i++) {
				var chel = el.childNodes[i];
				if (chel.nodeType === 1) { q.push(chel); }
			}

		}
		return null;
	}

	var cache = {};
	var dummy = function(){};

	// constructor
	var CORJAX = function() {
		// try to force this method to only be invoked with 'new' keyword
		if (!(this instanceof arguments.callee)) {
			throw new Error("constructor called as function (missing 'new' keyword)");
		}

		// build the request object
		var req, xdr = {};
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			if (req.withCredentials === undefined && window.XDomainRequest) {
				xdr = new XDomainRequest();
			}
		} else if (window.ActiveXObject) { // old IE
			try { req = new ActiveXObject("Msxml2.XMLHTTP"); }
			catch(ex0){
				try{ req = new ActiveXObject("Msxml3.XMLHTTP"); }
				catch(ex1){
					try{ req = new ActiveXObject("Microsoft.XMLHTTP"); }
					catch(ex2){
						throw new Error("XML HTTP request not implemented");
					}
				}
			}
		} else {
			throw new Error("XML HTTP request not implemented");
		}

		// first of three methods exposed to user
		var theUrl;
		var frag = false;
		var beginEx = false;
		this.open = function(method, url) {
			// only support GET for now
			method = method.toUpperCase();
			if (method !== 'GET') { throw new Error(method+" method not allowed"); }
			url = resolveUrl(url);
			if (xdr.open && getOrigin(url) !== getOrigin(location.href)){
				// only use ie xdr if we have to *grumble*
				req = xdr;
			}
			var iof = url.indexOf('#');
			if (iof > -1) {
				frag = url.substring(iof+1);
				url = url.substring(0,iof);
			}
			theUrl = url;
			try { req.open(method, url); }
			catch (ex) { beginEx = ex; }
		};

		// second of three methods exposed to user
		var doBegin, doDone, doError;
		var begin = dummy;
		var done = dummy;
		var failBefore = dummy;
		var failAfter = dummy;
		var useCache = false;
		this.setHandlers = function(args) {
			begin = args.setup || begin;
			done = args.success || done;
			failBefore = args.failBeforeSetup || failBefore;
			failAfter = args.failAfterSetup || failAfter;
			useCache = !!args.caching;

			var hasBegun = false;
			var isDone = false;
			var errorFlag = false;
			doBegin = function(){
				if (hasBegun || isDone || errorFlag) { return; }
				hasBegun = true;
				begin();
			};
			doDone = function(data){
				if (useCache) { cache[theUrl] = data; }
				if (frag) {
					data = getFrag(data, frag);
					if (data === null) {
						doError('fragment #'+frag+' not found');
					}
				}
				doBegin();//ensure this executes
				if (isDone || errorFlag) { return; }
				isDone = true;
				done(data);
			};
			doError = function(mess){
				if (errorFlag || isDone) { return; }
				errorFlag = true;
				hasBegun ? failAfter(mess) : failBefore(mess);
			};

			// double assignment because we don't yet know which obj to use
			req.onreadystatechange = xdr.onreadystatechange = function() {
				if (req.readyState === 4) {
					if (req.status === 200) { doDone(req.responseText); }
					else if (req.status > 0) { doError("error: "+req.status+": "+req.statusText); }
					else { doError("unspecified error"); }
				}
			};

			// try/catch prevents "unsupported" errors in ie6
			// double assignment (see above)
			try{req.onload   =xdr.onload   =function(){ doDone(req.responseText); }; }catch(ex){} // IE's XDomainRequest
			try{req.onerror  =xdr.onerror  =function(){ doError("unspecified error"); }; }catch(ex){}
			try{req.onabort  =xdr.onabort  =function(){ doError("the request was aborted"); }; }catch(ex){}
			try{req.ontimeout=xdr.ontimeout=function(){ doError("the request timed out"); }; }catch(ex){}
		};

		// third of three methods exposed to user
		this.send = function() {
			if (useCache && cache.hasOwnProperty(theUrl)) {
				doDone(cache[theUrl]);
				return;
			}
			if (beginEx) { doError(beginEx.message); }
			else {
				try { req.send(null); }
				catch (ex) { doError(ex.message); }
				doBegin();
			}
		};
	};

	return CORJAX;

})(); // end cors library

return CORJAX;

})();


/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.2.0 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/requirejs/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var ID_requirejs, ID_require, ID_define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.2.0',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*ID_require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, multi, multiText, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof ID_define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof ID_requirejs !== 'undefined') {
        if (isFunction(ID_requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = ID_requirejs;
        ID_requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof ID_require !== 'undefined' && !isFunction(ID_require)) {
        //assume it is a config object.
        cfg = ID_require;
        ID_require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.ID_require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'ID_require': function (mod) {
                if (mod.ID_require) {
                    return mod.ID_require;
                } else {
                    return (mod.ID_require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'ID_define' : 'ID_require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.ID_require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.ID_require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = ID_requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.ID_require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!ID_require) {
        ID_require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.ID_require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    ID_define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['ID_require'] : ['ID_require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    ID_define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

/*
 * includer.js: Require-based includer lib -- used in the framework clientlibs and bundles
 *
 * dependencies: jQuery, ID_require.js (an edited version of standard require.js)
 *
 * (c) 1992-2016 Cisco Systems, Inc. All rights reserved.
 *
 */

/* globals cdc: true, jQuery: false, ID_define: false, ID_require: false */

if (typeof cdc == "undefined") { cdc = {}; }

cdc.includer = (function () {
    var debugging  = false,
        qParamsStr = location.search.slice(1),
        qParamsObj = {},
        _assetServer = null,
        _requireHasBeenSetup = false,
        includer   = {
           isHostnameForced: false,
           domainConfig: {
              subdomains: [
                 'newsroom', 'tools', 'about',  'investor', 'apps',
                 'software', 'origin-software', 'sso', 'www-stage', 'cloudsso.*',
                 '.*\\.cloudapps', 'wwwin-fdk-(stage|devint)','search','searchx'
              ]
           },
           requireConfig: {
              waitSeconds: 0,
              baseUrl: "", // "//www.cisco.com",
              paths: {
                 "cl":  "etc/designs/cdc/fw/w/cl",
                 "lib": "etc/designs/cdc/fw/lib",
                 "m":   "etc/designs/cdc/fw/m"
              }
           }
        };

    /* ---------------------------------------------------------------------
     *             private methods (protected by the closure)
     * ---------------------------------------------------------------------
     */

    function dbgLog (msg,obj) {
       if (debugging) {
          if (typeof obj === 'object') {console.log(msg,obj); }
          else { console.log(msg); }
       }
    }

    /*
     * determinePrefix(): used by setupRequire() only
     *
     * set the require.config baseUrl value based on twisty logic
     *
     */

    // logic defined in Mingle #12997
    function determineBaseUrl (myhost) {
       var baseUrl = "",
           host    = myhost || window.location.hostname,
           currEnv = cdc.util.matchEnvironment(host),
           subDom  = includer.domainConfig.subdomains;

       dbgLog('begin determineBaseUrl()');
       dbgLog(' - host=[' + host + ']');
       dbgLog(' - env=[' + currEnv + ']');

       // safest is for any 'unknown' env to be considered prod; unless it is using sandbox port 4502
       if (currEnv === "unknown" && location.port != '4502') {
          currEnv = "prod";
          dbgLog(' - non-sandbox unknown, setting env=[' + currEnv + ']');
       }

       if (currEnv === "prod") {
          baseUrl = '//' + host;
          host    = host.replace('.cisco.com', '');

          // original loadJs() code to use the subdomain stuff
          // -- so a page loading from tools.cisco.com will load js from www.cisco.com, etc
          dbgLog(' - checking the subdomain list');
          for (var z=0; z < subDom.length; z++) {
             if (host.match('^' + subDom[z])) {
                baseUrl = '//www.static-cisco.com';
                dbgLog(' - host matches subdomain "' + subDom[z] + '"');
                break;
             }
             else {
                dbgLog(' - host does not match subdomain "' + subDom[z] + '"');
             }
          }
       }
       else if ((location.port != '4502' && location.port != '4503') || myhost) {
          dbgLog(' - port is not 4502 or 4503...');
          if (currEnv === "stage") {
             baseUrl = cdc.util.matchesTrueWemEnv() ? "//" + window.location.host : "//cloudsso-test.cisco.com"; // US160911 TODO: fix `^M` character
          }
          else if (currEnv === "dev") {
             baseUrl = "//fdk-devint.cisco.com";
          }
          else {
             dbgLog(' - but env is not dev or stage...');
             baseUrl = "//" + window.location.host;
          }
       }
       else {
          dbgLog(' - port is 4502 or 4503...');
          baseUrl = "//" + window.location.host;
       }
       dbgLog(' - baseUrl=[' + baseUrl + ']');
       dbgLog('end determineBaseUrl()');

       return baseUrl;
    }

    // Set up requirejs
    function setupRequire () {
        dbgLog('begin setupRequire()');
        includer.requireConfig.baseUrl = determineBaseUrl();
        dbgLog(' - baseUrl is now ' + includer.requireConfig.baseUrl);

        if (typeof ID_define === "function" && ID_define.amd) {
           ID_define("jquery", [], function() {
              return jQuery;
           });
           dbgLog(' - defined "jQuery" module to return existing framework jQuery object');
        }
        dbgLog(' - calling ID_require.config() with requireConfig object: ', includer.requireConfig);
        ID_require.config(includer.requireConfig);
        _requireHasBeenSetup = true;
        dbgLog('end setupRequire()');
    }

    // helper function for search(), called inside a 'for' loop, so moved out of loop to keep jshint happy
    // this returns a function which will be called by require.js when the asset is loaded
    function componentInit (componentId, assetPath, scope) {
       return function(componentModule) {
          dbgLog('in require callback for ' + componentId + ' at ' + assetPath);
          dbgLog(' - baseURL is = ' + ID_require.s.contexts._.config.baseUrl);
          if (componentModule) {
             if (typeof componentModule.init === "function"){
                componentModule.init(scope);
                dbgLog(' - inited ' + componentId);
             }
             else {
                dbgLog(' - Note: ' + componentId + ' in registry, but has no init()');
             }
          }
          else {
             dbgLog(' - Alert: ' + componentId + ' not found in registry');
          }

          /*
          if (cdc.debug && cdc.debug.callBeacon) {
             cdc.debug.codeBeacon ({
                message: componentId,
                signature: "cdc.cl.componentSurvey",
                warnUserInStage: false,
                beaconInStage: true
             });
          }
          */
       };
    }

    /* ---------------------------------------------------------------------
     *       publicly accessible methods ( i.e., cdc.includer.foo() )
     * ---------------------------------------------------------------------
     */

    // now only used by loadCss() -- possible candidate for private method?
    // NOTE: loadJs() used to call this but new version does not -- should it?
    includer.uniquifyIncludes = function(includes,type) {
      var dedup = {};
      var deduped = [];
      var nodeName, attrName;

      if (type == 'js') {
         nodeName = 'script';
         attrName = 'src';
      }
      else if (type == 'css') {
         nodeName = 'link';
         attrName = 'href';
      }

      for (var i=0;i<includes.length;i++){
        // for dev support - if root-rel url, add prefix
        // if (includes[i].match(/^\//)) {
        //  includes[i] = includer.asset_prefix + includes[i];
        // }
        dedup[includes[i]]=1;
      }

      if (typeof(includer.alreadyInPage) != 'undefined'){
         for (i=0;i<includer.alreadyInPage.length;i++){
            dedup[includer.alreadyInPage[i]]=0;
         }
      }

      jQuery(nodeName).each(function(){
         if (this[attrName]){
            var uncachedUrl = this[attrName].replace(/http:\/\/[^\/]*/,'');
            uncachedUrl = uncachedUrl.replace(/[\&\?]cacheReset=[0-9\-]*/,'');
            dedup[uncachedUrl]=0;
         }
      });

      for (i=0;i<includes.length;i++){
         if (dedup[includes[i]]){
            deduped.push(includes[i]);
         }
      }
      return deduped;
   };

    /*
     * Method: cdc.includer.loadCss()
     *
     * Description:
     * - - This function has two parameters. includes parameter stores the loaction of CSS assets. This function checks DOM for CSS if CSS is alredy loaded then it wont load the CSS otherwise it load the CSS file into head section of HTML page through DOM.
     *
     */

    // From original includer public API, not used internally
    includer.loadCss = function(includes,extraArgs){
       if (typeof includes == "string") {
          includes = [ includes ];
       }
       if (!extraArgs){
          extraArgs = {};
       }

       includes = includer.uniquifyIncludes(includes,'css');
       for (var i=0;i<includes.length;i++){
          //NEED TO check for css in dom
          //include css if not there already
          var css = document.createElement('link');
          css.setAttribute('rel', 'stylesheet');
          css.setAttribute('type', 'text/css');
          css.setAttribute('href', includes[i]);
          if (extraArgs.ids && extraArgs.ids[i]) {
             css.setAttribute('id', extraArgs.ids[i]);
          }
          document.getElementsByTagName('head')[0].appendChild(css);
       }

    };

    /*
     * Method: cdc.includer.loadJs()
     *
     * Description:
     * -  This function has two parameters.
     *    - includes parameter stores the location of JS assets.
     *    - extraArgs holds callback refs to be fired when asset is loaded
     *
     *    This function used to check DOM for JS if JS file is alredy loaded
     *    then it won't load the JS otherwise it load the JS file into head section of HTML page through DOM.
     *
     *    Now is uses AMD to load the asset instead.
     */

    // From original includer public API, not used internally
    includer.loadJs = function (includes, extraArgs) {
        dbgLog('in loadJs(), includes: [' + includes + '] ', includes);
        // Allow for the argument to be just one string (i.e., one asset name) instead of an array
        if (typeof includes == "string") {
            includes = [includes];
        }
        if (!_requireHasBeenSetup) {
            setupRequire();
        }

        // need to fiddle with the inputs so that require.js will prefix them with the baseUrl
        for (var i=0; i < includes.length; i++) {
           dbgLog(' - checking inputs for /etc/designs/cdc/fw or /web/fw...');
           if (includes[i].match(/^\/etc\/designs\/cdc\/fw/) || includes[i].match(/^\/web\/fw/)) {
              includes[i] = includes[i].replace(/^\//, ''); // remove initial forward slash
              if (includes[i].match(/\.js\?/)) {
                 dbgLog('   - ' + includes[i] + ': MATCH - but has qstring, keep absolute...');
                 includes[i] = includer.requireConfig.baseUrl + includes[i];
              }
              else {
                 dbgLog('   - ' + includes[i] + ': MATCH - changing value...');
                 includes[i] = includes[i].replace(/\.js$/, ''); // strip off trailing '.js' for AMD
              }
              dbgLog('   --> value is now ' + includes[i]);
           }
           else {
              dbgLog('   - ' + includes[i] + ': no match, not changing value.');
           }
        }

        // TODO: manipulate includes with domain names and subdomain stuff
        ID_require (includes, function () {
            if (extraArgs && extraArgs.callback && typeof extraArgs.callback == "function") {
                // Provide the callback with the modules that were loaded, if available. This behavior is different from the old includer, which did not provide any arguments to the callback.
                extraArgs.callback.apply (null, arguments);
            }
        });
    };

   /*
    * Method: cdc.includer.addSubDomain()
    *
    * Description:
    * -  addSubDomain() works with one param and this param could be string type or array type. It appends the subdomain in main array object of cdc.includer.domainConfig.subdomains.
    *
    *    Sample usages:
    *    > cdc.includer.addSubDomain('products');
    *    > cdc.includer.addSubDomain(['groups', 'services', 'products']);
    *
    *    Param:
    *    - This function using only one param called 'o'. This param contains the one array/string type of parameter to add the subdomains.
    *
    */

   // From original includer public API, not used internally
   includer.addSubDomain = function(o){
      //alert('deprecated');
      if (typeof o == "string") {
         o = [o];
      }

      if(o.length) {
         for(var i in o){
            if(includer.domainConfig.subdomains.join().indexOf(''+o[i]) < 0) {
               includer.domainConfig.subdomains.push(o[i]);
            }
         }
      }
   };

   /*
    * Method: cdc.includer.removeSubDomain()
    *
    * Description:
    * -  removeSubDomain() works with one param and this param could be string type or array type. It appends/removes the subdomain in main array object of cdc.includer.domainConfig.subdomains.
    *
    *    Sample usages:
    *    > cdc.includer.removeSubDomain('tools');
    *    > cdc.includer.removeSubDomain(['tools', 'products', 'services']);
    *
    *    Param:
    *    - This function using only one param called 'o'. This param contains the one array/string type of parameter for remove the subdomains.
    *
    */

   // From original includer public API, not used internally
   includer.removeSubDomain = function(o){
      //alert('deprecated');
      var arrString;
      if (typeof o == "string") {
         o = [o];
      }

      if(o.length) {
         for(var i in o){
            if(includer.domainConfig.subdomains.join().indexOf(''+o[i]) > 0) {
               arrString = includer.domainConfig.subdomains.join('~');
               arrString = arrString.split('~');
               includer.domainConfig.subdomains = [];
               for(var x in arrString){
                  if(arrString[x] != o[i]){
                     includer.domainConfig.subdomains.push(arrString[x]);
                  }
               }
            }
         }
      }
   };

    /*
     * Method: cdc.includer.cdcRandNum()
     *
     * Description:
     * - randum number generator
     *   - input: takes param limit to set random max, default is 1000
     *   - output: 'TimeInSeconds-RandNum'
     *
     *   Sample usages:
     *   > invoke with: cdc.includer.randNum(50); or cdc_rand_num();
     *
     */

    // From original includer public API, used by cacheBust() below
    includer.cdcRandNum = function(limit){
      if (!limit) {limit = 1000;}
      var sNum = Math.floor(Math.random()*limit)+1;
      var sTime = (new Date()).getTime();
      var rNum = sTime+"-"+sNum;
      return rNum;
    };

    /*
     * Method: cdc.includer.cacheBust()
     *
     * Description:
     * - cache buster : puts a cache avoidance param on a url with a random number
     *
     *   Sample usages:
     *   - cdc.includer.cacheBust('//www.cisco.com');          = YourUrl?cacheReset=rand#
     *   - cdc.includer.cacheBust('//www.cisco.com','foo');    = YourUrl?foo=rand#
     *   - cdc.includer.cacheBust('//ng-prod1/image');         = YourUrl&cacheReset=rand#
     *   - cdc.includer.cacheBust('//cisco.com/edit.pl?a=3');  = YourUrl&cacheReset=rand#
     *
     */

    // From original includer public API, not used internally
    includer.cacheBust = function(url,param){
      if (!param) {param = 'cacheReset';}
      var delim = "?";
      // if url is ng-prod1(bam) or has ?, set param delimeter to &
      if (url.match(/(ng-prod1|\?)/)) {delim = "&";}
      var fullParam = delim+param+'=';
      // degug alert(url+fullParam+cdc_rand_num());
      return url+fullParam+includer.cdcRandNum();
    };


    includer.setAssetServer = function (assetServerDomain) {
        // The parameter should not include the .cisco.com suffix, because that suffix will be tacked on in setupRequire below
        _assetServer = assetServerDomain;
    };

    // required by Mingle #12997
    includer.forceHostname = function (hostName) {
      includer.isHostnameForced = true ;
      ID_require.s.contexts._.config.baseUrl = "//" + hostName + "/web/fw/w/cl/";
    };

    // required by Mingle #12997
    includer.forceBaseRelative = function(){
      ID_require.s.contexts._.config.baseUrl = "/web/fw/w/cl/";
    };


    // required by Mingle #12997
    includer.addHostname = function (assetUrl) {

      var prefix = includer.requireConfig.baseUrl;

      if (assetUrl[0] == '/' && assetUrl[1] != '/') {
        //then it's relative
        return prefix + assetUrl.slice(1);
      } else if (assetUrl.slice(0,2) == '//') {
        //then it is abs && has hostname
        return assetUrl;
      } else if (assetUrl.slice(0,5) == 'http:' || assetUrl.slice(0,6) == 'https:') {
        return assetUrl.slice(assetUrl.indexOf(':') + 1);
      } else {
        return assetUrl;
      }
    };


    includer.search = function(scope){
        if (!scope) {
           scope = document.body;
        }

        dbgLog('begin search(): iterating over cdc.includer.manifest...', cdc.includer.manifest);

        var manifest = cdc.includer.manifest;
        for (var componentId in manifest){
           if (manifest.hasOwnProperty(componentId) ) { // keep jshint/jslint happy
              var aComponentSpec = manifest[componentId];
              if (scope.querySelector (aComponentSpec.signature)){
                 var assetPath = manifest[componentId].require;
                 // TODO: manipulate assetPath with domain names and subdomain stuff
                 dbgLog(' - ' + componentId + ': found on page, calling ID_require("' + assetPath + '"): look for callback to fire');
                 ID_require(assetPath, componentInit(componentId, assetPath, scope));
              }
              else {
                 dbgLog(' - ' + componentId + ': not on page, skipping');
             }
           } // end if to keep jshint/jslint happy
        } // end for
        dbgLog('exit for loop');
    };

    // Now for load-time execution code...
    //
    if (typeof includer.alreadyInPage == 'undefined') {
       includer.alreadyInPage = [];
    }

    if (qParamsStr !== "") {
       qParamsStr.split('&').forEach(function(pair){
          var kvPair = pair.split('=');
          qParamsObj[kvPair[0]] = kvPair[1];
       });
    }

    if (qParamsObj.includerDbg === "true") {
        debugging = true;
    }

    if (!_requireHasBeenSetup) {
       setupRequire();
    }

    // add dbgLog to public API for cl.js to use...
    includer.dbgLog = dbgLog;

    return includer;
}()); // execute anon function assigned to cdc.includer

//jQuery (function () {
jQuery(document).ready(function(){
    cdc.includer.search(document.body);
});

/*
 * ======================================================================================
 *
 * for some reason these cdc.util functions were in the cdc.includer definition...
 * NOTE: maybe they should be moved to a new module?
 *
 * ======================================================================================
 */

/*
  Method: cdc.util.JsLoader()

  Description:
  -  there are four private methods of JsLoader.
  - cdc.util.JsLoader.Load();
  - cdc.util.JsLoader.loadOne();
  - cdc.util.JsLoader.asuumeAlreadyLoaded();
  - cdc.util.JsLoader._initialize();
  - cdc.util.JsLoader._service();
*/

cdc.util.JsLoader = function () {
    var _loadedUrls = null; // Map: loaded url -> 1, initially null to enable initialization
    var _pendingQueue = []; // Array: {url: pendingUrlString, callbacks: [ array of callbacks] }

    var _doLoad = function (jsUrls, callback, forceLoad, dataType) {
        if (_loadedUrls === null) _initialize();
        var _forceLoad = !!forceLoad;
        var _dataType = dataType;
        var processUrlAtIndex = function (jsUrls, index) {
            var addedCount = 0;
            if (index >= jsUrls.length) { // No more assets to load for this request
                if (typeof callback === "function") callback();
                return;
            }
            var url = jsUrls[index];
            if (_loadedUrls[url] === undefined || _forceLoad) { // This asset is not yet loaded. Add it to the pending queue if needed.
                var ndx = index;
                var assetLoadedCallback = function () { processUrlAtIndex (jsUrls, ndx + 1);  };
                var pos = 0, m = _pendingQueue.length;
                for (; pos < m; pos++) {
                    if (_pendingQueue[pos].url === url) { break; }
                }
                if (pos >= m) { // This URL is not in the pending queue, so add it to the queue.
                    _pendingQueue.push ({"url": url, "callbacks": [ assetLoadedCallback ], okToUseCache: true, dataType: _dataType});
                    addedCount = 1;
                } else { // This URL is already on the pending queue
                    _pendingQueue[pos].callbacks.push (assetLoadedCallback);
                }
            } else { // Already loaded, so ignore it and move on.
                addedCount += processUrlAtIndex (jsUrls, index + 1);
            }
            return addedCount;
        };
        // Prime the pump
        jsUrls = (typeof (jsUrls) == "string") ? [ jsUrls ] : [].concat (jsUrls); // If it's an array, make a copy of it
        var queueWasEmpty = _pendingQueue.length <= 0;
        if (processUrlAtIndex (jsUrls, 0) > 0 && queueWasEmpty) {
            // The queue was initially empty, but I added stuff to it
            _service();
        }
        return this;
    };
    /*
    Method: cdc.util.JsLoader.load()

    Description:
    -   Load the given list of JavaScript assets, in the order specified. If the callback is provided, call it after all the assets have been loaded. This
    -   function takes care of multiple interleaved calls that might all specify common assets. If two callers specify assets in different orderings, the
    -   ordering of the first such caller wins.
    -   @param jsUrls an array of strings specifying JavaScript asset URLs
    -   @param callback (optional) a function to call when all the specified assets have been loaded.
    -   @param forceLoad (optional) boolean: true if the resource should be loaded even if it was already loaded earlier

    */
        this.load = function (jsUrls, callback, forceLoad) {
            if ((!jsUrls || jsUrls.length <= 0) && typeof (callback) == "function") {
                // No urls given, but callback specified, so the needed assets are (vacuously) loaded. So call the callback.
                callback();
                return;
            }
            _doLoad (jsUrls, callback, forceLoad, "script");
            return this;
        };

        // Load just one URL from a data service, with an optional parameter set. This method expects JSONP as the payload. This method caters to a common use case.
        this.loadOne = function (jsUrl, parameters, callback, forceLoad) {
            var url = jsUrl;
            if (parameters) {
                var separator = (jsUrl.indexOf ("?") > 0) ? "&" : "?";
                url += separator + jQuery.param (parameters);
            }
            return _doLoad ([ url ], callback, forceLoad, "json");
        };

        /*
         - Tell this loader to pretend that the given URLs are already loaded into the page, so they don't need to be reloaded.
         - @param jsUrls an array of asset URLs
         */
        this.assumeAlreadyLoaded = function (jsUrls) {
            jQuery.each (jsUrls, function (item) {
                _loadedUrls[item] = 1;
            });
        };

        // Private functions
        function _initialize () {
            // Remember the scripts loaded via explicit script tags
            _loadedUrls = {};
            jQuery("script").each (function (item) {
                var src = this.getAttribute ("src");
                if (src) _loadedUrls[src] = 1;
            });
        }

        function _service () {
            // Service one request, and invoke pseudo-recursively
            if (_pendingQueue.length >= 1) {
                var item = _pendingQueue[0];
                jQuery.ajax({
                    type: "GET",
                    url: item.url,
                    dataType: item.dataType || "script",
                    cache: item.okToUseCache,
                    success: function (data) {
                        _loadedUrls[item.url] = 1;
                        _pendingQueue.shift();
                        var i;
                        for (i = 0; i < item.callbacks.length; i++) {
                            item.callbacks[i]();
                        }
                        _service();
                    }
                });
            }
        }

        return this;
    };

/*define ("includer", ['require'], function () {
    return cdc.includer;
});*/

    /*
Method: cdc.includer.ServiceRequestQueue()

Description:
     - addRequest: Add a request for a data service.
     - @param url The URL of the service request
     - @param parameters the parameter set for the request: a map of strings to strings
     - @param callback the callback function to call when the request has been completed. This function will be called with the JSON data returned by the request.
     - @param okToUseCache (optional) a boolean value, set to true if the request may use an available cached version, i.e., a cache buster should be included; defaults to false
     - @param dataType  (optional) either "script" or "json" depending on the expected data type; defaults to "json"
     - This method is oriented towards a data service, hence its "okToUseCache" defaults to false.
*/

cdc.util.ServiceRequestQueue = function () {
    var _queue = [], _pending = false, _loadedUrls = {}/* For de-duplication of assets */;

    this.addRequest = function (url, parameters, callback, dataType, okToUseCache) {
        var dataTypeToUse = dataType  || "json";
        if (_loadedUrls[url] === undefined || !okToUseCache) {
            _queue.push ({"url": url, "parameters": parameters, "callback": callback, "okToUseCache": !!okToUseCache, "dataType": dataTypeToUse});
            _loadedUrls[url] = 1;
            _service();
        }
    };

    // Return the number of requests currently in this queue.
    this.getQueueSize = function () {
        return _queue.length;
    };

    // Private functions
    function _service () {
        // Service one request, and invoke pseudo-recursively
        if (_queue.length >= 1 && !_pending) {
            _pending = true;
            var item = _queue[0];
            jQuery.ajax({
                type: "GET",
                url: item.url,
                data: item.parameters,
                dataType: item.dataType,
                cache: item.okToUseCache,
                success: function (data) {
                    item.callback (data);
                    _pending = false;
                    _queue.splice (0, 1);
                    _service();
                }
            });
        }
    }
};

/*
 * cl.js
 *
 * extends cdc.includer with 'manifest' object to add support for Component Library
 * provides any common cdc.cl/cdc.components functions
 *
 * dependencies: jQuery, includer.js
 *
 * (c) 1992-2016 Cisco Systems, Inc. All rights reserved.
 * Terms and Conditions: //cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
 */

 /**
  *  Manifest:
  *   component:{
  *      signature: String identifying the CSS Selector to search for.  If signature is found the component code must be loaded.
  *      require: Array of Strings: Paths of JS files that the component needs. Paths are relative to web/fw/w
  *      cssDependecies: Array of Strings: Paths of CSS files that the component needs. Paths are relative to web/fw/w
  *      scope: Optional CSS Selector property to set the search scope of the DOM.
  *   }
 **/

/* globals cdc: true */

if (cdc.includer) {
    cdc.includer.dbgLog('start cl.js - inc config is go');

    cdc.includer.manifest = {
        a00v1: {
            signature:        '.a00v1',
            require:         ['cl/a00/a00v1'],
            cssDependencies: ['cl/a00/a00.css']
        },

        a00v3: {
            signature:        '.a00v3',
            require:         ['cl/a00/a00v3'],
            cssDependencies: ['cl/a00/a00.css']
        },

        a00v4: {
            signature:        '.a00v4',
            require:         ['cl/a00/a00v4'],
            cssDependencies: ['cl/a00/a00.css']
        },

        c16v3: {
            signature:        '#c16v3',
            require:         [
                              'cl/c16/c16v3',
                              'lib/jqmodal'
                             ],
            cssDependencies: ['cl/c16/c16.css']
        },

        c16v5: {
            signature:        '.c16v5',
            require:         ['cl/c16/c16v5'],
            cssDependencies: ['cl/c16/c16.css']
        },

        c17v1: {
            signature:        '.c17v1',
            require:         ['cl/c17/c17v1'],
            cssDependencies: ['c17/c17.css']
        },

/* this needs to lazy load via in-page script; if includer pulls this in it will break the component
        c17v2: {
            signature:        '.c17v2',
            require:         ['cl/c17/c17v2'],
            cssDependencies: ['c17/c17.css']
        },
*/

        c19v1: {
            signature:        '.c19v1',
            require:         [
                              'lib/jquery.hoverIntent.minified',
                              '//www.cisco.com/cdc_content_elements/visualsciences/visualsciences.js',
                              'cl/c19/c19v1'
                             ],
            cssDependencies: ['cl/c19/c19.css']
        },

        c22v2: {
            signature:        '#c22v2',
            require:         [
                              'lib/jquery.dimensions.min',
                              'lib/jquery.tools.min',
                              'lib/jquery_tache',
                              'cl/c22/c22v2'
                             ],
            cssDependencies: ['cl/c22/c22.css']
        },

        c25v8: {
            signature:        '.c25v8',
            require:         ['cl/c25/c25v8'],
            cssDependencies: ['cl/c25/c25.css']
        },

        c26v1: {
            signature:        '.c26v1',
            require:         [
                              'cl/c26/c26v1',
                              'lib/jqmodal',
                              'lib/jquery.bgiframe.min',
                              'lib/jquery.dimensions.min'
                             ],
            cssDependencies: ['cl/c26/c26.css']
        },

        c26v2: {
            signature:        '.c26v2',
            require:         [
                              'cl/c26/c26v2',
                              'lib/jqmodal',
                              'lib/jqDnR',
                              'lib/jquery.bgiframe.min',
                              'lib/jquery.dimensions.min'
                             ],
            cssDependencies: ['cl/c26/c26.css']
        },

        c26v3: {
            signature:        '.c26v3',
            require:         [
                              'lib/jqmodal',
                              'cl/c26/c26v3'
                             ],
            cssDependencies: ['cl/c26/c26.css']
        },

        c26v4: {
            signature:        '.c26v4',
            require:         ['cl/c26/c26v4',
                              'lib/jqmodal',
                              'lib/jqDnR',
                              'lib/jquery.bgiframe.min',
                              'lib/jquery.dimensions.min',
                             ],
            cssDependencies: ['cl/c26/c26.css']
        },

        c28v1: {
            signature:        '.c28v1', //c28v1.js referes to '.c28v3'
            require:         ['cl/c28/c28v1'],
            cssDependencies: ['cl/c28/c28.css']
        },

        c32v1: {
            signature:        '.c32v1',
            require:         ['cl/c32/c32v1'],
            cssDependencies: ['cl/c32/c32.css']
        },

        c36v1: {
            signature:        '.c36v1',
            require:         [
                              'cl/c36/c36v1',
                              'lib/jquery.tools-1.1.0.min',
                              'lib/jquery.urlEncode',
                              'lib/jquery.phpdate',
                              'lib/ntpagetag'
                             ],
            cssDependencies: ['cl/c36/c36.css']
        },

        c37v1: {
             signature:        '#c37v1',
             require:         ['cl/c37/c37v1'],
             cssDependencies: ['cl/c36/c36.css']
        },

        id01v1: {
             signature:        '#id01v1',
             require:         ['cl/id01/id01v1.min'],
             cssDependencies: ['cl/id01/id01.css']
        },

        id02v1: {
             signature:        '.id02v1',
             require:         ['cl/id02/id02v1'],
             cssDependencies: ['']
        },

        id04v1: {
             signature:        '#id04v1',
             require:         ['cl/id04/id04v1'],
             cssDependencies: ['cl/id02/id02.css']
        },

        id35v1: {
            signature:        '.id35v1',
            require:         [
                              'lib/jQuery.equalHeights',
                              'm/contacts_rules',
                              'cl/id35/id35v1'],
            cssDependencies: ['cl/id35/id35.css']
        },

        id37v2: {
            signature:       '.id37v2',
            require:        ['cl/id37/id37v2'],//MORE?
            cssDependecies: ['cl/id37/id37.css']
        },

        n04v4: {
            signature:        '.n04v4',
            require:         ['cl/n04/n04v4'],
            cssDependencies: ['cl/n04/n04.css']
        },

        n04v6: {
            signature:        '.n04v6',
            require:         [
                              '/etc/designs/cdc/fw/lib/jquery.hoverIntent.minified',
                              'cl/n04/n04v6'
                             ],
            cssDependencies: ['cl/n04/n04.css']
        },

        n05v17: {
             signature:        '.n05v17',
             require:         ['cl/n05/n05v17'],
             cssDependencies: ['cl/n05/n05.css']
        },

        nn11v1: {
             signature:        '.nn11v1',
             require:         ['cl/nn11/nn11v1'],
             cssDependencies: ['cl/nn11/nn11.css']
        },

        n13v8: {
             signature:        '.n13v8',
             require:         ['cl/n13/n13v8'],
             cssDependencies: ['cl/n13/n13.css']
        },

        n19v3: {
             signature:        '.n19v3',
             require:         ['cl/n19/n19v3'],
             cssDependencies: ['cl/n19/n19.css']
        },

        n21: {
             signature:        '#n21',
             require:         ['cl/n21/n21'],
             cssDependencies: ['cl/n21/n21.css']
        },


        n21v1: {
            signature:        '.n21v1',
            require:         ['cl/n21/n21v1'],
            cssDependencies: ['cl/n21/n21.css']
        },

        n22v1: {
            signature:        '.n22v1',
            require:         ['cl/n22/n22v1'],
            cssDependencies: ['cl/n22/n22.css']
        },

        p01v1: {
            signature:        '#p01v1',
            require:         ['cl/p01/p01v1'],
            cssDependencies: ['cl/p01/p01v1.css']
        },

        pt29: {
            signature:        '#pt29',
            require:         ['cl/pt29/pt29'],
            cssDependencies: ['cl/pt29/pt29.css']
        },

        s03v3: { //CSS does not refer to an s03v3 class or js
            signature:        '.s03v3',
            require:         ['cl/s03/s03'],
            cssDependencies: ['cl/s03/s03.css']
        },

        s03v4: {
            signature:        '.s03v4',
            require:         ['cl/s03/s03'],
            cssDependencies: ['cl/s03/s03.css']
        },

        s10v1: {
            signature:        '#s10v1',
            require:         ['cl/s10/s10v1'],
            cssDependencies: ['cl/s10/s10.css']
        },

        s10v3: {
            signature:        '#s10v3',
            require:         ['cl/s10/s10v3'],
            cssDependencies: ['cl/s10/s10.css']
        },

        // these used to be the built-in 'widgets; defined in includer.js
        'module-sbt': {
            signature: '.module-sbt',
            require: [
                '//cisco.com/cdc_content_elements/visualsciences/visualsciences.js',
                '/etc/designs/cdc/fw/j/sbt.js'
            ],
            cssDependencies: ['/etc/designs/cdc/fw/c/sbt.css']
        },
        'cdc-widget-accordion': {
            signature: '.cdc-widget-accordion',
            require: [
                '//www.cisco.com/cdc_content_elements/visualsciences/visualsciences.js',
                '/etc/designs/cdc/fw/lib/jquery.hoverIntent.minified.js',
                '/etc/designs/cdc/fw/w/accordion/widget-accordion.js'
            ]
        },
        'data-hero': {
            signature: '.data-hero',
            require: [
                '/etc/designs/cdc/fw/m/series-models-rules.js'
            ]
        },
        'support-mm-item': {
            signature: '.support-mm-item',
            require: [
                '/etc/designs/cdc/fw/lib/jQuery.equalHeights.js' // for global support menus only
            ]
        },
        'cdc-widget-lightbox': {
            signature: '.cdc-widget-lightbox',
            require: [
                '/etc/designs/cdc/fw/lib/jqmodal.js',
                '/etc/designs/cdc/fw/lib/jquery.bgiframe.min.js',
                '/etc/designs/cdc/fw/w/lightbox/lightbox.js'
            ],
            cssDependencies: [
                '/etc/designs/cdc/fw/w/lightbox/lightbox.css'
            ]
        }

   };
}

/*
// THE COMMENTED COMPONENTS:
/*
a03v5
a03v7
c00v20
n05v16
n19
s01
s02v12
s07v5
s14v1
s15v1
*/

//ADDCORNERS, NOT COMMENTED BUT LACKING JS:
/*

      'c25v1':{   // PCP
         callback:function(){
            cdc.util.addCorners('.c25v1');
         }
      },

      'c25v2':{   // PCR Hero (Image only)
         callback:function(){
            cdc.util.addCorners('.c25v2');
         }
      },

      'c25v7':{   // PCR Hero (Single Embedded Video)
         callback:function(){
            cdc.util.addCorners('.c25v7');
         }
      },

      'c28v6':{
         callback:function(){
            //jQuery(".c28v6 form").css({'display':'block'});
         }
      },

      'c40v1':{   // PCP Portlet allows PNG transparency
        js: [
           //'/etc/designs/cdc/fw/lib/jquery.pngFix.js'
        ],
           callback:function(){
           cdc.util.addCorners('.c40v1');
        }
     },

     'n05v15':{   // N05v15: PCR Quicklinks
        callback:function(){
           cdc.util.addCorners('.n05v15');
        }
     },

     'nn08v1': { // section tab sub product navigation
        callback:function(){
           //cdc.util.addCorners('.nn08v1');
        }
     },

     'n17v6':{
        callback:function(){
           cdc.util.addCorners('.n17v6');
        }
     },
*/

 /**
 *  Cookie related functions
 *  cookie.js
 *  $Revision: 1.4 $
 */

if (window.cdc === undefined) { window.cdc = {}; }

/**
cookie manipulation functions
NOTE: deprecated functions have been aliased to these functions in deprecated.js
TODO: update files that call this lib so we can remove support for legacy function signatures
*/
cdc.cookie = cdc.cookie || {
    /**
    sets a cookie. days and msecs are days and milliceconds from now,
    respectively. if neither days or msecs are given, defaults to
    expire at end of browser session.
    @param args {
        cookieName: string
        cookieValue: string
        days: int (optional)
        msecs: int (optional, overrides days)
        path: string (optional) (default=/)
        domain: string (optional)
    }
    */
    setCookie: function (args) {
        // LEGACY - support old signature (string, string[, int])
        if (!args.cookieName) {
            args = {cookieName: args, cookieValue: arguments[1]};
            if (arguments.length > 2) { args.days = arguments[2]; }
        }

        var expireStr = '';
        var pathStr = '';
        var domainStr = '';
        var msecs = parseInt(args.msecs);
        if (isNaN(msecs) && args.days) {
            msecs = args.days * 24 * 60 * 60 * 1000;
        }

        if (!isNaN(msecs)) {
            var ex = new Date();
            ex.setTime(ex.getTime() + msecs);
            expireStr = "; expires=" + ex.toUTCString();
        }
        if (args.path) {
            pathStr = "; path=" + args.path + ";";
        } else {
            pathStr = "; path=/;";
        }
        if (args.domain) { domainStr = "; domain=" + args.domain; }
        try {
            document.cookie = args.cookieName
             + "="
             + escape(args.cookieValue)
             + expireStr
             + pathStr
             + domainStr;
        } catch (e) {
            return false;
        }
        return true;
    },

    /**
    gets requested cookie.
    @param args { cookieName: string }
    */
    getCookie: function (args) {
        // LEGACY - if args is a string and not an object
        if (!args.cookieName) { args = { cookieName: args }; }

        var dict = cdc.cookie.unpackParamString(document.cookie, /\s*;\s*/);
        return dict[args.cookieName] || "";
    },

    /**
    deletes requested cookie.
    args are identical to setCookie, except that expiry is forced
    to a negative number, effectively deleting the cookie.
    */
    deleteCookie: function (args) {
        // mutating args obj might mess things up
        // if caller reuses it for other things
        var dArgs = {},
            name;
        for (name in args) {
            if (args.hasOwnProperty(name)) { dArgs[name] = args[name]; }
        }
        dArgs.msecs = dArgs.days = -1;
        dArgs.cookieValue = '';
        return cdc.cookie.setCookie(dArgs);
    },

    /**
    @param days number of days from now to count milliseconds for
    */
    daysFutureToTimeMS: function (days) {
        if (isNaN(parseInt(days))) { return 0; }
        var mydate = new Date();
        mydate.setTime(mydate.getTime() + ((days) * 24 * 60 * 60 * 1000));
        var ms = Date.parse(mydate);
        return ms;
    },

    // ###################################################################################
    // COOKIE CHIPS

    /**
    sets value of given cookie chip.
    to avoid naming collisions, cookie chips allow
    multiple name/value pairs within a single cookie.
    @param args {
        cookieName: string
        chipName: string
        chipValue: string
    }
    */
    addCookieChip: function (args) {
        // LEGACY - support old signature (string, string, string)
        if (!args.cookieName) { args = {cookieName: args, chipName: arguments[1], chipValue: arguments[2]}; }

        var str = cdc.cookie.getCookie(args),
            dict = cdc.cookie.unpackParamString(str);
        dict[args.chipName] = args.chipValue;
        cdc.cookie.setCookie({
            cookieName: args.cookieName,
            cookieValue: cdc.cookie.packParamString(dict),
            days: 366
        });
    },

    /**
    returns value of requested cookie chip
    @see cdc.cookie.addCookieChip
    @param args {
        cookieName: string
        chipName: string
    }
    */
    extractCookieChip: function (args) {
        // LEGACY - support old signature (string, string)
        if (!args.cookieName) { args = {cookieName: args, chipName: arguments[1]}; }

        var str = cdc.cookie.getCookie(args),
            dict = cdc.cookie.unpackParamString(str);
        return dict[args.chipName] || "";
    },

    /**
    deletes value of cookie chip
    @see cdc.cookie.addCookieChip
    @param args {
        cookieName: string
        chipName: string
    }
    */
    crumbleCookieChip: function (args) {
        // LEGACY - support old signature (string, string)
        if (!args.cookieName) { args = {cookieName: args, chipName: arguments[1]}; }

        var str = cdc.cookie.getCookie(args),
            dict = cdc.cookie.unpackParamString(str),
            removed = dict.hasOwnProperty(args.chipName),
            pStr;
        delete dict[args.chipName];
        pStr = cdc.cookie.packParamString(dict);

        // delete the cookie if it's empty
        if (!pStr) {
            cdc.cookie.deleteCookie(args);
        } else {
            cdc.cookie.setCookie({
                cookieName: args.cookieName,
                cookieValue: pStr,
                days: 366
            });
        }
        return removed;
    },

    /**
    takes a dictionary, returns a string
    e.g. {"foo":"bar","foo 2":"bar 2"} => "foo=bar&foo%202=bar%202"
    @param sep optional separator, defaults to "&"
    */
    packParamString: function (dict, sep) {
        sep = sep || '&';
        var frags = [],
            name;
        for (name in dict) {
            if (!dict.hasOwnProperty(name)) { continue; }
            frags.push(escape(name) + '=' + escape(dict[name]));
        }
        return frags.join(sep);
    },

    /**
    takes a string, returns a dictionary
    e.g. "foo=bar&foo%202=bar%202" => {"foo":"bar","foo 2":"bar 2"}
    @param sep optional separator, defaults to "&" (can be string or regexp)
    */
    unpackParamString: function (str, sep) {
        sep = sep || '&';
        var frags = str.split(sep),
            dict = {},
            frag,
            ioe,
            name,
            val,
            i;
        for (i = 0; i < frags.length && (frag = frags[i]); i++) {
            ioe = frag.indexOf('='); // expecting "foo=bar"
            if (ioe < 0) { continue; }
            name = unescape(frag.substring(0, ioe));
            val = unescape(frag.substring(ioe + 1));
            dict[name] = val;
        }
        return dict;
    }
};

/**
 *  New User cookie for Portal Enhancements
 *    -- determines whether new user content will be available to the user
 */
cdc.cookie.newUser = {
    newUserEndTime: 168, // sets expiration in hour increments
    cookieName: 'cdc.cookie.newUser', // sets name of cookie used
    updateUserVal: function () {
        // checks for existing cookie and adjusts value if necessary
        var uVal;
        var newUser = cdc.cookie.getCookie({cookieName: this.cookieName});
        if (!newUser) {
            // no cookie set; initialize new cookie
            uVal = this.setValidCookie();
        } else {
            var today = new Date();
            var now = today.getTime();
            if (newUser == 0) {
                // new user time already set to expired; no cookie mod necessary
                uVal = 0;
            } else if (newUser < now) {
                // new user time has expired since last visit; set cookie to 0
                uVal = this.endNewUser();
            } else {
                // cookie already set and still valid; no cookie mod necessary
                uVal = newUser;
            }
        }
        return uVal;
    },
    setValidCookie: function () {
        // creates new cookie with expiration beginning from now
        var today = new Date();
        var now = today.getTime(); // milliseconds
        var expireDate = now + (1000 * 60 * 60 * this.newUserEndTime); // set remaining hours based on expireTime set above
        var expireInMsecs = 1000 * 60 * 60 * 24 * 365 * 25; // expire actual cookie in 25 years
        cdc.cookie.setCookie({cookieName: this.cookieName, cookieValue: expireDate, msecs: expireInMsecs});
        return expireDate;
    },
    endNewUser: function () {
        // sets existing cookie value to 0, indicating user is no longer new
        var endVal = 0;
        var expireInMsecs = 1000 * 60 * 60 * 24 * 365 * 25; // expire actual cookie in 25 years
        cdc.cookie.setCookie({cookieName: this.cookieName, cookieValue: endVal, msecs: expireInMsecs});
        return endVal;
    }
};

// check for cdc.cookie.newUser and set if necessary
document.addEventListener('DOMContentLoaded', function() {
    cdc.cookie.newUser.updateUserVal();
});

// delete identified problem cookies
// remove this list after parseXML.js and reccomendation.js stop writing a list of links to it.
document.addEventListener('DOMContentLoaded', function() {
    cdc.cookie.setCookie({cookieName: "remainingLinks", cookieValue: "", path: "/", msecs: -1000});
});

/**
 * sso.js
 * $Revision: 1.15 $
 *
 *  sso.js
 *
 * keeps login sessions synched until idle timeout occurs
 * enforces idle timeout limit
 *
 *   (c) 1992-2010 Cisco Systems, Inc. All rights reserved.
 *   Terms and Conditions: //cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
 */

cdc.sso = cdc.sso || new function () {

    /* pick urls to use based on environment, should probably be moved to local storage? or some such other method that doesn't expose the non-prod hostnames */
    var environment="nosynch";
    environment = cdc.context.findEnvironment();
    if( environment!=='prod' && environment!=='stage' && environment!=='dev'){
        environment="nosynch"
    }
    var urlMap=  {
        "prod": {
            "oamValidate": window.location.protocol + "//sso.cisco.com/autho/apps/sso/validatessosession/cdc/cdcvalid.js",
            "portalSync":  window.location.protocol + "//www.cisco.com/cisco/psn/web/site/collab/sign.gif?",
            "logout":      "https://www.cisco.com/autho/logout.html?ReturnUrl=//www.cisco.com/web/fw/lo/logout.html",
            "ssoCookieName": "cdcSsoTimer"
        }
        , "stage": {
            "oamValidate": window.location.protocol + "//sso-nprd.cisco.com/autho/apps/sso/validatessosession/cdc/cdcvalid.js",
            "portalSync":  window.location.protocol + "//www-stage.cisco.com/cisco/psn/web/site/collab/sign.gif?",
            "logout":      "https://www-stage.cisco.com/autho/logout.html?ReturnUrl=//www-stage.cisco.com/web/fw/lo/logout.html",
            "ssoCookieName": "cdcSsoTimerStage"
        }
        , "dev": {
            "oamValidate": window.location.protocol + "//sso-nprd.cisco.com/autho/apps/sso/validatessosession/cdc/cdcvalid.js",
            "portalSync":  window.location.protocol + "//www-dev.cisco.com/cisco/psn/web/site/collab/sign.gif?",
            "logout":      "https://www-dev.cisco.com/autho/logout.html?ReturnUrl=//www-dev.cisco.com/web/fw/lo/logout.html",
            "ssoCookieName": "cdcSsoTimerDev"
        }
    };

    /* Timers the synch script uses to pace itself. */
    /* I'm making idleTimer and resynchInterval accessible to outside scripts so the time can be shortened for script testing */
    /* I'm not making synchCheckInterval accessible to prevent making it too small (it will establish a minimum for the others) */
    /* if the user tries to make the idleTimer longer than the backend's system timeout, they may find themselves logged out by that timeout, possibly in the middle of something. */
    this.idleTimer = 600*60*1000; // 4 hours for idle timeout -> Making this to 10hrs -->US134868
    this.resynchInterval = 29*60*1000; // how often we need to synch
    var synchCheckInterval = 50*1000; // how often to check whether it is time to synch

    /* A couple of parameters for the Ready notifier.
      This allows other functions to wait until session synching has happened, or at least the portal ping is complete.
      Originally created for vpLplink. Rest of implementation spread through out code. */
    var ssoReadyEventSent = false;
    this.authStatusIsSynced = ssoReadyEventSent;
    var readyListeners = [];

    /* Pick which set of environment variables you will use. */
    var storedValues = cdc.context.ls.getConfigInfo('SsoConfig');
    var now = new Date();
    if (storedValues && storedValues.expiry < now.getTime() ) {
        if (console) {
            console.log("Deleting expired ssoConfig.  Values were:"+JSON.stringify(storedValues)+
                        "You must resave them if you need them.");
        }
        cdc.context.ls.deleteConfigInfo('SsoConfig');
        storedValues = false;
    }

    if (storedValues) {
        if (console) {
            console.log('using your stored values, run SSO bookmark if you want to switch back to defaults');
            console.log(JSON.stringify(storedValues));
        }
        environment = "localstored";
        urlMap["localstored"] = storedValues.localstored;
        this.idleTimer = (storedValues.idleTimer && parseInt(storedValues.idleTimer) != 'NaN')?parseInt(storedValues.idleTimer):this.idleTimer;
        this.resynchInterval = (storedValues.resynchInterval && parseInt(storedValues.resynchInterval) != 'NaN')?parseInt(storedValues.resynchInterval):this.resynchInterval;
    }

    if ( environment != "nosynch") {
        var oamValidateUrl = urlMap[environment].oamValidate;

        var portalSynchUrl = urlMap[environment].portalSync;

        var logoutUrl = urlMap[environment].logout;
        var ssoCookieName = (environment == "localstored")?"cdcSsoTimerLocal":urlMap[environment].ssoCookieName;


        /* Ready notification code */
        var portalImage = new Image();
        function sendSsoReadyEventIfNeeded() {
            if (!ssoReadyEventSent) {
                for (var i = 0; i < readyListeners.length; i++) {
                    readyListeners[i]();
                }
                ssoReadyEventSent = true;
                cdc.sso.authStatusIsSynced = ssoReadyEventSent;
            }
        }

        portalImage.onload = function () {
            // Just logged in, send an SSO ready event
            sendSsoReadyEventIfNeeded();
        }
    }

    this.addReadyListener = function (callback) {
        if (typeof callback != "function") { // Client code gave us a bad parameter
            if (typeof console != "undefined" && console.trace) {
                console.log ("cdc.sso.addReadyListener: expecting a function, got a " + typeof callback);
                console.trace ();
            }
            return;
        }
        if (ssoReadyEventSent || cdc.context.authStatus != "unready") {
            callback();
        } else {
            readyListeners.push (callback);
            /* if user is logged in this queue is executed from makeSynchCalls so portal synch has happened
              if user is not logged in, it will never go to makeSynchCalls and doesn't need to wait so call now */
            cdc.context.checkLogin( function(val) {
                if (val != "valid") sendSsoReadyEventIfNeeded();
            })
        }
    }

    /* ################  THIS IS THE MAIN PLACE TO UPDTE fOR RIDS ############# */
    this.check = function() {
      if ( environment != "nosynch" ) {
          var idleTime = cdc.cookie.extractCookieChip(ssoCookieName,'idleTimer');
          var timeNow = new Date().getTime();
          var scriptElem = document.createElement("script");
          scriptElem.type = "text/javascript";
          if ( idleTime > timeNow ) {
            // we only check validity with ATS once per session, so we won't do it again
            cdc.context.setAuthStatus("valid");
            this.initialSynch();
          } else if ( cdc.cookie.getCookie("ObSSOCookie") && cdc.cookie.getCookie("ObSSOCookie").indexOf("loggedout" ) != 0 ) {
            // Can't use jQuery.getScript; because jQuery falsely optimizes this to ajax, which fails.
            scriptElem.src = cdc.context.cacheBust(oamValidateUrl);
            document.getElementsByTagName('head')[0].appendChild(scriptElem);
          }else {
        cdc.context.setAuthStatus("invalid");
    }
      }
    };

    // this is returned by the call to the oamValidateUrl
    this.oamStatus = function (valObj) {
        var val = valObj.userLogin;
        cdc.context.setAuthStatus(val);
        if (val == "valid") {
            cdc.sso.initialSynch();
        } else {
            cdc.sso.nonSynchable(val);
        }
    }


    this.initialSynch = function() {
       if ( environment != "nosynch" ) {
          var timeNow = new Date().getTime();
          // we always want to reset the idle time out for another 4 hours on page load.
          addSessionCookieChip({cookieName:ssoCookieName,chipName:'idleTimer',chipValue:timeNow+cdc.sso.idleTimer})
          makeSynchCalls();
          setTimeout("cdc.sso.keepSynched()",synchCheckInterval);
       }
    };

    this.keepSynched = function() {
          var timeNow = new Date().getTime();
          if ( cdc.cookie.getCookie(ssoCookieName)) {
            if (cdc.cookie.extractCookieChip(ssoCookieName,'idleTimer') < timeNow ) {
              timedOut();
            } else {
              makeSynchCalls();
              setTimeout("cdc.sso.keepSynched()",synchCheckInterval);
            }
          }
    };

    function makeSynchCalls() {
          var timeNow = new Date().getTime();
          var synchTimer = cdc.cookie.extractCookieChip(ssoCookieName,'resynchInterval');
          if ( !synchTimer || synchTimer <= timeNow ) {
            portalImage.src=portalSynchUrl+timeNow;
            // update resynch timer
            addSessionCookieChip({cookieName:ssoCookieName,chipName:'resynchInterval',chipValue:timeNow+cdc.sso.resynchInterval});
          } else { // Already logged in, so send an SSO ready event
              sendSsoReadyEventIfNeeded();
          }
    };

    function logout () {
        // first see if we've logged out already
      if (cdc.cookie.getCookie(ssoCookieName) || cdc.context.authStatus != "invalid" ) {
        jQuery('body').append("<iframe src='"+logoutUrl+"' style='height:0;width:0;' ></iframe>");
      }
    };

    function timedOut() {
          logout();
    };

    this.nonSynchable = function(val) {
        // if anonymous session don't run logout
        if (val == 'invalid') {
            logout();
        }
    };

    function addSessionCookieChip (args) {
          // needed because addCookieChip will make cookie last a year instead of session
          // also domain needs to be .cisco.com
            var str = cdc.cookie.getCookie(args),
            dict = cdc.cookie.unpackParamString(str);
            dict[args.chipName] = args.chipValue;
            cdc.cookie.setCookie({
                  cookieName: args.cookieName,
                  cookieValue: cdc.cookie.packParamString(dict),
                  domain:'cisco.com'
            });
    }
};

cdc.sso.staySynched = cdc.sso.initialSynch; // alias for backwards compat with ATS script, may remove dep on if it can start sending initialSynch instead

cdc.sso.check();

/**
* rsvputil.js
*
* Dependencies:
* No dependencies
*
* Usage:
* window.cdc.rsvputil.addEventListener([elem], [eventName], [callback])
* etc...
*
* Known Issues:
* Basic browser support includes IE 9+, FireFox (current), Chrome (current)
* and Safari (current)
*
* Listener callback
* @callback listenerCallback
* @param {Object} event IDOMEvent raised by listener
*
* EachObj callback
* @callback eachObjCallback
* @param {Object} object - item at the current index
* @param {number} index - index at which the object appears
* @param {Object[]} objects - all items in the array
*/
(function (root, factory) {
    'use strict';
    if (root.cdc === undefined) { root.cdc = {}; }

    root.cdc.rsvputil = factory();
}(this, function () {
    'use strict';
    var namespace = 'rsvputil';
    /**
     * add an event listener to an element
     *
     * @param {Object} elem HTML element
     * @param {String} eventName name of the event to attach
     * @param {listenerCallback} callback listener to attach
     */
    function addEventListener(elem, eventName, callback) {
        // W3C recommendation
        if (elem.addEventListener) {
            elem.addEventListener(eventName, function () {
                cdc.debug.log(namespace, eventName);
                callback();
            });
        } else if (elem.attachEvent) {
            // Lt IE 9 support
            elem.attachEvent('on' + eventName, callback);
        }
    }

    /**
     * throttles a function
     *
     * @param {callback} callback callback to throttle
     * @param {number} [delay=10] name of the event to attach
     */
    function throttle(callback, delay) {
        var timeout;
        delay = delay || 10;
        return function () { timeout = timeout ? window.clearTimeout(timeout) : window.setTimeout(callback, delay); };
    }

    /**
     * basic object iterator (IE 9 support for Array.prototype.forEach)
     *
     * @param {Object[]} objects - list of objects to iterate
     * @param {callback} callback -
     */
    function eachObj(objects, callback) {
        var i;
        for (i = 0; i < objects.length; i++) {
            callback(objects[i], i, objects);
        }
    }

    /**
     * Creates a new object literal by coallescing values from arguments
     *
     * @param {Object} defaults default values in new object literal
     * @param {Object} options values to copy into the new object literal
     * @returns {Object} an object literal with values collected from defaults and options
     */
    function extend(defaults, options) {
        var extended = {}, prop;
        for (prop in defaults) {
            if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
                extended[prop] = defaults[prop];
            }
        }
        for (prop in options) {
            if (Object.prototype.hasOwnProperty.call(options, prop)) {
                extended[prop] = options[prop];
            }
        }
        return extended;
    }

    return {
        addEventListener: addEventListener,
        eachObj: eachObj,
        extend: extend,
        throttle: throttle
    };
}));

/**
*   mediaQueries
*   Data module - separates data input from mediaQueryObserver
*/
(function (root, factory) {
    if (root.cdc === undefined) { root.cdc = {}; }
    root.cdc.mediaQueries = factory();
}(this, function () {
    return [
        { mediaQuery: 'only all', name: 'base', breakpoint: 0 },
        { mediaQuery: 'only all', name: 'short', breakpoint: 0 },
        { mediaQuery: 'only screen and (min-width:30em)', name: 'xsmall', breakpoint: 480 },
        { mediaQuery: 'only screen and (min-width:37.5em)', name: 'small', breakpoint: 600 },
        { mediaQuery: 'only screen and (min-width:37.5em)', name: 'tall', breakpoint: 600 },
        { mediaQuery: 'only screen and (min-width:48em)', name: 'medium', breakpoint: 768 },
        { mediaQuery: 'only screen and (min-width:60em)', name: 'large', breakpoint: 960 },
        { mediaQuery: 'only screen and (min-width:64em)', name: 'xlarge', breakpoint: 1024 },
        { mediaQuery: 'only screen and (min-width:64em)', name: 'grande', breakpoint: 1024 },
        { mediaQuery: 'only screen and (min-width:80em)', name: 'venti', breakpoint: 1280 }
    ];
}));

/**
*   mediaQueryObserver
*
*   version: 1.0
*   history:
*   16 Feb 2014: created
*/

(function (root, factory) {
    if (root.cdc === undefined) { root.cdc = {}; }

    var mediaQueries = root.cdc.mediaQueries,
        util = root.cdc.rsvputil,
        debug = root.cdc.debug;

    root.cdc.mqo = factory(mediaQueries, util, debug);
}(this, function (mediaQueries, util, debug) {
    var namespace = 'mqo',
        callbacks = [];

    var getCurrentMax = function () {
        var maxMatch;
        util.eachObj(mediaQueries, function (item) {
            var isMediaMatch = window.matchMedia(item.mediaQuery).matches;
            maxMatch = isMediaMatch ? item.name : maxMatch;
        });
        return maxMatch;
    };

    var onStatusChange = function (oldQuery, newQuery) {
        debug.log(namespace, 'onstatuschange function entered');
        util.eachObj(callbacks, function (callback) {
            callback(oldQuery, newQuery);
        });
    };

    var update = function () {
        debug.log(namespace, 'update function entered');
        util.eachObj(mediaQueries, function (item) {
            var isMediaMatch = window.matchMedia(item.mediaQuery).matches,
                oldItem = util.extend({}, item);

            if (item.isMediaMatch === undefined || item.isMediaMatch !== isMediaMatch) {
                item.isMediaMatch = isMediaMatch;
                onStatusChange(oldItem, item);
            }
        });
    };

    if (!jQuery('html').hasClass('lt-ie9')) {
        util.addEventListener(window, 'resize', update);
        util.addEventListener(window, 'load', update);
    }

    return function (size) {
        var mediaQueryItem;

        util.eachObj(mediaQueries, function (item) {
            mediaQueryItem = item.name === size ? item : mediaQueryItem;
        });

        return {
            onEnter: function (callback) {
                if (typeof callback !== 'function') { throw 'Media Query Observer requires a callback of type function'; }
                debug.log(namespace, 'onEnter started');
                var wrapper = function (oldQuery, newQuery) {
                    debug.log(namespace, 'onEnter wrapper entered');
                    if (newQuery.name !== size) { return; }
                    if ((oldQuery.isMediaMatch === undefined || oldQuery.isMediaMatch === false) && newQuery.isMediaMatch === true) {
                        debug.log(namespace, callback);
                        callback(oldQuery, newQuery);
                    }
                };
                callbacks.push(wrapper);
            },
            onExit: function (callback) {
                if (typeof callback !== 'function') { throw 'Media Query Observer requires a callback of type function'; }
                debug.log(namespace, 'onExit started');
                var wrapper = function (oldQuery, newQuery) {
                    debug.log(namespace, 'onExit wrapper entered');
                    if (newQuery.name !== size) { return; }
                    if ((oldQuery.isMediaMatch === undefined || oldQuery.isMediaMatch === true) && newQuery.isMediaMatch === false) {
                        debug.log(namespace, callback);
                        callback(oldQuery, newQuery);
                    }
                };
                callbacks.push(wrapper);
            },
            getScreenSize: function () {
                return getCurrentMax();
            }
        };
    };
}));
/**
 *  _breakpointhandler.js
 *  $Revision: 1.5 $
 */
(function () {
    if (window.cdc === undefined) { cdc = {}; }
    if (typeof cdc.mqo !== 'function') { throw 'Media Query dependency not met'; }

    cdc.breakpoint = (function () {
        var isLtIE9 = jQuery('html').hasClass('lt-ie9'),
            mqo = cdc.mqo,
            breakpoints = {
                base: 0,
                'short':0,
                xsmall: 480,
                small: 600,
                tall: 600,
                medium: 768,
                large: 960,
                xlarge: 1024,
                grande: 1024,
                venti: 1280
            };
        function getSizeFromNumber(num) {
            var size = 'base', key;
            for (key in breakpoints) {
                if (breakpoints.hasOwnProperty(key)) {
                    if (num >= breakpoints[key]) { size = key; }
                }
            }
            return size;
        }

        return {
            breakpoints: breakpoints,
            onEnter: function (callback, minWidth) {
                if (isLtIE9) {
                    callback();
                } else {
                    mqo(getSizeFromNumber(minWidth)).onEnter(callback);
                }
            },
            onExit: function (callback, minWidth) {
                if (!isLtIE9) { mqo(getSizeFromNumber(minWidth)).onExit(callback); }
            },
            getScreenSize: function () {
                var screenSize;
                screenSize = isLtIE9 ? 'large' : mqo().getScreenSize();
                return screenSize;
            },
            isGridRowStacking: function (checkme) {
                // put it here, return true/false
                var myBp = mqo().getScreenSize(), imStacked = true, rowtype, $row,
                    unstackedAt = {
                    // all rows are stacked below tall/small bp; all rows are unstacked from medium on
                    // this structure allows
                        tall:["halves","twothirds-third","third-twothirds","wide-narrow","narrow-wide"]
//                      medium:["halves","twothirds-third","third-twothirds","wide-narrow","narrow-wide","thirds","quarters","wide-narrow-v2","narrow-wide-v2","quarter-half-quarter","halvesinhalf"]
                    };
                if (myBp === "tall") {
                    if (typeof checkme === "string") {
                        // if you want to know about a halves row inside a halves row or a halves row inside
                        // quarter-half-quarter or a halves row with .col.half.medium then value to send is
                        // halvesinhalf
                        if (unstackedAt["tall"].indexOf(checkme) >= 0 ) {
                            imStacked = false;
                        }
                    } else if (typeof checkme === "object") {
                        $row = checkme.closest('.row');
                        if ($row.hasClass('halves') ) {
                            imStacked = ($row.hasClass('medium') || $row.parent().closest('.row').hasClass('halves') || $row.closest('.row').hasClass('quarter-half-quarter') )?true:false;
                        } else {
                            for (i=0; i < unstackedAt['tall'].length && imStacked; i++) {
                                if ( $row.hasClass(unstackedAt['tall'][i])) {
                                    imStacked = false;
                                }
                            }
                        }
                    }
                } else if (myBp === "medium" || myBp === "large" || myBp === "grande" || myBp === "venti") {
                    imStacked = false;
                }
                return imStacked;
            }
        };
    }());
}());

/**
 *  code to show the correct warning and link for outdated IEs
 *  _ie-warning.js
 */

if(window.cdc == undefined) { cdc = {}; }

cdc.ie = ( function(){
    var upgradeLink = "http://windows.microsoft.com/en-us/internet-explorer/download-ie";
    var upgradeText = "Please upgrade your version of IE.";
    var compatLink = "http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-10";
    var compatText = "You are accessing Cisco.com in Compatibility View."

    return {
        init: function(){
            var anchorTag = document.createElement('a');
            var spanTag = document.createElement('span');
            var imgTag = document.createElement('img');

            anchorTag.setAttribute('id', 'ie-message');

            if (Modernizr.compatibilitymode) {
                anchorTag.className = 'ie-compatmode';
                anchorTag.setAttribute('href', compatLink );
                imgTag.setAttribute('alt', compatText);
                imgTag.setAttribute('src', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/4RCERXhpZgAATU0AKgAAAAgAAwExAAIAAAAeAAAIPodpAAQAAAABAAAIXOocAAcAAAgMAAAAMgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoAAAB6hwABwAACAwAAAhuAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4QmoaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaDwveG1wOkNyZWF0b3JUb29sPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIACoDugMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP1Fooor5Y6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAorP1zWLbw/pF5qN4222tY2lcr1IA6AdyTwB3NeDeEPHF7pPjGLXtSEkVrrk0kdy8hBjKo4TKnOQIXZUJIHylyM9a8TH5rSwFWlSmr82/91XtzPy5ml/Vj0cLgp4qE5xfw7eb3svkfRNFFFe2ecFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRXy5qfxO13Ur2W4/tW6t1diVit52RVHYAAjpVX/hPtc/6Dmo/wDgXJ/jXorBS6sjmPq2ivlFviBraLk69qCgdzdv/jS/8J/rn/Qc1D/wLk/xp/UpfzBzH1bRXyl/wn2uf9BzUf8AwLk/xo/4T7XP+g5qP/gXJ/jR9Sl/MHMfVtFfKX/Cfa5/0HNR/wDAuT/Gj/hPtc/6Dmo/+Bcn+NH1KX8wcx9W0V8pf8J9rn/Qc1H/AMC5P8ataZ8TNd069iuDqt1cBCC0VxOzqw7ggkjml9Sl0Ycx9R0UUV5xYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFKWwBRRRTAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqhrWpDR9Hvr8wvOLWCScxRcvIFUnavucYpSkopyfQau3ZHlvxl8R/btStvD0D5httt1e4PBbrFGcHt98g/8ATOuAnmtbzRfDlkJY5Z4P7WF1bhgWjEl0hTeByu5QSM9RyKxx420+4mmury+33t1K087CKTG8nJAyDhR90DsAKih8WaOhTMrCVTKZbjzZn88M2UHlldsexfl+U/N1NfhuMxmIxtbE1pRspxsk09EpRaSsnrpd3stX1sj9Kw+Hp4enSpp/C7vVb2afXz/I+gvhH4mfWvDhsbqQvqGlkW8jP950xmOQ/VRgn+8hru6+Z/h745t7Tx1pR06R7prx1sp4VhcZjdhh8kADY3PPbfX0xX6dw9jKmLwMVWTU4e679bbP7t/O58ZmuHjh8S3D4Za/5/iFeY/GLxBq/wAO2sfG2n/adT02zU2Oo6HHMqrOszKsMqBiFWRZSik5GUkfP3Vr06svxH4c07xZpMul6pb/AGqxleN3i3smSjq6ncpB4ZVPWvp4uz1PHPPNP1rxX4budH8IQyWuu+LryyuNa1K/1K4kS2hHmoDFEqqzbd8uxFGAqx5OTwcKH9paS88H+N9di0FY28N6Bb6ubaW4JLzO12kkJYL91XtCAwHzBs4Fen+KvAGj+MLqzu79bqK9s1kjgvdPvZrS4SOQqZI/MiZWKNsXKk44B6gEc/rPwB8Da7arZz6RLBY/2culSWdjfT2sM9qpYpFKsTqJApdyC2SC5Oea0UofaQjf+IniuTwX4VuNTi+x+cssUKfb5zFEGkkVASVDMxG7IRQWY/KOTXmWn/HzXdesNFtNK0Czk8Qahr11oBF5NPbW6tBbPcGba8IlClEztKg54BIw1er+LvB+meONJ/s7VI5nhWeO5ikt53glhljYOkiSIQysGGQQf0rK0b4S+FtBuLCez0+Vbiy1CXVIp5r2eZ/tUsDQSSuzuS7NGxB3Z5O773NKLjbXcDhPCP7QVz4o8WWVkuht/Zd5qNxpoeGC7eWAxGRRO7GEQ+W7xbcB8rvQnPzBdz4w/FHV/hzdaf8AY9Jhk06SCaefVL0T/ZkdCu2F3hjfyS4LHzZAEXb3PTf034T+G9J8RDWLW2uo51uJbxLU307WkdxLu8yZLcv5au29ssF/jc9WYmbxd8NdF8b3Mdxqa30cywtbO9hqM9oZoGOWik8p13oT2PTtjJp3hzLTQNTzi4/aOmbxRcWdnojXen2d/bafOII7meeVpViLyxNHC0OyPzeQXBYI5GPl3M039oqfxBrTW8OiTHSbi7vNPjkt4br7RB5IlC3DuYBCEdosYDkrvQnPzBe+k+DfhT+2I9Rjsbi2Ikhmks7a9mjtJ5IVRYXkgVxG7IsaAEr/AAJnO1cOtvhB4Xtdbk1KK0ulZpprn7Gb6c2iTy7hLMkBfy0dt7ZZVH33I5Yku9PsGp5Ppf7QGt6d4Aj1K10iG80/QfCWkeIdSm1K/d7qeO5ikLIrCMB5AIXO9sBm/h546rxV8aNd0n/hJ9S07QrC60HQNVt9GnNxetHdSyyGANKqhCoRTcKApO5sE8cA9XH8GfB0eg6how0bGm3+kWuhXMH2qb95ZW6ukMW7fkbVlcbgQxzyTxXJ+PfgK/jjxhcXssmlQ6bd3dpdzSi1kF4pgZDtGJBG7HywBK6FkVyBnjDvTk9ham58WL69uNc8FeGbfUbrR7PX9QmhvLyzkMU5jitpJhFHIMFGdkGWB3bVfHqOf8UMPhrJHY2ninUNUtrjXNCjj0ifUnlvbFZ71Ymd55GeWSCTH3JOvlyAPhsL6Z4u8H6V420xbDVrZp4UlW4ilimeGaCVc7JIpEKtG4ycMpB5I6E1j2fwj8M2dmYGtLm/d7+31OS7vr6ee5luLeRZIHaVnLMEZQQpO0dNuCaiMlZDPPbn9orUtDvvEP8Abfh+GyGnQXk8OmSyzQXsghfbEVMkYjmSUFWLQswjzzu5I6vVPHvi3wjorPr2haXJqd3e2dhpgsL5/s80tw4TbIzR7owhyxYBty9ADxV6P4IeEFuLlprC5vbeeG4txY3l9PPawxzgiZYoXcpHvBIO0DA4GBT7X4L+FLfTtRspLO6vl1DyPPuL/Ubi4uSIG3QBZnkMieWxyu1htb5vvEmm3DsGpZ8E+MNQ1rWNe0LWrO2ttY0V4fNksZGe3njmQvG67lDKflYFTnGM5INYnhf4ka94gjm8QPo9lD4LEt6nnpdOb2JLdnQSvGU2kO0TfKDuUMuc8gbumfCzw7pIgMVvdyXEd+upveXF/PJcT3CxmJXlkL7pQEOAjkoOMLwKi0/4Q+GNM8SDW4LKYXSzz3cUEl3M9rBPMGE0scBYxo7h2ywUfff+82VeOoHnniD9oTW/CPg628Tax4dslsdW0a41fTYLW9dpUMUInEM5KBctGSdy8Bl288NUupfGjxl4f1TW4tU8PaILbQZNOOoNa38rs8d5IqKsQMQG+M7yS2A3y425O3rl+Angj+zrvT5NLuLnTp7KTTktLi/uHjtrWQKHht1LnyEO0Z8vbwAB8oAG/qvw48O63JrEl7p/nvq/2X7afPkXzvs7b4ejDbtbnjGe+armgugamV8Wdefw/o+hzRtdA3HiHSrM/Zbgwtia9ijIYhTuTDfMv8S8ZGc1zHhH40axr2veHVu9HsbbR9f1TU9HtHhumkuEls2uMyOpQLtcWsnygkjg55wPTNe8Nad4pt7a31O3+0w215b38K72XbPBIssT5UgnDopweD0IIrNsPht4c0v+xvsuneV/Y97dajZfv5T5Nxced578t8277RL8pyo3/KBgYhSio6oDmPG7XPij4qaF4Pl1K+0rRn0q61WddNu5LSe9kjmhiWMTRssioolZmCEEkpk461V8RXvga5tvCmj6zD4u1bUdXltbNdUuiz6VEtqLho7mUF5JWUfMu4BmWaME4G89r4u8B6R42Ni+ox3Ed3Yu0lpfWNzJbXNuWGG2SxsrBWAwy52txkHFZrfCHwv/AGBb6StnPFHbXLX8V5HezLerdMrK0/2gP5pcqxUsWOV+U5XinzKyuB5/P8evEdxqtzoen+HtN/trTrXUrjUTdX0gt0Nm8AIiYRkuJBcRkZA27jnO3Ba37QmtaX4S17WdV0CySS28Lx+LLG3tL1nDQOXxBKxjGHG1csoKnceOPm9G034S+FdJdJLbS2WYWd1YNM1xK7yxXMiyT72Lku7vGhLsS3H3qyPHHwU0fxL4H1nRNLQaVeXvh/8A4R2C8Z5JRBaqD5alS3zbS2c/ePc1fNTvsGpj618YPEXhK61HTtf0rRrLUTaW99YyrqEht9klwsDxykx7jJGzqQsYbzc4UKa55vjd4r8RR+DW0eysLOSfxdN4f1RLrz4lmCWssylFkhEiKypuOQGDKFG5WLV38nwK8ITWtzE9peySzG3KXcmpXD3FsIHLwLDKZN0SoxJCoQPXNWY/g14Wg02KxgtLuARaqNaW4W/nNx9t2bGmMpcuWZCVbJwwc55Jpc0OwtTyjwj488Xa7428OW+gSfaFuLDxGZrfWr+RoQ1vrCQpKxVMsQAUVcfKsnU7fmqXHxk1HxZfJdWRv9FlfUPCaXFuL0vFH5+pzwXMKLtX5T5TKzf8tF2cDFeuXXwL8H3H2NorK8sbiz+1i2ubDVLq3mhFzMZ7gK6SBvnkJJ54HAwOKs2vwZ8G2axC30VIFi/s/Ysc8qqPsMrS2nAbHyO7Mf72fm3VXPC+39XuGp5b4X+JvjO+8SeE7DRo7a503UY/EjyxarePJPJLaaj5SDzBH8qAOoVQfuuVP3FLehfDv4tD4iarZ21nYeVB/Ydvqd87ud9pcTOyLbFcY3Dypt3PGwcc1rWvwp8NaddaLcWVnNZTaRc3dzaPb3cqlWupTLcK3zHekkh3FWyuQMAAVV+FXw3/AOFe2euSzm2fVNb1OfVbw2assKvI2RGgYlgo69cbncgDOKiTg1otQ1OC8V+ONb8KzfEHwkl7cSa9qNzat4ankcs6pqB8gbST0t5kuHPOFTZUU3xkk8D3Gu6VFHeajenxS2i282pzz3aRJHptvO0pWKNpNvP3FByzliwBOPWdW+H+ga94r0TxJf6ctxreirKLG6Mjr5IkG18qCFfjONwO3J24yao6p8J/DOrC8MljNBcXWpf2w93a3c0M8d55KwedHIjhoz5aBNqkKRnIOTlqULaoZ59/w0VeQ6Uk914ckt7q4sbs2MUhliS8vobqOBIF8yNWCTGeF1Yru2l/lytdZ8L/AIsP8TLp1i037HDb6XaXN2Wk3NBeTNKJLXgYJjEQy3+2K1B8I/Cv2TQLeXTWuF0O9Oo2MtxcSySrcksWldyxaVizFjvLZbB6gYktfhT4XsdN1nT7XTTbWms6kdYvlt7qZGmujIkhk3B9ygvGpKghTyMYJBTcGrINTL+O+sX2hfDw3enXc1ldf2vpEPnQuVbZJqVtG65HYo7KfY074tfE4/DmHQ4YLUXN9rF21rC0kc0kcCrE8jSMsKPI2AmAoHJPJAya6bxf4Q0vx3oM2jazDLcafNJFK6Q3Mlu4eKRZY2WSNldSHjVgVI+7WHN8IPD1xpcdhK2sXCw3Qvbe6uNdvp7q2nCFA8U8kzSR/KzDarBSCcg5NTFxsrgef6p+0Nqdr4XsNRg0a1t79kvpJrK8+1+ZMLZ1XMEK25mKSBgwkZFVAQGBJpviP9ojV7Oz1zVdJ8P2dxo2i+GrTxJdvd3rJMyXMU7RwoqxkFgYeWJAx9a7e6+BfhG8jsontL5BawzWxeLU7mOS6imYPNHcOJN06u43N5hbJ+pzdk+EPhGbSdV0x9I3WWqaXb6LeRfaZv3tpArrDFnfldolcbgQxzyTxV3p9g1IfA/jbV9Y8WeJPDeu2FnaalpMNpeCTT52kiaK480KuWVTvVoHBOMEYOB0rz/TPiZ4l8P+MvFr3UcGpeGx43tdCUzXL/aLf7Tb2SIsS7doRZJgxGed79MfN7La+G9OsfEWpa5Bb7NU1GCC2uZ97HzI4TIYl2klRgyycgAndznArNm+G3h25+2eZpuftmrwa7P+/lG6+h8nypeG4x5EXyj5Ts5BycypR6oNThP+Fz67NY2euW+hWUvh7U9Tm0fTx9rYXRmEkkUMsi7NoSSSPaVB3KrhiTyow3/aojaN7iHQnksm8PDUIZmmwzaoYkmGnFccOUlT5s9cggYyfTLP4TeGNP8AECavFYzLPHdSX0Vq13M9pDcybt86QFzGkh3tlguckkckk14/gl4Jjs7a0TQoxb22tf8ACRQp5suFv+cSj5s8A42fdxxtxxVc1Pqg1M/44eLPE3g34cw6poAsY9WOpabbTfaXYxqk11FE4X5GzkyBckDCsWHzAA5uqfGLWtPj8QasmjWUvh/w5fR6dqTfanFzJIViM0kK+Xt2RmbgMQz7D93jPofi7wnpvjbQbnR9WieWynMbsIpGjdXjdZI3VlIZWV0VgQeCKwrr4PeGL/VzqFxaXM0kksM9zCb6b7PdzRBBFLPCH8uV1EafM6knaM52riYuNtUAfE7xxdeCdO06SzWxNzfXf2ZDfPIQP3budkUSNJK52YCIPVicCuT8N/GvWfHlt4Yi8PaHZx6nqen3WpXaancSxRW6QTrA0aHyt5Z5CcFkXaoyy5+Wu/8AF3gPSfG39ntqQu459PmM9pdWF5NaTwsysjYkiZWAZWKkZ5+uKxpfgn4SOm6RY21hc6bDpImS0fT9QuLeVI5n3zRmRJAzI7clSSOBjBAwJwtqB4z8JPjVq1no9nLqQvNUvriLw3azG81AuitfX11Azqu04dQuSc/PhB8uK7/xF8bNZsf7eXT9AEkeleIm0We/aOe5it4xZw3AnkjgjaTBeUR8Dav3mYdKn8N/s96Ppc3iW1u4II9Bv4LCysNOsJJo2tIrOWaWCQTF94lDzbgykbdi4rdT4IeFbezkhtY9Us55L19Ra/g1e7S7Nw0KRPIZvM3nckaKVJ2nGcZ5rSUqd72Fqcx8OPif4o8bfFKS0mj0dfDUnhqx1VEsbs3DLJLLcIzLIIwHBaIjBIwqg43FlGx41+L1x4P1rXNJfTI5dQSKwfRozKyjUGuZzb7CQDtKS43YzhXDV0Oh/C/w74X1ax1HSrWaxubOxGmr5d1KVkgDu6rKpYiQh5JGDNlsu5zzVLxN8Nx4q+J3hbxLeNbfZPDsNw1tGEYzyTygKdxzt8tQqsAQTuAORjmLwvtoPU5hfjZqq2dl4hfRrP8A4RPUNTl0m1dbpzeB1kkiSZ12bdjvFjaDuVXDEnlRn6r+0fPpXgzSNdOhxyfbfA0vjB4RckbWj+y/uAdvIP2k/N/sdOa721+EXhiz14arHYzeal1Jex2kl3M1pFcybvMmS3LeUrtvbLBerE9WYnKtv2efAtvZ3NodLu7i2uNNm0bybjU7qRI7GVkZreIGQiNMxJgJjbjjFO9Pqg1NHWvFHiXwx8M9U8Qajo1pca3p9vJeSaZp9y0iNEp3MiuyqWcRg9sFunWuK1X4zRX3xF0OK1Sd/D0OpPbrqFrcsqXLDSbi7kDx7cSIq+VgZHz+6Yr2qSNZUKOqsjAgqRkEHqCK47w98H/CPhXT9BsdM0cW1roU811p6m4mfyZJY3idiWcl8pK6gOWAGMYwuJjKOt0B5hpX7Tmqahodzqy+FZJoG0eTWoYoIroGCOMI7QyvJCqM5jZmUxllLIV9GOz/AMNEfavE2r6TZaOs6G/s7LRbrz/k1ISXAgunwB8ogcOT1yq+vFdr4b+D/hjwrMzWNncmEWz2UNrdX09xBbW7Y3RQRyOyxIcDKqBwAv3QADR/g34P0FvCr2OirA/hdbhNIYzyubYTjE3LMS5bqS+7nkc1TlT7C1Ifix441bwLpmnXGmaV9ujuLnybm8eCeeKxj2MwkeOBHkILALkDaucsQBz51qX7Tt0ixjTtFtr+a30qDU7qOzkubtLhpfM2wW8kEDLuxFndJsGXClR8xX1/xX4J03xlFa/bmvbee0dnt7vT7ya0niLDadrxspwRwQcg+nSufuvgX4NuIbaKKwu7OKG2WxdLPUbmEXNurM4in2yDzl3SOT5m4ne/PzNlRcLaoZ5b4o+MHxFto/H1xpqaPHa6X4j0exsftLOskVvdfYjsZDEcswuBuycqXfbnYuehsfiprlr4o1DQrGwju9Vv/Fk2jK2oX7tbW5TSYbtmTEe4IMMAmOWydw3cd7rHwg8M65Jrr3FpcKNaFu15HBdyxo0sBTyJkVWASRPKiwy4P7tPSrNn8L/DWn6rBqcVg51GHUG1VbmS6ldjdPaC0aVstgkwDaQRt/ixu5p80LbC1OH8O/GbXvG39g6fo2i6eutXVvqFxfC9u3S3jFnd/ZHWJljLMZJASCR8q8nJwKwtP/aR1vULfw5fzeG7XSNM1S3t5hPfzzCGZ5JmjaKO5WMwxvGApxKy7y+FwPmrrPGXwVt7zT9ItvD1ppMMFjNeSm31RJ5MtdSGWVllSRZADIzM0ZJRg23AwuDw3+zr4X0Pw/o2mXBvrw2NrBb3AivZra2vjEcq0tujiNgGOQpB4wpLAU707bBqeq0VmaL4fsvD8d2ljHLGt1dS3kvmzvKTLIxZyC7EqCTwowq9FAFadYFBRRRSA+Df7Y/2qP7Y/wBquQvrifT7ye1uUaC4gkaOSNhhlZTggj2IqH+0z619Sc57R4UlsofBPiHXpIbO4vLOa2hWa+t1uI7GN2YNMY2BB5AG4g47da0ta8K6fb2Z1rUrhbOwlFkIofDsC2yu1wrbZCkqsIwfLztCjcz8Y7+LaL401Tw3dG50rUbnT7gjaZLaRkJX0OCMirkHxP8AEtrfSXsXiDVEu5I/KecXcm9lBJCls5IBJI96dwPV/DOl2Oi/E3UdH1e2t9ftNLjvGeK5hRo5/KhdlJQ5APyg+xrav/h7p7abpJtZgljePfX8OowojXc1lHBHKkeSOXU7kweA2849fnu38UXttcyXMN5cRXEgdXmjkZXYOCGBYHJyCQfWp7fxtq9mlkkGq3kSWTM9qsc7KIGY5YoAflJ7460Aez6T8PrbxJHZto2qXkr6hYx31jBc+UzlTciCQOyqAwAO8MAvHUYFUvG3hG18JaWmpW+pXV5Z3U0aae8yovnxmFXkkbCjJV3VBjjr3FeVyfETXptWOqtrd+dSKeWbsXTiXaeNu4HOPbpVO68VX9/a2ltc39xcW1oCtvDLMzpCpxkKpJCg4GcUXA6r+2P9qj+2P9quK/tM+tTWNxPqF5Ba2yNPcTyLHHGoyzMxwAB7k0gP0hooor5Y6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKUtgCiiiqAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAwdU8C+GtcumutS8PaXqF02A091ZRSuewyzKTVb/hVvgv/oUNB/8ABbD/APE109FVzSXUDmP+FW+C/wDoUNB/8FsP/wATR/wq3wX/ANChoP8A4LYf/ia6eijml3YrHMf8Kt8F/wDQoaD/AOC2H/4mj/hVvgv/AKFDQf8AwWw//E109FHNLuwscx/wq3wX/wBChoP/AILYf/iaP+FW+C/+hQ0H/wAFsP8A8TXT0Uc0u7CxzH/CrfBf/QoaD/4LYf8A4mrOl+A/DWh3iXeneHtK0+6UELPa2MUcgB64ZQDzW9RRzS7jCiiipAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiiplsB//9k=');
            } else {
                anchorTag.className = 'ie-upgrade';
                anchorTag .setAttribute('href', upgradeLink );
                imgTag.setAttribute('alt', upgradeText);
                imgTag.setAttribute('src', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/4RCERXhpZgAATU0AKgAAAAgAAwExAAIAAAAeAAAIPodpAAQAAAABAAAIXOocAAcAAAgMAAAAMgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoAAAB6hwABwAACAwAAAhuAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4QmoaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaDwveG1wOkNyZWF0b3JUb29sPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIACoDugMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP1Fooor5Y6AooooAKKKKACiiigAorwn4veKJdc8SHTLI3Bt9DikvZpLfHySoFLSnJ5EIZemTuc8HFeqeA/Ew8XeGrW+YKt0uYbqJeiTLwwAycAnkZ/hIrxcLmtLFYuphIr4dn0lbSVvR6Ho1sFOjQhXfXddr7X9UdFRRRXtHnBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRWf4g1BtJ0HUb5Ape2t5JlDdCVUkZ/KmtXYDQor5WuPiLr1xM8r63fBmOSI7hkX8FBAH4VH/AMJ9rn/Qc1H/AMC5P8a9H6lL+YjmPq2ivlL/AIT7XP8AoOaj/wCBcn+NH/Cfa5/0HNR/8C5P8aPqUv5g5j6tor5S/wCE+1z/AKDmo/8AgXJ/jR/wn2uf9BzUf/AuT/Gj6lL+YOY+raK+Uv8AhPtc/wCg5qP/AIFyf40f8J9rn/Qc1H/wLk/xo+pS/mDmPq2ivlL/AIT7XP8AoOaj/wCBcn+NH/Cfa5/0HNR/8C5P8aPqUv5g5j6tor5S/wCE+1z/AKDmo/8AgXJ/jR/wn2uf9BzUf/AuT/Gj6lL+YOY+raK+Uv8AhPtc/wCg5qP/AIFyf41Jb/EXXreZJU1u+LKcgSXDOv4qSQfxo+pS/mDmPqmis/w/qDatoOnXzhQ9zbRzMF6AsgJx+daFec9HYsKKKKQBRRRQAUUUUpbAFFFFMAooooAKKKKACuc8e+KF8I+Grm9QK90cQ2sR/jmbhR1HA6n/AGQa6Ovn74zeNrf/AITYadeySW1vpsSmJWjciWSRQWkyBggKQo9Dv9a8TOsbPA4KdWkm5vRer6/Lf8D0suw0cViYwn8K1f8AXnsc/Yzw6bHrgu7pBJc+HtShWWdwrXFxJ5RCgk/M7tuIUcmuq+GPiL/hHfFqW0r4sNW2wvnotwP9W3/Ah8h99leczeLtHkclp2uFMLxoqyTQeXIdu2XKqd+zDfIflbdz0p9x4s0e5haP7Y6E/dZYX3Kw5DDjqDyK/IMPicThXh6tOLbptvZ31et9Lartc++q0aVdVYTekku3ytr08z66ornPh/4guPFXg/TNUuYvKuJ0PmDBUFlYqWAPIB25Hsa6Ov3WlUjWpxqR2aT+8/MpxdOTg91oeKeMrzxbpHjiXwbp+oXTWvjNmuLDVWkBk0dI1UXqLk5xsKtFjO15D/Coq9q3xc1PRU8QahZ6RbXPhXwxfx6XezT3bm9mIWLzZY1KlSI/NHDNufY/K8Z9JvfDun6hremaxcW/majpqypazb2HlrKFEg2ggHIReoOO1YOp/CXwzrGvS6tdWUzTXE8d1dW6XcyWt1NGEEck0AcRyOojTBZT9xc52rjr5ovdGZz3h34yz61/whW7S44v+Eh13VdHbExPkLZ/bNsg4+Yv9kHHGN/fFT/F/wCKV78O/siWFtYXcr2txeNDcvM00qxbMpHFBHI5zv5kI2rxnOa1dP8Ag74W0vxRBr1vZ3K39veT6hbI1/O1vbzzq6TyRwGTy1LiWQtheS+etWvF3wx8P+OtRt77VYLo3MNvJZs1pfTW3nW8hUvDKI3XzIyVUlWyPwJyrw5lpoGp53qv7QuoW39qajZ6DBLoGkeHbPxDeSS3TLcyLcxzGGCJAhBctFgsSAB2rp/hb8Ur7xvq2pabqGmfZ5LaCK5jvLa3ukt3Ds4aLM8MZ3oVGSAQwcHjkDet/hb4WtbPUbVNIja21HTLfRrqGWR5Ems4VkSKIhiRhVlkGep3ck8VN4S+H+k+C5rqaw+3TXFyqRvcajfz3kojTOyNXmdmVBuOFB6kk5PNDcLaINTkr74zT2f9t40uN/7P8Y2HhZf3xG9bj7HmY8cEfaz8vfZ15rhfHHx61q20Pxxa6jpX9hy2WnajPDbR3U1lqKrAcJJHI8XlyiRcNuhL7MgHdyR6rqXwd8Lax4kfXLqzuXu3vLbUXijv544GurcoYZ2hVxG0g8pBuI5CAHIqndfAXwZqCXsN3YXl5Z3UE9v9iuNUunt4I58+cIUMmIt+eSmCBwuBVRlBdBamFffGjWLXxLqCDR7E6Dp3ii08LzzG6b7U8lytvslVdm0KrXMeQSSRnpjlll8aNdvLjQdQGhWA8N674gk0K0k+2N9ri8tp0MsiFNp3GBvkByvGc8472b4beHbn7Z5mm5+2avBrs/7+Ubr6HyfKl4bjHkRfKPlOzkHJzwK/AV5fiPZ69cyaVHY2WryazC1nayJcSSMrgIw8wxJhpNzSIoaTYN2OTQnB9B6mz8X/AIpXvw7+yJYW1hdyva3F40Ny8zTSrFsykcUEcjnO/mQjavGc5rmPEH7QuqWtjrOraZodnLo2iaBp/iO9N1dMs7wXIlYxRqqFd4WFjuJxnAxzkejeLvhj4f8AHWo299qsF0bmG3ks2a0vprbzreQqXhlEbr5kZKqSrZH4E5gk+EPhGbSdV0x9I3WWqaXb6LeRfaZv3tpArrDFnfldolcbgQxzyTxSi4W1Qalv4h+MpfBei21xbWa3+oX19babZ28khiRpppFRS7gMVQZLEgE4XAGa42w+MWqWvxE0vwVrGk2qatPqJtJ7mznZoDE1jcXUciBlDbiYGjKnp97JyK9F8SeGdN8YaRLperW32qykdHKB2jZXRg6OrKQyMrqGDAggjINcy/wV8LSaetu0F+1yL1dR/tT+0rgX5uBGYhIbkSeZ/qyY8bsbTtxipjy21A4HT/jZ4k1nxp4SljtLCz8NXdv4ge+hMjyTH+z71YC64j67cMFB+YyOD91SaV98WvFseseCvEGoWen6ZouoaFqWsxWceqskZCwQyRR3TugUFQ+S4DAEtxwC3qWm/B7wvoo0EWFjNZ/2JLdSWZjvJiQLmTzbhHJcmRHfDFWyMgY6Vkr+zp4D8gwS6Vc3NuttNYwQz6ldSJa28oAeGFTIREnAwFA27V242rjTmp32/rUWp5/r/wAfPFV54Q146Pa6bb63o+r6PbvdSJcx289veXMaAok0AbJLbC2Cu0l1bcNtb2oftB3ln4yvdKj0P7TbabqNvpd2ttDdyzSSOsRlliZYDGEj83o7qzBHPy/Lu7Bfgn4U/snWLCW3vrk6v9na+vLrUriW6leBt8EnmvIWVkbBUqRjaOwAqeb4Q+GrjXBq0kF4blpYbi4iGozi3upoVVYpZoQ4jkdRGnzMpJ2LnO1cHNT7Bqeeap8S/FPiS+8FalaW1vpvhnUPFp05Hhu3+1SwxfaEJmTYF2SNDu2g5X5M5ydvbfEL4rJ8O9ZaHUrL/iWvot3qVvcoxLSz2xQtbBQPvMkgZfXa4qxF8FfCUPiCLVhY3PnwXzapBAb+4+zW905YvNHBv8tHYuxOF5LE/wATZ2vF3gLQfHSaYmu6eL9dMvY9QtQ0jpsnUEKx2kblwxBQ5Uj7wNTeF0M8qX9orU019rCXw63+g3lrp2oW8Ed1NN50iwmZ4mSAx7ITNyHcMwRz8vy7hvjl4vuPDx16HwvZw6NNq11pkV4jXN4bdLea4ieeeKGIuFZ4lVdoIXJZmAwD6Lf/AAn8Oah4kk1qW2uUupp47u5hivp0trmaIKI5JYFcRyOoRcEr/Amc7Vw24+EfhubR7XTbaC80yOzurm8t5tP1Ce3niluJHkmKyI4bDtI5KkleeBwMPmhpoGp5vpXxzuJtW1S6hskvL69s9BisrWLVfOsDcXk93GCriP5EHl7mbBZgoG0MMVqXXxl8SWfi6z8FtoumHxRPqAs/P+1SCy8trOa6WYfu92QIJFKeoHzYbI66H4K+DLbT7yyi0UJb3cFrbzYuptxW2keWBg2/crpJI7iRSHLNksSBVjR/hN4a0a+sb+KymuNTs7t79NQu7uae4adoGt2d3ZyZP3TsgVsqo+6BgUOUOiFqM8A/EEeKvh2PE1/bCwaA3kV3FC5kVXtppYZShIBKloWIyM4xXlnxA+NnjCy+Ft3qqaXp+lza94bvdU0ae3vXeWyaK18/bNmPaX8rcylfl3psPB317h4d8Mab4V0n+zNLtRa2Pnz3BhLs43zSvLKcsSeXkc4zgZwOOK5a1+Bfgy3sryy/syeexuLCbS1tZ764kjtrSZQssNurSEQoyjB8vacYAwAAFFxTu0MxvEUmq+E/2YfEFyt5cQazZeF725S6F/NdSpMLaR1cTzHzGYNggnp0HAFZVj8bdbW6y+k2cmh2PiCw8M3Nw105upJrmK2KzKuzaFD3SZBJLDPTHPrOr+GdN8QeGb3w/fW/naRe2j2E9vvZd8DoUZNwO4ZUkZBz71kj4X+GEt7iAaZ+6n1S31qRfPl5vIBCIZc7sjAt4flHynZyDk5SlG3vIDyLR/j14o0fw676/Z6fc6tfeKdT0aze1E8sUEdtLOGZ1ihLuFEQVcLubILFecbOm/HjxDr+oaLp+m+GbaK7ms7++vm1Gee2RIbS4iid4VeEO4kWZWTcq4z83Q120/wa8L3Ed4gt7yHz9SfWEeDUJ4ntrt9/mSwMrgxFzI5YKQrbzkEHFXNH+F/hvQ5rWe0sJPtFvZ3NgtxNdSySNFcSJLNvZmJd3dFYu2Wz35NU5Q7C1PM7H9o7UbHw/Drev6FbR2moeEm8WWEGm3LSSeWpgBgkLIBvJuYsMBgcjnGTleJ/j34vl8LagdJ02zttUtb3ScX0kF3HatFc3qQSRDz7dSZFLKCQMbZN64ZdtevL8JfCS6fZWR0eN7Sy0V/DsMMs0kijT3EYaEhmO4EQx/Mct8vXk5pf8KV8LPo+pabNFqN5FqAhWWe91S5uLhFhcSQCOZ5C8YjcBlwR83JyafNTT2DUy/2hNW1XRfg9d3VnJd22ptfaXC/9k3PlzESX9vHJHFISmCyuyhiV+9yRWLqHjiX4M+BZvE+paH4kt9Hivli1GDxHq0V5exRMoVJoNk8yspkdVKb1bq2OBu9N8TeCtJ8ZeGX0DV4p7zTWMLMFupYpd0UiSRuJY2WQMHjVtwYHK1mWPwn8OWclo0kepap9juDdwLrGs3moKkpjaPcFnmccI7AZHGcjnmpjKNrMZw03xe8azXesWtj4a0Z7jRdDtNcvll1R9kgnE5+zxMsZBYCA4kPy57YOay/BPxh1XVtT1m30tTqd7rnihrfSU1SV44bK1Gk2l05YAMcDc2EHVpOoGTW/a/s1eGY/Emr3L/aU0W70210yHS7a+uYRHDE1w0kTssmZIn85QIz8qiPaPl4rq7z4R+FrqG5jXTXs2n1Aar9os7qaCWG6ECQCSJ0YNEfKRU2oQpXII5Oa5oJbC1OFtfjtrt/4pi8PQ6DYRX9kt/LrM0t65hgjs5bdZGgxHmQulwjKCF2k4b7vOHb/ALVF7/wiuoa9P4aZ7VdEn1q3SOO6QQ+WqOsE0kkCxlnR8hkLLlCOeGPr+g/DHwz4X1C1vtP0zyr2C3uLVbiSeSV3SeVJZzIWY+Y7vEjF33N8vXGaxoPgL4Lh02901tPurjTLqyk00WNxqVzJDb2r43xQKZP3KnaP9Xt4UAYUABc1PsGp1vhmbWbjSIZNftrOz1NixkgsJ2miQFjtXcyqSQuATjGeleO+Pb6+v/j1d6O48XXmmReHLG5jtfDN+bZIZZLq8R5JAJo85WNB/F9yvZ49Bsk8RS60I5f7QktUsy/nuU8pXZwBHu2A7nPzAbj0JwBTI/DOnQ+JrnX0t8atcWcVhLcb2+aGN5HRNudow00hyBk55PAqIys7jPOdY+L2qaT/AMJDqdrpFtceF/DOoR6ZfSzXTi9mO2IyyRqEK4TzRwxy+xvu8Z3vhT441v4hWeo6re6XZado6Xl1ZWXk3TSzytb3MsEjupQBAWi4AJPrVvU/hL4Z1jXpdWurKZprieO6urdLuZLW6mjCCOSaAOI5HURpgsp+4uc7Vxu+HfDOm+EtN/s7Srf7JZiee48rez/vJpXlkbLEnl5GbGcDOBgcU2420WoHgngf4h+KdB8P69rGrT2Nxq2p+LNQ0uEXWpXdzDCtvNcII4LZYyxwItoWFAWX525BrX1D9ojV28G+GvEVn4ejtLHUba5murvUPtRtreaGTy/IZ44S0W4q5EsyIqheRnIHod/8HvC9/bQQraXdk0GpXOrRXFhfz286XFwzmdllSQMA5lfKg7fm4AwMVZvgZ4Qk0uy063tL7TrO0hktkj0/VLq23wSyGSSJ2SQF0LMTgk4z8uKvmg9WhHnq/HjxJoN18QLzVrLT73T7HV9P03SLe0meQq11b2zruaOJi6BZvMZlDNnKqGG0m/b/AB68Q6pJpWk6b4ctptc1DV30uG4vDdWlk6rZvc+evmQiTAEbqU2/eThsEGu8uvg34Tu21UNp0iQamtsLm2hupo499uEEMqKrDy5EWKIB02sPLXnip9H+FXh3R7rT7tLW5u7+xvJNQhvr69muJzO8DQM7u7kv+6coFbKqPugYFLmh2DU62Pf5SeYFD4G4KcjPfBOK8Ut/j1q9vrGv2uq6NYaQ1jb31xFZandS2UwW3PyO0ksYjljkXDF4WcR553da9V8M+HU8NxagiXEk5vb6e+YyFiFMjE7VySQAMd8ZzgAcDlbj4DeDrxbyO6sLy8tbiGaFbO51K5kgt1m5l8lDIRESf4kAK/w4qYuK3GeVeOfjN4m8UfDvxPY6bHBp+rafqmj2k19azXlmslteXMaZhZ4kkViSULLxtYurbgFrpZPjxc6L4lm0GDRpb2z0e+tdHuigvbm6mdli8yVJBCyMsfmZPmOGYI5OON3dWvwZ8K21pfwSWd3ftqM1pPeXF9qNxPNcSWsolgZpGct8jqCADjACn5eKsX/wn8Oah4kk1qW2uUupp47u5hivp0trmaIKI5JYFcRyOoRcEr/Amc7VxfNDawtSn8KfHGt/EKz1HVb3S7LTtHS8urKy8m6aWeVre5lgkd1KAIC0XABJ9a858BfFjxXovhWy1LWbSDVNEuvEOp6Ul29273oIvrpYHKlSuwFFi25yqgPnHy17d4d8M6b4S03+ztKt/slmJ57jyt7P+8mleWRssSeXkZsZwM4GBxXK6f8AAzwbpepLd2+nXICXM94lpJqFw9qtxMX8ycQs5QSHzXAbGVDfLip5o63Wgzk/Bvxg8Y+Nrbw5Fa6Bo1nqOvaR/wAJBAtxfyvFb2REIRXIjBaV3l6D5VUckng5d9+1DdR+Hb28tvCr3GsG3tZ9P0r7Vg3e5rhblFfbjMX2O5OQPmHlk7Q3Hpl18I/DNxpehafFa3djFodqLDTptPv57e4gtgqKYvOSQOyFYkBDE52A/eANT2nwt8K2GqeH9QttGgt7vQLaSz014i6rbxOu1l2g7WyM8sCRuOD8xy+anfYWpwes/HbUptPvNS8P6It7okeqLp66wY57iJI/sqTNO8UEbybPMfygQNoILMQMZxLf48X51DUL+0sIb+6u4PDkENsNWMtgJb66uYN0bLH8oBUFmxuYYBVSuK9Itvgn4S03wvpXh/S7O60bT9KkkksG03Ubi3mt2kLF9sqyByDuOVJI9uBh1n8FfBunBRb6Ns2vYOP9KmJLWczT2zEl+SskjsSfvFvm3UKVPsGpytr8ZNevLpPD0Wk6efFZ8QT6EztcOtiPKtFu2mB2lzmJ1XZ13Z52jNdj8L/G17450jVJ9R0+HTbzT9UutLkhgnM6FoX2F1YqpIJGRkCsvxx8JLTWdNuxo9tYQXt3q6azc/2gJpEnnEKwFlZZFeF9iIA0ZGNv3TubMPw1+DEHgODSmN4huLS41C8khs42htzJdOpKqhdvkRV2jduYn5tw5BT5OUepa8aeOfENj4/0rwl4c0vT7u8vtLutTa81K5eOOFYZYE2lVRmbcZgOCMdeeleW6Z+0ReQ6h4o8QTWdw8cmn6Db2uiyTPJFbXk91ewTEFEZigaLJZULMsYwucCvUvGHwktfGnxB0nxFe3tzBDp+l3VgkVjcTW04eaWB/MWaN1YALE6le+/2q0vwX8GJp91YR6GkFrc21nZyJDPLGRHaO72xRlcFHR5GYOpDbuSxIFNOCVmhanFx/HjUp9Bkb+zrO01JdTXT0uLuO8jt7lTAZhJBCYfPlbIKGNVO0gtuKjmlqH7RGrt4N8NeIrPw9HaWOo21zNdXeofajbW80Mnl+QzxwlotxVyJZkRVC8jOQO7k+CfhiW0t42Gp/a4Lxr5dTGrXS3xlaPymJuBIJCDH8m3dtC4wBgU2b4GeEJNLstOt7S+06ztIZLZI9P1S6tt8EshkkidkkBdCzE4JOM/Linen2DU424/aOmbxRcWdnojXen2d/bafOII7meeVpViLyxNHC0OyPzeQXBYI5GPl3ekeKvGT+HfFfgzR1tFnHiC/ns2lLlTAI7Se43AY+bJh24465qlJ8G/Cn9sR6jHY3FsRJDNJZ217NHaTyQqiwvJAriN2RY0AJX+BM52rjY8XeCdL8b2tnDqaXAayuBdWtxZ3UltPBKFZNySRsrLlHdTg8q7Cobg2tBnmej/GvxJ4y1TSNK0DQdNS+v4dYnabUL11ihSx1AWgyFjLMZMg8Y2574qpB+0HrevaDq2raJ4bs/L0DRV1XVra/vmRzKfPDQQMIyGCm2c+YwAbgADkjdk/Z30CPxJodzYyXem6PpWn6haw2tnfXMVwJrq6jneUTiQPyVmBUn/lpxjArO+In7PMHiS1g03RYtF03SP7I/sYLc2kry20WWwylJFE2A5ISYMoYbs5LZv93cNSGz+O2v6lp/iHVI9J0ax0jSrq204XF/qMivJczRWso+VYz8qrc/dGWdsKoHWrGg/HTVvFGn6dZado9sviO81q50Y/azPBaoIITO85V41lAKbQEKg7n+9tG49gfgz4V/4R+70dbO4it7m8h1GSaG7lScXUMcUccySKwMbhYIx8m0cdOTmP/hS3hNdI/s2KzvIV/tA6qt1FqNyLtLwpsadZ/M8wOy/K3zYYE7s7jlc0Owanknh/49a9otxf6Pf20dxrs2savK73D3V1b2sEFwkaxIYIXcgl8KSqhVGTzhT6R4y+I2sSfs761420SxbSdaj0GbU47XU0ZWtpEiZ2DKVyzJtbAKgMQM4Bq6vwH8HQWkEFnZ32myQS3EyXljqt1Dc5nKmfMyyB2EhRSwJILDd97mupfwhpEnhKTww1jGdBks2097LkIbdkKNGTnOCpxnOaJShdNIDzlvip4rMN/BaaNpd5e6Do9vqmrGS9kRJmlWR1hgIjPzbIslmAUFwMHkjqvFHxCTTfhza+KbBbYR3sdrJb/wBpzNAgWdkClsKzFgH4RQWY/KOTUF98E/C2pW9vFdRahMY7NdPmk/tS5V7u2UsVhuCsgMyAu2BJu6kdCQd3xR4J0nxdocekX9u6WkMsU0BtJmt5LeSJg0bxvGQyMpUYwfbpSbhdWAxfhH8RJfiNoN/dXNoLK80/UZtOnVUlRZGQKRIqzIkigq6nay5HqRyeP0H47aleX+iXWp6PZ2nh/V9Q1bTYJLe4eS5jksvtJaR1KgbWW0lwoJIOznnA9L8I+C9J8DWVza6RbywR3Vw15cPNcS3Ek0zKoaRnkZmLEIMnPJ56k1Usvhn4a09dHW30wIukXt1qFkDPIwiuLnzvPflju3faJvlbKjfwBgYV43egHkulftOapqGh3OrL4VkmgbR5NahigiugYI4wjtDK8kKozmNmZTGWUshX0Y7P/DRH2rxNq+k2WjrOhv7Oy0W68/5NSElwILp8AfKIHDk9cqvrxXa+G/g/4Y8KzM1jZ3JhFs9lDa3V9PcQW1u2N0UEcjssSHAyqgcAL90AA0f4N+D9Bbwq9joqwP4XW4TSGM8rm2E4xNyzEuW6kvu55HNU5U+wtTgtG/aOn1rXxHDoTyaTNe3VjG0cF0ZovJ80LPIxh8nY7Q7cByV3oTn5gvafDXxj4k8cfDS28TXWk6fZXWqWMeoaZYwXbSAxyQq8azMUUKxJ5wCAD7VZtvhB4Xtdbk1KK0ulZpprn7Gb6c2iTy7hLMkBfy0dt7ZZVH33I5Yk9J4f0Kx8LaDp2jaZB9m03TraOztYN7P5cUahEXcxJOFUDJJPrUycbaIZ41qH7TSR6HY6lY6K1yk+m2E0qM8gNve3c/lJbuEjZvk2Ts+0M3yABTuFPt/j14h1STStJ03w5bTa5qGrvpcNxeG6tLJ1Wze589fMhEmAI3Upt+8nDYINd7F8HPB8Gk65pkejiO01q+Op3qrcTBnud4kEqOH3REOoZfLKhW5XBJqbR/hV4d0e60+7S1ubu/sbyTUIb6+vZriczvA0DO7u5L/unKBWyqj7oGBVc0OwankHjj49a3baB43tdT0r+w57LTdQnhto7qey1BVgOFkjkeLy5Q64bdCX2ZAO7kjtte+MGqaa/iTVbbR7Wfwx4b1FdOv5HuGW7lbERlkiQIV2x+cPlJy+w428Z1br4C+DNQS9hu7C8vLO6gnt/sVxql09vBHPnzhChkxFvzyUwQOFwK0tT+EvhnWNel1a6spmmuJ47q6t0u5ktbqaMII5JoA4jkdRGmCyn7i5ztXBzQ7C1OQ8I/GjWNe17w6t3o9jbaPr+qano9o8N00lwktm1xmR1KBdri1k+UEkcHPOB7DXMWHw28OaX/Y32XTvK/se9utRsv38p8m4uPO89+W+bd9ol+U5Ub/lAwMavh/w/ZeF9Fs9J06OSOxtI/LhSWd5nCjnl5GZmPuSTWcnFv3RmlWD4/by/AfiR/7um3J/KJ63q5/4gWs154D8SW9vG01xLptzHHGvJZjE4UD3JNEfiQM+Lf7Y/wBqj+2P9quLbVCvBPNJ/aZ9a+mMD2SGPT28E+Hr5rW3a6u9bkspJvLUvINsRWJmxkjliFPqa6jVvAeh3PiiOBb2+05NT1u60qzttMhhFvAYyCp2lT8ozyoI4BIK4rwnRfH2t+G0mTStWvNOSYYkW1nZA3bJAI5960rf4ua/Z+G4tGs76Syt0lmlkltpnSScybdwchsMPl449aYHp8Hw9gaG1We91WS8n0y41Q3FnCjWCLH5gEZYoW3Ex8tu/jAC85pmp+CdM0+4ki/tLV5VtrOC7vbmR7a3t7cTKnlpvZGOSzkcIxbgBRgsfOtJ+Lt1onh59Ns9PtYJ2t5bU3sbzKxjkyGJjEnllyDt8wpux371k2vxF1+xvJbu31u/gupYhA863Th2jAAVC2c4AAwO1FwPeIfhvpXhfxlodjrN5d6x9u1eSygt1giMDpGEYidGVixIfkAr8qlsEVh6l4Is7W1Wd9Ya2u7mzuNQt7WPb5YSORlEflBC5BC8yB1VSRlTXlFv8UPE1t9o8nxDqkZnkWWUrdyAu6gBWJzkkBRz7Cq6fEDXE0ufTF1i+GnzsXltftDeW5JyxZc4OTyfWgD2D4f2uh634W1hdVgt0ubi8trG01KSNS9nI6ylWDEZVC6KrAEZXNW/F3g3TdEubyfUWn0q3shp1lJZ6OIUc3M0ALOxZWXBdT0GWY9R38FTxFdR2clotzMlpIyyPAHIRmUEKxXOCRk4Nalt8TPEdnfz30OvalHezRiOW4F2+91AwoZs5IHb0ouB7bY/CW3m1CWK4125S0s7+ewv7qJIx5bK8SQlQQQC5lGQS2MHHSuK8YaY3g69s7G4mmN+9qlxdRSgL5DtkiMAAHhNpOecmvO4/GWp28NxBHqV5HFcSrNNGs7BZJAch2AOGYHkE85qHUPE15q15Jd395Ne3cmN89zIzu2AAMsSScAAUgOs/tj/AGqP7Y/2q4r+0z60q6oW4B5oA/QjwA3meA/Db/3tNtj+cSVvVz/w/t5rPwH4btrmNoriLTbaOSNuGVhEgYH3BroK+Yl8TNwoooqRhRRRQAUUUUpbAFFFFUAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBzt58O/Cmo3Ulzd+GdGuriQlnmmsIXdmPUlipJNRf8Kt8F/wDQoaD/AOC2H/4munoquaXcVjmP+FW+C/8AoUNB/wDBbD/8TR/wq3wX/wBChoP/AILYf/ia6eijml3YWOY/4Vb4L/6FDQf/AAWw/wDxNH/CrfBf/QoaD/4LYf8A4munoo5pd2FjmP8AhVvgv/oUNB/8FsP/AMTR/wAKt8F/9ChoP/gth/8Aia6eijml3YWOY/4Vb4L/AOhQ0H/wWw//ABNH/CrfBf8A0KGg/wDgth/+Jrp6KOaXdhY5j/hVvgv/AKFDQf8AwWw//E0f8Kt8F/8AQoaD/wCC2H/4munoo5pd2FjmP+FW+C/+hQ0H/wAFsP8A8TUtn8O/CmnXUdzaeGdGtbiMhkmhsIUdWHQhgoINdFRRzS7hYKKKKkYUUUUAFFFFABRRRUy2A//Z');
            }

            spanTag.appendChild(imgTag);
            anchorTag.appendChild(spanTag );
            document.body.insertBefore(anchorTag, document.body.firstChild)
        }
    }
})();
jQuery(document).ready(function(){
    if (jQuery('html').hasClass('lt-ie8')) {
        cdc.ie.init();
    }
});
/**
 * _framework_touch.js
 * $Revision: 1.4 $
 *
 *   This script sets up touch functionality at framework level for general usage
 *
 *   (c) 1992-2013 Cisco Systems, Inc. All rights reserved.
 *   Terms and Conditions: http://cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
 *
 */

if (typeof cdc == "undefined") { cdc = {}; }
if (typeof cdc.framework == "undefined") { cdc.framework = {}; }

cdc.touch = (function() {
    // used as swipe directional identifier
    var left = 'toleft';
    var right = 'toright';
    var threshold = .3;
    var inTouch = false;  // continuous swiping
    var touchEvents = {};
    var objIEGesture = [];

    var clearTouch = function() {
        touchEvents = {};
    };

    //  MSGesture doesn't work wirh jQuery object - use the function below to get pure javascript object
    var setObj = function(obj) {
        var rootObj = undefined;
        if (obj instanceof jQuery) {
            //  assign a random Id to the element if there's none
            if (jQuery(obj).attr('id') == undefined || jQuery(obj).attr('id') == '') {
                var randId = 'touch-id-' + Math.floor((Math.random() * 10000) + 1);
                if (!document.getElementById(randId)) {
                    jQuery(obj).attr('id', randId);
                    rootObj = document.getElementById(randId);
                } else {
                    setObj(obj);
                }
            } else {
                rootObj = document.getElementById(jQuery(obj).attr('id'));
            }
        } else {
            rootObj = obj;
        }
        return rootObj;
    };

    var addSwipeHandler = function(obj) {
        // ie10+
        if (('onmsgesturechange' in window)) {
            objIEGesture['"' + obj.id + '"'] = new MSGesture();
            obj.addEventListener("MSGestureStart", function(evt) {
                clearTouch();
                inTouch = true;
                touchEvents.startX = evt.clientX;
                touchEvents.startY = evt.clientY;
                }, false);
            obj.addEventListener("MSGestureChange",  function(evt) {
                    evt.stopPropagation();
                }, false);
            obj.addEventListener("MSGestureEnd", function(evt) {
                inTouch = false;
                touchEvents.endX = evt.clientX;
                touchEvents.endY = evt.clientY;
                if (isOverThreshold()) {
                    obj.callback(getSwipeDirection());
                }
            }, false);
            obj.addEventListener("MSPointerDown", function(evt) {
                objIEGesture['"' + obj.id + '"'].addPointer(evt.pointerId)}, false);

            objIEGesture['"' + obj.id + '"'].target = obj;
        } else {
            jQuery(obj).on ("touchstart", function(event) {
               clearTouch();
               inTouch = true;
               touchEvents.startX = event.originalEvent.touches[0].pageX;
               touchEvents.startY = event.originalEvent.touches[0].pageY;
            });

            jQuery(obj).on ("touchend", function(event) {
                inTouch = false;
                touchEvents.endX = event.originalEvent.changedTouches[0].pageX;
                touchEvents.endY = event.originalEvent.changedTouches[0].pageY;
                if (isOverThreshold(obj)) {
                    obj.callback(getSwipeDirection());
                }
            });

            jQuery(obj).on ("touchmove", function(event) {
                if (Math.abs(event.originalEvent.changedTouches[0].pageY - touchEvents.startY) < Math.abs(event.originalEvent.changedTouches[0].pageX - touchEvents.startX)) {
                    event.preventDefault();     // this fixes Android device (swiping not advancing prev/next item)
                }
            });

            jQuery(obj).on ("touchcancel", function(event) {
                inTouch = false;
                touchEvents.cancel = true;
                obj.callback();
            });
        }
    };

    var getSwipeDirection = function() {
       return ((touchEvents.startX - touchEvents.endX) > 0 ? left : right);
    };

    var isOverThreshold = function(obj) {
        var rootWidth = jQuery(obj).width();
        var slideX = touchEvents.startX - touchEvents.endX;

        return (Math.abs(slideX/rootWidth) >= threshold );
    };

    return {
        left: left,
        right: right,

        swipe: function(obj, callbackFunc, swipeThreshold) {
            // touch capability not supported
            if (!Modernizr.touch) { return; }

            var newObj = setObj(obj);
            newObj.callback = callbackFunc;

            //  swipeThreshold is expected to be a decimal number between 0.0 and 1.0 - fraction of viewport's width
            if (arguments.length > 2) {
                threshold = arguments[2];
            }
            addSwipeHandler(newObj);
        },

        inTouch: function() {
            return inTouch;
        }
    };
})();

/**
 *  _skip.js
 *  $Revision: 1.2 $ - updated to work with Responsive Login - Alex Karaman
 *
 *  masterbrand skip links code
 */

(function () {
    if (jQuery('#booksearch').length==1) {
        jQuery('#skiplink-content').attr("href", "#booksearch");
    } else if(jQuery('#eot-doc-wrapper').length==1) {
        jQuery('#skiplink-content').attr("href", "#eot-doc-wrapper");
    }

    jQuery(document).on('focus blur', '#fw-skiplinks', function (ev) {
        if (ev.type==='focus'||ev.type==='focusin') {
            jQuery(this).addClass("show");
        }
        else if (ev.type==='blur'||ev.type==='focusout') {
            jQuery(this).removeClass("show");
        }
    });

})();

// Fix for Webkit (ios) skiplinks - thanks to https://gist.github.com/Zegnat/1900563
(function(a,b,c,d) {
    for (c in a) {
        if ((d = a[c].hash) && a[c].href == b + d && a[c].addEventListener) {
            a[c].addEventListener('click', function (e,f,g,h) {
                if (e=(f=document).getElementById(g = this.hash.slice(1)) || f.getElementsByName(g)[0]) {
                    if (h = !e.getAttribute(f='tabindex')) e.setAttribute(f,-1);
                    e.focus();
                    if (h) e.removeAttribute(f);
                }
            });
        }
    }
})(document.links,location.href.split('#')[0]);

/**
 * _masthead.js
 * $Revision: 1.3 $
 *
 *   masthead will cover logo, areanav, utility links, and mycisco link
 *
 */
if (window.cdc === undefined) { window.cdc = {}; }

cdc.util.ensureNamespace("cdc.masthead");

cdc.masthead = (function () {
    var isBannerReferrerProcessed = false,        //  ***  Mingle #8039  banner
        isTreenavReferrerProcessed = false;      //  ***  Mingle #8039  treenav

    var utilityWelcomeMsg = function () {
        if (cdc.util.authStatus === "valid") {
            cdc.userInfoDispatcher.getUserProfile({
                listOfDataFields: ["contactInfo"],
                callback: function (data) {
                    // data is a JavaScript object containing the fields as requested
                    var welcomeMsg = "",
                        selector;

                    if (data.contactInfo !== null && !jQuery.isEmptyObject(data.contactInfo)) {
                        if (data.contactInfo.givenname !== null && data.contactInfo.givenname) { welcomeMsg = data.contactInfo.givenname; }
                        if (data.contactInfo.sn !== null && data.contactInfo.sn) { welcomeMsg = welcomeMsg + " " + data.contactInfo.sn; }
                    }

                    if (welcomeMsg) {
                        //Target homepage header tag and include welcome message else include on framework pages
                        if (jQuery("header#fw-masthead")[0]) {
                            selector = "#fw-utility #actions li.fw-welcome";
                        } else {
                            selector = ".ft-toolbar span.ft-cq-welcome";
                        }
                        jQuery(selector).append(" " + welcomeMsg);
                    }
                }
            });
        }
    };

    var addListeners = function () {
        if (jQuery('body').hasClass('fw-res')) {
            jQuery(document).on("click", "#fw-utility #language a", function () {
                cdc.util.openCdcPopup(jQuery(this).attr("href"), 730, 620);
                return false;
            }).ready(function () {
                //  ***  Mingle #8039
                // initial load and no-touch handled here.  touch is handdled in _treenav.js (in addButtonListener function) only when treenav.json is brought on to the page
                if (jQuery('html').hasClass('no-touch')) { cdc.masthead.handleReferrer(''); }
            });
        }
	    $( document ).ready(function() {
        	cdc.sso.addReadyListener(utilityWelcomeMsg);
        });
    };

    // *** mingle #8222 - give acct/register links env specific sub-domains
    var currentEnv = cdc.util.findEnvironment();
    var _envSpecifier = function (currentlink, subdom) {
        var subdom_new;

        if (currentEnv === "dev" || currentEnv === "stage") {
            subdom_new = cdc.util.getEnvSubdomain('wp', subdom, false);
            currentlink = currentlink.replace('//' + subdom, '//' + subdom_new);
        }

        return currentlink;
    };

    var _addReferrerUrl = function (prefix) {  //  prefix can be null/empty string (banner) or 'tn-' (for treenav)
        var currentUrl = window.location.href;
        var accountObj = jQuery('#' + prefix + 'actions.guest-actions a[href*="/account/"]');
        var oldRegSvc = jQuery('#actions.guest-actions a[href*="register"]');
        var registerObj = (oldRegSvc.length !== 0) ? oldRegSvc : jQuery('#' + prefix + 'actions.guest-actions a[href*="Registration"]');
        var accountLink = accountObj.attr('href');
        var registerLink = registerObj.attr('href');

        if (accountLink && accountLink.indexOf('referer') === -1) {    //  avoid compounding referrer
            accountLink = _envSpecifier(accountLink, 'www');
            accountObj.attr('href', accountLink + '?referer=' + currentUrl);
        }

        if (registerLink && registerLink.indexOf('referer') === -1) {
            registerLink = _envSpecifier(registerLink, 'idreg');
            var queryPrefix = (registerLink.indexOf('?') === -1) ? '?' : '&';    //  check for existing query
            registerObj.attr('href', registerLink + queryPrefix + 'referer=' + currentUrl);
        }

        if (prefix === 'tn-') {
            isTreenavReferrerProcessed = true;
        } else {
            isBannerReferrerProcessed = true;
        }
    };

    //  ***  Mingle #8039
    var _handleReferrer = function (prefix) {
        if (prefix === 'tn-' && !isTreenavReferrerProcessed) {    //  called from treenav
            _addReferrerUrl(prefix);
        } else if (!isBannerReferrerProcessed) {                    // call from no-touch
            _addReferrerUrl('');
        }
    };

    return {
        init: function () {
            addListeners();
        },
        //  ***  Mingle #8039
        handleReferrer: _handleReferrer
    };
}());

cdc.masthead.init();

/**
 * Copyright (C) 2013 Cisco
 * $Revision: 1.6 $
 * _treenav.js
 */

if (window.cdc === undefined) { cdc = {}; }

cdc.treenav = (function () {
    var slideTime = 300;

    var treenavBuilderCallback = function (treenavBuildSuccessful) {
        if (treenavBuildSuccessful) {
            cdc.treenav.animation.init(slideTime);
        } else {
            cdc.treenav.animation.initJSONFail(slideTime);
        }
    };

    return {
        init: function () {
            jQuery('#fw-overlay').on('click', function () {
                if (jQuery(this).hasClass('active')) {
                    jQuery('#fw-treenavbutton').click();
                }
            });

            if (jQuery('body').hasClass('cec-login')) { return; }
            if (jQuery('html').hasClass('lt-ie9')) { return; }

            if (jQuery('body').hasClass('cdc-login')) {
                cdc.treenav.animation.initJSONFail(slideTime);
            } else {
                cdc.treenav.builder.buildTreeNav(treenavBuilderCallback);
            }
        }
    };
}());

/**
 * _treenavanimation.js
 */
if (cdc.treenav === undefined) { cdc.treenav = {}; }

cdc.treenav.animation = (function () {
    var jsonFail = false,
        animationTime = 300,
        utilityIds = ['actions', 'mycisco', 'language', 'lang-options'],
        overlay = jQuery('#fw-overlay'),
        treenav,
        treenavPrimary,
        treenavSecondaryId = 'treenav-secondary',
        secondaryMenu,
        firstGroupButton,
        direction = jQuery('html').attr('dir') === 'rtl' ? 'right' : 'left',
        animatePrimary = {
            duration: animationTime,
            easing: 'linear',
            queue: false
        },
        animateSecondaryClose = JSON.parse(JSON.stringify(animatePrimary)),
        animateDirection = {};

    animateDirection[direction] = 0;

    var secondaryCleanup = function () {
        jQuery('#' + treenavSecondaryId).remove();
    };

    animateSecondaryClose.complete = secondaryCleanup;

    /**
    * Adds a listener to the treenavbutton, to toggle the open state of the treenav.
    **/
    var addButtonListener = function () {
        jQuery('#fw-treenavbutton').on('click', function () {
            if (treenav === undefined) {
                if (!jsonFail) {
                    treenav = jQuery('#fw-treenav');
                    treenavPrimary = jQuery('#treenav-primary');
                    firstGroupButton = jQuery(treenavPrimary).find('.treenav-in:eq(0)');
                    insertUtilityFragments();
                    addTreenavListeners();
                } else {
                    buildJsonFailTreenav();
                    treenav = jQuery('#fw-treenav');
                }
            }

            if (jQuery(this).hasClass('active')) {
                jQuery('.cecFinderNavigation').show();
            } else {
                jQuery('.cecFinderNavigation').hide();
            }

            toggleTreenav(this);
            //  ***  Mingle #8039 - add referrer url to Account and Register links
            cdc.masthead.handleReferrer('tn-');
        });

        var treenavType = jQuery('#fw-treenavbutton').attr('data-treenav');
        if (treenavType !== undefined && treenavType.indexOf('employee') !== -1) {
            cdc.util.inNetworkTest();
        }
    };

    /**
    * Goes through the process of cloning fw-banner menu setup and re-constructs
    * it into a treenav.
    **/
    var buildJsonFailTreenav = function () {
        var jsonFailTreenav = jQuery("<nav id='fw-treenav' class='overthrow'></nav>");
        var areanav = jQuery(jQuery("#fw-areanav ul")[0]).clone();

        jQuery(areanav).attr('id', 'treenav-primary');
        jQuery(areanav).find('.mm-reflink').remove();
        jQuery(areanav).find('.mm-menu').remove();

        jQuery(jsonFailTreenav).append(areanav);
        jQuery('#fw-banner').append(jsonFailTreenav);

        insertUtilityFragments();
    };

    var moveUtilityLink = function (element) {
        jQuery('#tn-language').append(element.detach());
    };

    var modifyUtilityLinks = function () {
        var languageOptions = jQuery('#tn-lang-options li'),
            locator = jQuery('#tn-language li:first-child a'),
            myCisco = jQuery('#fw-treenav #tn-mycisco'),
            aboutCisco = jQuery('#fw-treenav li.fw-about-cisco-util'),
            localOffices = jQuery('#fw-treenav li.fw-local-offices-util');

        // if there are language options, move them so that they are a nested list of the locator link
        if (languageOptions.length > 0) {
            locator.parent().append('<ul id="tn-languages"></ul>');
            languageOptions.each(function () {
                jQuery('#tn-language #tn-languages').append(jQuery(this).clone());
            });
            languageOptions.parent().detach();
        }

        // if myCisco, aboutCisco, or localOffices utility links exist, move them so that they are a child of the tn-language list
        if (myCisco.length > 0 || aboutCisco.length > 0 || localOffices.length > 0) {
            if (aboutCisco.length > 0) { moveUtilityLink(aboutCisco); }
            if (localOffices.length > 0) { moveUtilityLink(localOffices); }
            if (myCisco.length > 0) {
                moveUtilityLink(myCisco);
                myCisco.replaceWith('<li id="tn-mycisco">' + myCisco.html() + '</li>');
            }
        }
    };

    /**
    * Creates a copy of the masthead utility links to use in the treenav.
    **/
    var insertUtilityFragments = function () {
        var i;
        for (i = 0; i < utilityIds.length; i++) {
            jQuery('#tn-util').append(jQuery('#' + utilityIds[i]).clone().attr("id", "tn-" + utilityIds[i]));
        }
        modifyUtilityLinks();
    };

    /**
    * These listeners are only added if the treenav is open.
    **/
    var addTreenavListeners = function () {
        jQuery(treenav).on('click', '.treenav-in', function (event) {
            // block the sub menu if link has disabled class (the employee link when not behind firewall)
            if (jQuery(event.target).is('.disabled')) { return false; }

            if (atLeastSmallViewport()) {
                var listElements = jQuery(treenav).closest('ul').find('ul');
                jQuery(listElements).removeClass('active');
            }

            highlightSelectedButton(this);
            secondaryHandler(this);
        });
    };

    var atLeastSmallViewport = function () {
        return (jQuery.inArray(cdc.breakpoint.getScreenSize(), ['short','xsmall']) === -1);
    };

    /**
    * Responsible for identifying if the TreeNav is to be open or closed.
    * Executes all actions that are needed to open or close the TreeNav completely.
    **/
    var toggleTreenav = function () {
        if (jQuery(treenav).hasClass('open')) {
            jQuery('#' + treenavSecondaryId).remove();
            jQuery('#treenav-back').remove();
            jQuery(treenavPrimary).removeAttr('style');
            resetSelectedButton();

            jQuery('#fw-treenavbutton').removeClass('active');
            treenav.removeClass('open');
            overlay.removeClass('open');
            jQuery('body').removeClass('body-treenav-open');
        } else {
            jQuery('#fw-treenavbutton').addClass('active');
            treenav.addClass('open');
            overlay.addClass('open');
            jQuery('body').addClass('body-treenav-open');

            if (atLeastSmallViewport() && !jsonFail) {
                openFirstSecondary();
            }

            // if treenav is being opened and search is visible, we want to hide search
            if (jQuery('#fw-search').hasClass('visible')) {
                cdc.search.toggleSearch();
                jQuery('#searchPhrase').val('');
            }

            // if treenav is being opened and web component search is visible, we want to toggle search visibility
            if (jQuery('#fw-masthead').hasClass('cdc-webcomponent') && jQuery('#fw-searchbutton').hasClass('active')) {
                document.querySelector('cdc-search').toggleSearchVisibility();
            }
        }
    };

    var highlightSelectedButton = function (button) {
        if (atLeastSmallViewport) {
            resetSelectedButton();
            // set the selected button with highlight
            jQuery(button).addClass('active');
        }
    };

    var resetSelectedButton = function () {
        // a reset on any button that might have been highlighted
        jQuery('.treenav-in').removeClass('active');
    };

    var secondaryHandler = function (selectedElement) {
        secondaryMenu = jQuery(selectedElement).siblings('ul')[0].children;

        if (secondaryMenu !== undefined && secondaryMenu != '') {
            //a clone is created to help with removal of the secondary treenav
            secondaryMenu = jQuery(secondaryMenu).clone(true);

            var setupSecondary = function () {
                secondaryCleanup();

                jQuery(treenavPrimary).after('<div id="' + treenavSecondaryId + '"><ul class="tn-nav"></ul></div>');

                addBackButton(jQuery(selectedElement).text());
                jQuery('#' + treenavSecondaryId + ' .tn-nav').append(secondaryMenu);

                openSecondary(selectedElement);
            };

            if (jQuery('#' + treenavSecondaryId).length > 0) {
                closeSecondary(setupSecondary);
                } else {
                setupSecondary();
                }
            }
    };

    var setSecondaryHeight = function (selectedElement) {
        var selectedOffset = jQuery(selectedElement).offset().top,
            secondaryHeight = jQuery('#' + treenavSecondaryId + ' .tn-nav').height(),
            height;

        if (selectedOffset > secondaryHeight) {
            height = (selectedOffset - jQuery('#fw-masthead').height()) + jQuery(selectedElement).outerHeight();
            jQuery('#' + treenavSecondaryId + ' .tn-nav').height(height);
        }
    };

    var openSecondary = function (selectedElement) {
        if (atLeastSmallViewport()) {
            setSecondaryHeight(selectedElement);
        } else {
            animateDirection[direction] = '-100%';
            jQuery(treenavPrimary).animate(animateDirection, animatePrimary);
            animateDirection[direction] = 0;
            jQuery('#' + treenavSecondaryId).animate(animateDirection, animatePrimary);
        }
    };

    /**
    * The only way to get here is if the openSecondary functions has been called.
    **/
    var closeSecondary = function (callback) {
        if (atLeastSmallViewport() && typeof callback === "function") {
            callback();
            } else {
            animateDirection[direction] = 0;
            jQuery(treenavPrimary).animate(animateDirection, animatePrimary);
            animateDirection[direction] = '100%';

            if (typeof callback === "function") {
                animateSecondaryClose.complete = callback;
            }

            jQuery('#' + treenavSecondaryId).animate(animateDirection, animateSecondaryClose);

            // reset complete object property
            animateSecondaryClose.complete = secondaryCleanup;
        }
    };

    /**
    * Use to open the first secondary treenav when in two panel view.
    **/
    var openFirstSecondary = function () {
        secondaryHandler(firstGroupButton);
        highlightSelectedButton(firstGroupButton);
    };

    /**
    * Adds a bottom to the DOM above the secondary menu, which allows users to navigate to
    * the primary menu.
    **/
    var addBackButton = function (menuName) {
        if (jQuery('#treenav-back').length <= 0) {
            jQuery('#' + treenavSecondaryId + ' .tn-nav').before('<div id="treenav-back"><button><span></span></button><span>' + menuName + '</span></div>');
            jQuery('#treenav-back').on('click', function (event) {
                closeSecondary();
            });
        }
    };

    if (!jsonFail) {
        var breakpointHandlerSmall = function () {
            if (jQuery(treenav).hasClass('open') && jQuery('#' + treenavSecondaryId).length === 0) {
                openFirstSecondary();
            } else if (jQuery(treenav).hasClass('open')) {
                jQuery('#' + treenavSecondaryId).removeAttr('style');
                jQuery(treenavPrimary).removeAttr('style');
            }
        };
        var breakpointHandlerSmallExit = function () {
            if (jQuery('#' + treenavSecondaryId).length > 0) {
                jQuery(treenavPrimary).css('left', '-100%');
                jQuery('#' + treenavSecondaryId).css('left', 0);
            }
        };
        cdc.breakpoint.onEnter(breakpointHandlerSmall, cdc.breakpoint.breakpoints.tall);
        cdc.breakpoint.onExit(breakpointHandlerSmallExit, cdc.breakpoint.breakpoints.tall);
    }
    var breakpointHandler = function () {
        if (jQuery('html').hasClass('no-touch')) {
            jQuery(overlay).hide();
            jQuery('body').removeClass('body-treenav-open');
        }
    };
    var breakpointHandlerExit = function () {
        jQuery(overlay).removeAttr('style');
        if (jQuery(treenav).hasClass('open') && !(jQuery(treenav).hasClass('open'))) {
            jQuery('body').addClass('body-treenav-open');
        }
    };
    cdc.breakpoint.onEnter(breakpointHandler, cdc.breakpoint.breakpoints.large);
    cdc.breakpoint.onExit(breakpointHandlerExit, cdc.breakpoint.breakpoints.large);

    return {
        init: function (slideTime) {
            animationTime = slideTime;
            addButtonListener();
        },

        initJSONFail: function (slideTime) {
            animationTime = slideTime;
            jsonFail = true;
            addButtonListener();
        },
        toggleTreenav: toggleTreenav
    };
}());

/**
 * _treenavbuilder.js
 */
if (cdc.treenav === undefined) { cdc.treenav = {}; }

cdc.treenav.builder = (function () {
    var htmlString = "",
        treeNavContainer,
        treenavCallback,
        lockedClass = 'locked',
        dividerClass = 'divider',
        mUrlVersions = ['mUrl', 'murl', 'mURL', 'mURl', 'MURL'],
        urlArray = [];

    var isRelativeUrl = function (url) {
        return (url.indexOf("//") < 0);
    };

    /** Retrieves the treenavjson.js file. **/
    var getTreeNavJSON = function (ajaxUrl) {
        var subdomain = window.location.host.split('.')[0],
            subdomains = cdc.includer.domainConfig.subdomains,
            urlParam = decodeURI((RegExp('treenavUrl=(.+?)(&|$)').exec(location.search)||[null,null])[1]);

        // add wwwin and www to list of subdomains for simiplied logic in if statement
        subdomains.push("wwwin");
        subdomains.push("www");

        // if current subdomain matches one of the defined accepted subdomains and the url is relative, get the json file from production
        // otherwise, add the appropraite host to the ajaxUrl if urlParam is not null
        if (subdomains.some(function (val) { return subdomain.match(RegExp('^' + val + '$', "i")); }) === true && isRelativeUrl(ajaxUrl)) {
            ajaxUrl = "//www.cisco.com" + ajaxUrl;
        } else if (urlParam !== "null") {
            if (urlParam.charAt(urlParam.length - 1) === "/") {urlParam = urlParam.substring(0, urlParam.length - 1);}
            if (isRelativeUrl(urlParam)) {urlParam = "//" + urlParam;}
            ajaxUrl = urlParam + ajaxUrl;
        }

        jQuery.ajax({
            type: 'GET',
            url: ajaxUrl,
            dataType: 'json',
            success: function (data) {
                manageTreeNavConstruction(data);
            },
            error: function () {
                treenavCallback(false);
            }
        });
    };

    /** Gets the json data and starts the build of the TreeNav **/
    var manageTreeNavConstruction = function (treeNavJSON) {
        try {
            var treeNavLayoutJSON;
            var treeNavItemsJSON;

            if (treeNavJSON === "") {
                throw {name: "TreeNavJson", message: "TreeNavJson file is empty"};
            } else {
                treeNavLayoutJSON = treeNavJSON.treeNavLayout;
                treeNavItemsJSON = treeNavJSON.navItems;
            }

            constructTreeNavHtml(treeNavLayoutJSON, treeNavItemsJSON);
            jQuery(treeNavContainer).append(htmlString);
            treenavCallback(true);
        } catch (er) {
            console.error(er.name + " " + er.message);
            treenavCallback(false);
        }
    };

    var constructTreeNavHtml = function (treeNavLayoutJSON, treeNavItemsJSON) {
        htmlString += '<nav id="fw-treenav" class="overthrow"><div id="treenav-primary"><div id="tn-util"></div><ul class="tn-nav">';

        var menuItems = [];
        createSectionArray(menuItems, treeNavLayoutJSON.treeNavMenuItems, treeNavItemsJSON);
        constructHtml(menuItems, false);

        htmlString += "</ul></nav>";
    };

    var createSectionArray = function (sectionArray, idArray, treeNavItemsJSON) {
        idArray.forEach(function (uniqueID) {
            var result = jQuery.grep(treeNavItemsJSON, function (e) { return e.uniqueID === uniqueID; });
            if (result.length > 0) { sectionArray.push(result[0]); }
        });
    };

    var constructHtml = function (sectionArray, startNewList) {
        var liClasses = "",
            url = "";

        if (startNewList) { htmlString += '<ul>'; }

        sectionArray.forEach(function (navItem) {
            //If - the nav item is a button for a submenu -- <button>
            //else if - the nav item is purely a heading -- <div>
            //else - the nav item is a link -- <a>

            if (navItem.navItems !== undefined && navItem.navItems.length > 0) {
                if (navItem.uniqueID.toLowerCase() == "employees") {
                    htmlString += '<li><button class="treenav-in employees disabled" title="Open Submenu" value="Open Submenu">' + navItem.navText + '</button>';
                } else {
                    htmlString += '<li><button class="treenav-in" title="Open Submenu" value="Open Submenu">' + navItem.navText + '<span></span></button>';
                }

                constructHtml(navItem.navItems, true);

            } else if (navItem.navUrl === undefined && navItem.mUrl === undefined || (navItem.navUrl == '' && navItem == '')) {
                htmlString += '<li><div>' + navItem.navText + '</div>';
            } else {
                liClasses = "";
                url = "";

                if (navItem.divider == "true") { liClasses += ' ' + dividerClass; }
                liClasses = liClasses != '' ? 'class="' + liClasses + '"' : liClasses;

                htmlString += '<li ' + liClasses  + '>';
                htmlString += '<span>';

                if (navItem.navUrl !== undefined && navItem.navUrl != '') {
                    url = navItem.navUrl;
                } else if (navItem.mUrl !== undefined && navItem.mUrl != '') {
                    url = navItem.mUrl;
                    }
                htmlString += '<a href="' + url + '">' + navItem.navText;

                if (navItem.locked == "true") { htmlString += '<span class="locked"></span>'; }

                    htmlString += '</a>';
                htmlString += '</span>';
            }
            htmlString += '</li>';
        });

        if (startNewList) {
            htmlString += '</ul>';
        }
    };

    return {
        // Since other event listeners are added to the built treenav, we need to pass a callback
        // that the treenavBuilder can use to inform other scripts whether the treenav was built successfully.
        buildTreeNav: function (callback) {
            treeNavContainer = jQuery('#fw-banner');
            treenavCallback = callback;

            var entitlement = (jQuery('#fw-treenavbutton')) ? jQuery('#fw-treenavbutton').attr('data-treenav') : '';    // treenav version set by megaMenu.jsp
            getTreeNavJSON(entitlement);
        }
    };
}());

/**
* Start the treenav processing.
**/
cdc.treenav.largeBreakpointExit = function () {
    if (jQuery("#fw-treenav").length === 0) {
        cdc.treenav.init();
    }
};
cdc.treenav.largeBreakpointEnter = function () {
    if (jQuery("#fw-treenav").length === 0 && jQuery('html').hasClass('touch')) {
        cdc.treenav.init();
    }
};

var largeExitPosition = cdc.breakpoint.onExit(cdc.treenav.largeBreakpointExit, cdc.breakpoint.breakpoints.large);
var largeEnterPosition = cdc.breakpoint.onEnter(cdc.treenav.largeBreakpointEnter, cdc.breakpoint.breakpoints.large);

// for enabling or hiding the employee link in treenav when the employee in-network ajax call returns successfully
cdc.treenav.showEmpTreenav = function (data) {
    if (data === true) {
        //add confidential ribbon later
        jQuery('button.employees').removeClass("disabled").html(cdc.emp.employees + "<span></span>");
    } else if (data === false) {
        jQuery('button.employees').hide();
    }
};

// for reinforcing the disabled employee link in treenav when the employee in-network ajax call times out or throws an error
cdc.treenav.notInNetwork = function () {
    jQuery('button.employees').addClass("disabled").html(cdc.emp.employees + " (" + cdc.emp.accessRequired + ")");
};

/**
 *  masterbrand search links code
 *  _search.js
 *  $Revision: 1.5 $
 */

if (window.cdc === undefined) { cdc = {}; }

cdc.search = (function () {
    var masthead = jQuery("#fw-masthead"),
        searchButton = jQuery('#fw-searchbutton'),
        searchForm = jQuery('#fw-search'),
        searchPhrase = jQuery('#search-phrase'),
        siteWideSearch = jQuery('#sitewidesearch'),
        autoSuggest = jQuery('input[name=autosuggest]'),
        typeAhead;

    // functionality for search button
    var searchPhraseHandler = function (event) {
        event.stopPropagation();
        event.preventDefault();

        if (event.type === "click" && jQuery(searchPhrase).val().length > 0) {
            siteWideSearch.submit();
        } else {
            switch (event.type) {
                case "focus":
                break;
                default:
                    if (!siteWideSearch.hasClass('active')) { searchPhrase.focus(); }
                    toggleSearch();
                break;
            }
        }
    };

    var addListeners = function () {
        if (jQuery('#fw-masthead').hasClass('cdc-webcomponent')) {
            jQuery('cdc-search').on('is-search-open-changed', function () {
                jQuery('#fw-searchbutton, #fw-masthead-overlay-arrow').toggleClass('active');

                if (jQuery('#fw-searchbutton').hasClass('active') && jQuery('#fw-treenav').hasClass('open')) { cdc.treenav.animation.toggleTreenav(); }
            });

            // 'focusin' was specifically needed for IE11. Other listeners types were failing to register the search button 'focus' [US118332].
            // a 'click' also registers as a 'focusin' so we need to make sure to fire only one
            // and we still need 'click', because 'focusin' doesn't fire if the search button is already focused
            var inMotion = false;
            jQuery('#fw-searchbutton').on('focusin click', function (event) {
                var search = document.querySelector('cdc-search');

                // if toggleSearchVisibility is defined, hook into event handler
                // otherwise, direct user to search results page
                if (typeof search.toggleSearchVisibility === 'function') {
                    if (event.type === 'focusin') {
                        search.toggleSearchVisibility(search);
                        inMotion = true;
                        setTimeout(function () { inMotion = false; }, 200);
                    }
                    if (event.type === 'click' && inMotion === false) {
                        search.toggleSearchVisibility(search);
                    }
                } else {
                    window.location = cdc.search.typeAhead.searchHostEnv();
                }
            });

        } else {
            jQuery('#fw-searchbutton, #fw-search-button').click(function (event) {
                searchPhraseHandler(event);
            });

            jQuery(searchPhrase).on('focus', function (event) {
                jQuery('input[name=autosuggest]').attr('value','false'); // metrics
                searchPhraseHandler(event);
                cdc.util.checkClear(this);
            });

            jQuery(window).on('resize orientationchange', cdc.search.typeAhead.show);
        }
    };

    /**
     * No typeahead if:
     *   - cdc.search.noTypeAhead is 'true'
     *   - page is from newsroom or investor
     *   - page body tag does not have an id of 'libra'
     */
    var setupTypeAhead = function () {
        // no typeahead if cdc.search.noTypeAhead is 'true'
        if (cdc.search.noTypeAhead) { return; }

        // no typeahead in newsroom and investor
        var host = window.location.hostname.toLowerCase();
        if (host.indexOf("newsroom.cisco.com") >= 0 || host.indexOf("investor.cisco.com") >= 0) { return; }

        if (document.getElementById("search-phrase")) {
            document.getElementById("search-phrase").onblur = cdc.search.hideTypeAhead;
        }

        // set query uri env for autosuggest json calls
        var turl = cdc.search.typeAhead.searchHostEnv() + "/services/hint?";

        cdc.search.setTypeAhead();
        typeAhead.initialize(turl, "sitewidesearch", "auto-suggest", "search-phrase", "search-drop-down");
        document.getElementById('search-drop-down').classList.add("ready");
    };

    var toggleSearch = function () {
        if (!searchForm.hasClass('visible') && jQuery('#fw-treenav').hasClass('open')) { cdc.treenav.animation.toggleTreenav(); }
        if (!siteWideSearch.hasClass('active')) {
            siteWideSearch.addClass('active');
            searchForm.addClass('visible');
            searchButton.addClass('active');
            searchPhrase.focus();
        } else {
            siteWideSearch.removeClass('active');
            searchForm.removeClass('visible');
            searchButton.removeClass('active');
        }
    };

    return {
        init: function () {
            // if IE10 or less, web component doesnt load so show old search
            var ua = window.navigator.userAgent;
            if (ua.indexOf('MSIE') != -1) { jQuery('#fw-masthead').removeClass('cdc-webcomponent'); }

            addListeners();

            // set search server for current environment
            if (cdc.util.findEnvironment() !== "prod") {
                if (window.location.href.indexOf('fdk-pstage') !== -1) {
                    cdc.search.typeAhead.searchHostEnv("https://search-prf.cloudapps.cisco.com");
                } else {
                    cdc.search.typeAhead.searchHostEnv("https://searchx.cisco.com");
                }
            }

            // set form action for current environment
            jQuery('#sitewidesearch').attr("action", cdc.search.typeAhead.searchHostEnv() + "/search");
        },
        setupTypeAhead: setupTypeAhead,
        setTypeAhead: function () {
            typeAhead = cdc.search.typeAhead;
        },
        toggleSearch: toggleSearch,
        mouseOver: function (index) {
            typeAhead.mouseOver(index);
        },
        mouseOut: function (index) {
            typeAhead.mouseOut(index);
        },
        mouseClick: function (index) {
            typeAhead.mouseClick(index);
        },
        toggleSearch: toggleSearch,
        jsonp: function (url, name, query) {
            if (url.indexOf("?") > -1) {
                url += "&callback=";
            } else {
                url += "?callback=";
            }
            url += name + "&";
            if (query) { url += encodeURIComponent(query) + "&"; }
            url += new Date().getTime().toString(); // prevent caching
            var script = document.createElement("script");
            script.setAttribute("src", url);
            script.setAttribute("type", "text/javascript");
            document.body.appendChild(script);
        }
    };
}());

cdc.search.typeAhead = (function () {
    // Private variables
    var __typeAheadUrl = false;                         // The url to fetch suggestions from
    var __form = false;                                 // The form
    var __query = false;                                // The query input field
    var __queryId = false;                              // The id of the query input field
    var __tooltip = false;                              // The tooltip div
    var __container = false;                            // The container div
    var __timeout = false;                              // The current timeout
    var __prev = "";                                    // The previously sent term
    var __original = "";                                // The term before panning into the suggestions
    var __index = -1;                                   // The index of the text cursor in the list of suggestions
    var __mouseIndex = -1;                              // The position of the mouse in the list of suggestions
    var __terms = [];                                   // The list of suggestions
    var __cache = [];                                   // A result-cache
    var __enabled = false;
    var __deletePressed = false;                        // Delete or backspace has been pressed
    var __section = "";                                 // Site section
    var __self = false;

    // Public Variables
    var searchHostEnv = "https://search.cisco.com";     // The default search server
    var mousein = false;
    var useInlineSuggestion = false;                    // Whether or not to display the first suggestion as marked text within the search-box
    var clearInlineSuggestionBeforeSubmit = false;      // Whether or not to remove inline suggestions before submitting

    /**
     * Initialize
     */
    var initialize = function (typeAheadUrl, formId, tooltipId, queryId, containerID) {
        __enabled = true; // was test for XmlHttpRequest()
        if (__enabled) {
            __typeAheadUrl = typeAheadUrl;
            __form = document.sitewidesearch;

            // add locale from hidden form element to url parameter
            __typeAheadUrl += "locale=" + __form.locale.value + "&";

            if (!__form) {
                __enabled = false;
            } else {
                __tooltip = byId(tooltipId);
                __container = byId(containerID);
                __queryId = queryId;
                __query = byId(queryId);
                if (__query) {
                    __self = cdc.search.typeAhead;
                    __query.onkeyup = function (e) {
                        if (e !== undefined) { event = e; }
                        __self.keyUp(event, queryId);
                    };
                    __query.onkeydown = function (e) {
                        if (e !== undefined) { event = e; }
                        __self.keyDown(event, queryId);
                    };
                    mousein = false;
                    __container.onmouseover = function () {
                        mousein = true;
                    };
                    __container.onmouseout = function () {
                        mousein = false;
                        __query.focus();
                    };
                    __query.onblur = function () {
                        if (mousein === false) {
                            __self.hide();
                        }
                    };
                }
            }
        }
    };

    /**
     * Set the id of the input-field to do completion for. Not really neccessary to call, as
     * the id is sent to the key handling methods.
     *
     * @param queryId the id of the search box
     */
    var setQueryId = function (queryId) {
        __queryId = queryId;
        __query = byId(queryId);
    };

    /**
     * Called when the search form should be submitted (usually because of mouse clik on one
     * of the suggestions in the list). By default submits the form specified by the formId
     * parameter of the initialize() function. Override for different behavior.
     */
    var submitForm = function () {
        jQuery('input[name=autosuggest]').attr('value','true'); // metrics
        if (__form.submit !== undefined) {
            __form.submit();
        } else {
            // fallback: serialize the form parameters via jQuery and append the new value, then redirect.
            var newQuery = jQuery("#" + __form.id).attr("action") + "?" + jQuery("#" + __form.id).serialize() + "&autosuggest=true";
            window.location = newQuery;
        }
    };

    // Input event handlers

    /**
     * Event handler for key up events.
     */
    var keyUp = function (event, field) {
        if (!__enabled) return;
        else if (field != __queryId) setQueryId(field);
        if (event) {
            if (__timeout) {
                clearTimeout(__timeout);
                __timeout = false;
            }
            if (event.ctrlKey || event.altKey) {
                return;
            }
            var timeout = 100;
            __deletePressed = false;
            switch (event.keyCode) {
                case 9 : // Tab
                case 27 : // Escape
                    hide();
                    return;
                case 8 : // Backspace
                case 46 : // Delete
                    __deletePressed = true;
                    timeout = 200;
                    break;
                case 13 : // Enter
                case 16 : // Shift
                case 17 : // Ctrl
                case 18 : // Alt
                case 20 : // Caps Lock
                case 33 : // Page up
                case 34 : // Page down
                case 35 : // End
                case 36 : // Home
                case 37 : // Arrow left
                case 38 : // Arrow up
                case 39 : // Arrow right
                case 40 : // Arrow down
                case 45 : // Insert
                    return;
                default :
                    timeout = 100;
                    break;
            }
            __index = -1;
            __timeout = setTimeout(function () { __self.fetchResults(); }, timeout);
        }
    };

    /**
     * Some keys also require keyDown handlers, because they never give a key up event. For
     * instance, pressing the 'tab' key will typically cause focus to leave the search input
     * box, causing the key up event to be sent to another component.
     */
    var keyDown = function(event, field) {
        if (!__enabled) return;
        else if (field != __queryId) setQueryId(field);
        if (event && event.keyCode) {
            switch (event.keyCode) {
                case 9 : // Tab
                    hide();
                    break;
                case 13 : // Enter
                    if (__index == -1) {
                        clearInlineSuggestion();
                    } else {
                        __query.value = __terms[__index];
                        submitForm();
                        return false;
                    }
                    break;
                case 38 : // Up-arrow
                    if (__index >= 0) updateResults(__index--, -2);
                    break;
                case 40 : // Down-arrow
                    if (__index < __terms.length - 1) updateResults(__index++, -2);
                    break;
            }
        }
    };

    var mouseOver = function (index) {
        if (!__enabled) return;
        var previous = __mouseIndex >= 0 ? __mouseIndex : __index;
        __mouseIndex = index;
        updateResults(-2, previous);
    };

    var mouseOut = function (index) {
        if (!__enabled) return;
        var previous = __mouseIndex;
        __mouseIndex = -1;
        updateResults(-2, previous);
    };

    var mouseClick = function (index) {
        if (!__enabled) return;
        if (index >= 0) {
            __query.value = __terms[index];
            submitForm();
        } else {
            hide();
        }
    };

    // Functions for retrieving suggestions

    var fetchResults = function () {
        var val = __query.value;
        if (canHandleRanges()) { val = val.substring(0, getCaretPosition()); }
        if (val.length === 0) {
            hide();
            __tooltip.innerHTML = "";
            __terms = [];
            __prev = val;
            return;
        } else {
            val = val.replace(new RegExp("\\\\", "g"), "\\\\");
        }

        __prev = val;
        if (__cache[val]) {
            displayResults(__cache[val], __prev);
        } else {
            // only fetch if 3+ characters input
            if (val.length > 2) {
                ta = cdc.search.typeAhead;
                cdc.search.jsonp(__typeAheadUrl + "count=" + 10 + "&query=" + encodeURI(val), "ta.displayResults", "");
            }
        }
    };

    var displayResults = function (matches) {
        if (matches === "") { return; }
        if (__tooltip && __query) {
            var text = "",
                match,
                regex = new RegExp("(" + __query.value + ")", "gi");

            __terms = new Array(matches.length);
            var index = 1, lastFiveClass = "";
            for (var i in matches) {
                if (matches.hasOwnProperty(i)) {
                    // markup the list items to be hidden in smaller sizes
                    if (index === 6) {
                        lastFiveClass = " data-last-items=\"lastItems\"";
                    }
                    match = matches[i].value;
                    __terms[i] = match;

                    text += "<div" + lastFiveClass + " id=\"tooltip_" + i + "\" onmouseover=\"cdc.search.mouseOver(" + i + ")\" onmouseout=\"cdc.search.mouseOut(" + i + ")\" onclick=\"cdc.search.mouseClick(" + i + ")\">" + match.replace(regex, "<span>$1</span>") + "</div>\n";

                    index++;
                }
            }
            __tooltip.innerHTML = text;

            show();
        }
    };

    var updateResults = function (previousIndex, previousMouseIndex) {
        var previous = byId("tooltip_" + previousIndex);
        var previousMouse = byId("tooltip_" + previousMouseIndex);
        var current = byId("tooltip_" + __index);
        var currentMouse = byId("tooltip_" + __mouseIndex);

        if (previous) {
            if (previousIndex != __mouseIndex) { previous.className = ""; }
        }

        if (current) {
            current.className = "hover";
            if (canHandleRanges()) {
                //Text field should not filled with the suggestion value until enter button is pressed or mouse click.
                selectRange(__original.length, __terms[__index].length);
            }
        }

        if (previousMouse && previousMouseIndex != __index) { previousMouse.className = ""; }

        if (currentMouse) { currentMouse.className = "hover"; }
    };

    var show = function () {
        if (__container && __query) {
            if (__terms.length > 0) {
                __container.classList.add("visible");

                // get the height of all the suggestions
                var items = __tooltip.children;
                var maxHeight = 0;
                for (var index = 0; index < items.length; index++) {
                    maxHeight += items[index].offsetHeight;
                }
                __container.style.height = maxHeight + "px";
            }
            else {
                hide();
            }
        }
    };

    var hide = function () {
        if (__container && __container.classList.contains("visible")) {
            __container.classList.remove("visible");
            __container.style.height = "0";
        }
    };

    // Text-selection helper-functions
    var canHandleRanges = function () {
        return __query.createTextRange || __query.setSelectionRange;
    };

    var selectRange = function (from, to) {
        if (__query.createTextRange) {
            var t = __query.createTextRange();
            t.moveStart("character", from);
            t.select();
        } else if (__query.setSelectionRange) {
            __query.setSelectionRange(from, to);
        }
    };

    var getCaretPosition = function () {
        if (document.selection) {
            var range = document.selection.createRange().duplicate();
            range.collapse(true);
            range.moveStart("character", -1000);
            return range.text.length;
        } else if (__query.setSelectionRange) {
            return __query.selectionStart;
        } else {
            return __query.value.length;
        }
    };

    var clearInlineSuggestion = function () {
        if (__query && canHandleRanges() && clearInlineSuggestionBeforeSubmit) {
            __query.value = __query.value.substring(0, getCaretPosition());
        }
    };

    // General helper-functions
    var findPosX = function (obj) {
        var curleft = 0;
        if (obj.offsetParent) {
            while (obj.offsetParent && obj.className != "pageContainer") {
                curleft += obj.offsetLeft;
                obj = obj.offsetParent;
            }
        } else if (obj.x)
            curleft += obj.x;
        return curleft;
    };

    var findPosY = function (obj) {
        var curtop = 0;
        if (obj.offsetParent) {
            while (obj.offsetParent && obj.className != "pageContainer") {
                curtop += obj.offsetTop;
                obj = obj.offsetParent;
            }
        } else if (obj.y) {
            curtop += obj.y;
        }
        return curtop;
    };

    var byId = function (id) {
        var element = document.getElementById ? document.getElementById(id) : false;
        return element && element !== null ? element : false;
    };

    return {
        clearInlineSuggestionBeforeSubmit: function (val) {
            if (val !== "") { clearInlineSuggestionBeforeSubmit = val; }
            return clearInlineSuggestionBeforeSubmit;
        },
        displayResults: displayResults,
        fetchResults: fetchResults,
        hide: hide,
        initialize: initialize,
        keyDown: keyDown,
        keyUp: keyUp,
        mouseClick: mouseClick,
        mousein: function () {
            return mousein;
        },
        mouseOut: mouseOut,
        mouseOver: mouseOver,
        searchHostEnv: function (val) {
            if (val !== undefined) { searchHostEnv = val; }
            return searchHostEnv;
        },
        show: show,
        useInlineSuggestion: function (val) {
            if (val !== undefined) { useInlineSuggestion = val; }
            return useInlineSuggestion;
        }
    };
}());

// initialize script dependency for search
cdc.search.init();


/**
* _fatfooter.js
*   This script sets up the popup menus for fatfooter
*
*   (c) 1992-2013 Cisco Systems, Inc. All rights reserved.
*   Terms and Conditions: http://cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
*
*/

if (window.cdc === undefined) { cdc = {}; }

cdc.fatfooter = (function () {
    var isClicked = false;

    var addListeners = function () {
        jQuery('.submenu-container').mouseenter(function () {
            if (!jQuery(this).hasClass('clicked') && !jQuery(this).hasClass('hovered')) {
                showMenu(this, 'hovered');
            }
        }).mouseleave(function (event) {
            if (jQuery(this).hasClass('hovered')) {
                hideMenu(this);
            }
        });

        // onclick registers onfocus then click - use this, since this is fired before onfocus, to prevent onfocus firing when clicked
        jQuery('#fw-fatfooter h4 .menu-button').mousedown(function () {
            isClicked  = true;
        // open submenu when tabbing is used
        }).focus(function () {
            if (!isClicked) {
                var currentMenu = this;
                showMenu(currentMenu.parentNode, 'hovered');
            }
        // open submenu on clicking of the button
        }).click(function (event) {
            showMenu(jQuery(this).closest('.submenu-container'), 'clicked');
            // prevent click listener on body from firing
            event.stopPropagation();
        });

        //  close-button now is the last element in submenu
        jQuery('.fatfooter-submenu .close-button').on("blur click", function () {
            hideMenu(jQuery(this).closest('.submenu-container'));    // get(0) converts jQuery object into pure javascript object
        });

        // close submenu when click outside of submenu
        jQuery('body').on('click', function (event) {
            if (jQuery(event.target).parents('.fatfooter-submenu').length === 0 && !jQuery(event.target).hasClass('fatfooter-submenu')) {
                closeAllMenus();
            }
        });

        //  for iPad - to close submenu when click outside of it
        jQuery('#fw-fatfooter, #fw-footer').on('touchstart', function (event) {
            if (jQuery(event.target).parents('.fatfooter-submenu').length === 0) {
                closeAllMenus();
            }
        });
    };

    var showMenu = function(menu, classname) {
        closeAllMenus();

        var submenuTopPosition = (jQuery(menu).find('.menu-button').outerHeight()/2 - jQuery(menu).find('.fatfooter-submenu').outerHeight())/2;

        if (jQuery(menu).attr('style') === undefined) { jQuery(menu).find('.fatfooter-submenu').css('top', submenuTopPosition + 'px'); }
        jQuery(menu).removeClass('hidden').addClass(classname);
    };

    var hideMenu = function (menu) {
        jQuery(menu).removeClass('clicked hovered').addClass('hidden');

        isClicked = false;
    };

    var closeAllMenus = function () {
        jQuery('.submenu-container').removeClass('clicked hovered').addClass('hidden');
    };

    return {
        init: function() {
            addListeners();
        }
    };
}());

cdc.fatfooter.init();

/**
 * footer_feedback_ol.js
 * $Revision: 1.7 $
 *
 *   This script sets up functionality for the Opinion Lab framework feedback form
 *
 *   (c) 1992-2011 Cisco Systems, Inc. All rights reserved.
 *   Terms and Conditions: http://cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
 *
 */

jQuery(document).ready(function () { // on ready
    cdc.util.ensureNamespace('cdc.ol');
    cdc.ol.enabled = false;
    cdc.ol.enable = function() {
        // use includer to pull in ol engine
        cdc.includer.loadJs("/etc/designs/cdc/fw/j/config.js", {
            callback: function () {
                var oo_feedback_footer, jFtrLinks;
                oo_feedback_footer = new OnlineOpinion.Ocode({});
                if (jQuery('#footer-nav').length) {
                    jFtrLinks = jQuery('#footer-nav').find('a');
                } else if (jQuery('#fw-footer').length) {
                    jFtrLinks = jQuery('#fw-footer').find('a[href]');
                } else {
                    jFtrLinks = jQuery('#fw-footer-nav').find('a');
                }

                // iterate over the links and find the feedback link
                jFtrLinks.each(function () {
                    var linkHref, addClickToLink, indexOfResult, currentUrl, isFeedbackLink;
                    isFeedbackLink = false;
                    linkHref = jQuery(this).attr('href');

                    jQuery(cdc.config.ol.footerFeedbackUrlIndex).each(function () { // test current href against an array of urls with indexOf
                        currentUrl = this; //store the current url we are testing for
                        indexOfResult = linkHref.indexOf(currentUrl);
                        if (indexOfResult !== -1){
                            isFeedbackLink = true;
                            return (indexOfResult !== -1); //break out of the iteration if we found the url
                        }
                    }); // end urls.each

                    // is a feedback link
                    if (isFeedbackLink === true ) {
                        // setup ol click (generic function that takes jq node)
                        addClickToLink = function (l) {
                            jQuery(l).attr('target', 'feedback_window').click(function () { // note that OL overrides the name of the target window
                                oo_feedback_footer.show();
                                return false;
                            });
                        };

                        if (!jQuery('body').hasClass('fw-res')) {
                            var olGif = jQuery('<img src="//www.cisco.com/web/fw/i/sm_0000EE_oo1.gif" border="0" title="Feedback" id="fw_feedback_img" alt="Leave Feedback" />');
                            if(jQuery(this).prev('img').attr('id') !== "fw_feedback_img"){ //avoid multiple icons that were creeping in occassionally on login page due to language change content refreshes.
                                jQuery(this).before(olGif);
                            }
                            addClickToLink(olGif);
                        }

                        // attach ol click to link and img
                        addClickToLink(this);
                    } // end if

                    return (isFeedbackLink !== true); //exit the iteraton if we found the link
                }); // end each
                cdc.ol.enabled = true;
            }
        }); // end includer load

    }; // end cdc.ol.enable()

    if (cdc.ol.enabled === false) { //ensure single init. was an issue on login page due to language content refreshes
        cdc.ol.enable(); //init
    }

    //login page: listen for changes to content after an ajax language switch
    jQuery('body').bind('cdc.login.languagechanged', function() {
        cdc.ol.enable();
    });
});
/*   OnlineOpinion v5.6.4 Released: 10/4/2012. Compiled 10/04/2012 11:28:22 AM -0500 Branch: master 4f693587716b7e98e287fda65b83b28cde6a3d5b Components: Full The following code is Copyright 1998-2012 Opinionlab, Inc.  All rights reserved. Unauthorized use is prohibited. This product and other products of OpinionLab, Inc. are protected by U.S. Patent No. 6606581, 6421724, 6785717 B1 and other patents pending. http://www.opinionlab    */var OOo={Browser:(function(){var a=navigator.userAgent,b=Object.prototype.toString.call(window.opera)==='[object Opera]',c={IE:!!window.attachEvent&&!b,Opera:b,WebKit:a.indexOf('AppleWebKit/')>-1,Chrome:a.indexOf('Chrome')>-1,Gecko:a.indexOf('Gecko')>-1&&a.indexOf('KHTML')===-1,MobileSafari:/Apple.*Mobile.*Safari/.test(a),PalmPre:a.indexOf('Pre/')>-1,BlackBerry:a.indexOf('BlackBerry')>-1,Fennec:a.indexOf('Fennec')>-1,IEMobile:a.indexOf('IEMobile')>-1,OperaMobile:a.search(/Opera (?:Mobi|Mini)/)>-1,ua:a},d=false;c.isMobile=(c.MobileSafari||c.PalmPre||c.BlackBerry||c.Fennec||c.IEMobile||c.OperaMobile);return c}())};OOo.Cache={};OOo.instanceCount=0;OOo.K=function(){};var OnlineOpinion=OnlineOpinion||OOo;(function(){function l(a){return document.getElementById(a)}function k(a,b){var c;for(c in b){if(b.hasOwnProperty(c)){a[c]=b[c]}}return a}function m(a,b,c,d){if(a.addEventListener){a.addEventListener(b,c,d)}else if(a.attachEvent){a.attachEvent('on'+b,c)}}function q(a,b,c,d){if(a.removeEventListener){a.removeEventListener(b,c,d)}else if(a.detachEvent){a.detachEvent('on'+b,c)}}function s(a){var b=[],c;for(c in a){if(a.hasOwnProperty(c)){b.push(c+'='+(encodeURIComponent(a[c])||''))}}return b.join('&')}function t(a){var b=s(a.metrics),c=a.tealeafId+'|'+a.clickTalePID+'/'+a.clickTaleUID+'/'+a.ClickTaleGetSID;b+='&custom_var='+OOo.createLegacyVars(a.legacyVariables,c);if(a.metrics.type==='OnPage'){b+='|iframe'}if(a.asm){b+='&asm=2'}b+="&_"+'rev=2';if(a.customVariables){b+='&customVars='+encodeURIComponent(OOo.serialize(a.customVariables))}return b}function n(a,b){var c=document,d=c.createElement('form'),e=c.createElement('input'),f=a.referrerRewrite;a.metrics.referer=location.href;if(f){a.metrics.referer=OOo.referrerRewrite(f)}d.style.display='none';d.method='post';d.target=b||'OnlineOpinion';d.action=a.onPageCard?'https://secure.opinionlab.com/ccc01/comment_card_json_4_0_b.asp?r='+location.href:'https://secure.opinionlab.com/ccc01/comment_card_d.asp';if(a.commentCardUrl){d.action=a.commentCardUrl;if(a.onPageCard){d.action+='?r='+location.href}}e.name='params';e.value=t(a);d.appendChild(e);c.body.appendChild(d);return d}function r(){return{width:screen.width,height:screen.height,referer:location.href,prev:document.referrer,time1:(new Date()).getTime(),time2:null,currentURL:location.href,ocodeVersion:'5.6.4'}}function u(a){var b='';if(a&&a.search('://')>-1){var c=a.split('/');for(i=3;i<c.length;i++){b+="/";b+=c[i]}}return b}function o(a,b){a=a||{};if(typeof a==='string'){return b+'|'+a}return a.override?a.vars:b+(a.vars?'|'+a.vars:'')}function p(a,b){if(!b){b=location}if(typeof a==="string")return a;return a.searchPattern?b.href.replace(a.searchPattern,a.replacePattern):a.replacePattern}var w=(function(){var a=document.body,b,c,d,e,f;if(document.createElement&&a&&a.appendChild&&a.removeChild){b=document.createElement('div');if(!b.getBoundingClientRect){return null}b.innerHTML='x';b.style.cssText='position:fixed;top:100px;';a.appendChild(b);c=a.style.height;d=a.scrollTop;a.style.height='3000px';a.scrollTop=500;e=b.getBoundingClientRect().top;a.style.height=c;f=(e===100);a.removeChild(b);a.scrollTop=d;return f}return null}()),x=(function(){if(navigator.appName==="Microsoft Internet Explorer"&&navigator.userAgent.search("MSIE 6")!==-1){return true}var a=document.body,b,c;if(document.createElement&&a&&a.appendChild&&a.removeChild){b=document.createElement('iframe');c=false;b.setAttribute('name','oo_test');b.style.display='none';a.appendChild(b);c=!!!document.getElementsByName('oo_test')[0];a.removeChild(b);return c}else{return null}}());function v(){OOo.$('oo_container').style.display='none'}function A(){var a=OOo.$('oo_invitation_prompt');if(a){var b=OOo.$('oo_container');this.showPrompt(b);return}var c=window.XMLHttpRequest?new XMLHttpRequest():new window.ActiveXObject("Microsoft.XMLHTTP"),d=this,e=document.createElement('link'),f;c.onreadystatechange=function(){if(c.readyState!==4){return}d.showPrompt(c.responseText)};c.open("GET",this.options.pathToAssets+this.options.promptMarkup,true);c.send(null)}function y(a,b){var c=document,d=typeof a==='string'?c.createElement('div'):a,e=c.createElement('div'),f,g,h=this.options,j;e.id='oo_invitation_overlay';d.id='oo_container';d.style.visibility='hidden';if(typeof a==='string'){d.innerHTML=a;c.body.appendChild(d)}d.appendChild(e);j=OOo.$('oo_launch_prompt');if(h.companyLogo){f=new Image();f.src=h.companyLogo;OOo.$('oo_company_logo').appendChild(f)}OOo.addEventListener(j,'click',b.bind(this),false);if(h.clickCallbacks){if(typeof h.clickCallbacks.yes==='function'){OOo.addEventListener(j,'click',function(){h.clickCallbacks.yes()},false)}if(typeof h.clickCallbacks.no==='function'){OOo.addEventListener(OOo.$('oo_no_thanks'),'click',function(){h.clickCallbacks.no()},false)}}if(h.neverShowAgainButton){g=OOo.$('oo_never_show');g.style.visibility='visible';OOo.addEventListener(g,'click',this.killPrompt.bind(this),false)}if(OOo.Browser.IE&&!window.XMLHttpRequest){e.style.position='absolute';e.style.width=Math.max(document.documentElement.clientWidth,document.body.offsetWidth)+'px';e.style.height=Math.max(document.documentElement.clientHeight,document.body.offsetHeight)+'px';d.style.position='absolute'}d.style.visibility='visible';d.style.display='block';e.className='no_loading'}k(OOo,{extend:k,toQueryString:s,addEventListener:m,$:l,appendOOForm:n,removeEventListener:q,createMetrics:r,truncateMetric:u,createLegacyVars:o,POSITION_FIXED_SUPPORTED:w,DYNAMIC_FRAME_NAME_IS_BUGGY:x,getFormParams:t,referrerRewrite:p,hidePrompt:v,getPrompt:A,showPrompt:y})}());(function(){function f(a){if(!a){return null}switch(typeof a){case'number':case'boolean':case'function':return a;case'string':return'\''+a+'\'';case'object':var b,c,d,e;if(a.constructor===Array||typeof a.callee!=='undefined'){b='[';d=a.length;for(c=0;c<d-1;c+=1){b+=f(a[c])+','}b+=f(a[c])+']'}else{b='{';for(e in a){if(a.hasOwnProperty(e)){b+=e+':'+f(a[e])+','}}b=b.replace(/\,$/,'')+'}'}return b;default:return null}}OOo.extend(OOo,{serialize:f})}());(function(){function e(a,b,c){var d;if(a.search(b[0])!==-1){OOo.createCookie(c,0);return false}else if(OOo.readCookie(c)){d=parseInt(OOo.readCookie(c),10);if((a.search(b[d+1])!==-1)&&(d+1!==b.length-1)){OOo.createCookie(c,d+1);return false}else if(a.search(b[d])!==-1){return false}else if(d+1===b.length-1&&a.search(b.pop())!==-1){OOo.eraseCookie(c);return true}else{OOo.eraseCookie(c);return false}}else{return false}}OOo.extend(OOo,{checkTunnel:e})}());(function(){function r(a){var b="",c;for(c=7;c>=0;c-=1){b+='0123456789abcdef'.charAt((a>>(c*4))&0x0F)}return b}function u(a){var b=((a.length+8)>>6)+1,c=new Array(b*16),d;for(d=0;d<b*16;d+=1){c[d]=0}for(d=0;d<a.length;d+=1){c[d>>2]|=a.charCodeAt(d)<<(24-(d%4)*8)}c[d>>2]|=0x80<<(24-(d%4)*8);c[b*16-1]=a.length*8;return c}function o(a,b){var c=(a&0xFFFF)+(b&0xFFFF),d=(a>>16)+(b>>16)+(c>>16);return(d<<16)|(c&0xFFFF)}function p(a,b){return(a<<b)|(a>>>(32-b))}function w(a,b,c,d){if(a<20){return(b&c)|((~b)&d)}if(a<40){return b^c^d}if(a<60){return(b&c)|(b&d)|(c&d)}return b^c^d}function x(a){return(a<20)?1518500249:(a<40)?1859775393:(a<60)?-1894007588:-899497514}function v(a){var b=u(a),c=new Array(80),d=1732584193,e=-271733879,f=-1732584194,g=271733878,h=-1009589776,j,l,k,m,q,s,t,n;for(t=0;t<b.length;t+=16){j=d;l=e;k=f;m=g;q=h;for(n=0;n<80;n+=1){if(n<16){c[n]=b[t+n]}else{c[n]=p(c[n-3]^c[n-8]^c[n-14]^c[n-16],1)}s=o(o(p(d,5),w(n,e,f,g)),o(o(h,c[n]),x(n)));h=g;g=f;f=p(e,30);e=d;d=s}d=o(d,j);e=o(e,l);f=o(f,k);g=o(g,m);h=o(h,q)}return r(d)+r(e)+r(f)+r(g)+r(h)}OOo.extend(OOo,{sha1:v})}());(function(){function h(a,b){if(!b){b=location}var c=a.cookieName||'oo_abandon',d=OOo.readCookie(c),e=a.startPage,f=a.endPage,g=a.middle;if(!d){if(b.pathname.indexOf(e)!==-1){OOo.createCookie(c)}return false}else if(b.pathname.indexOf(f)!==-1){OOo.eraseCookie(c);return false}else if(b.pathname.search(g)!==-1){return false}else{OOo.eraseCookie(c);return true}}OOo.extend(OOo,{checkAbandonment:h})}());(function(){function d(a){var b,c;for(b=a.length-1;b>=0;b-=1){if(a[b].read){c=OOo.readCookie(a[b].name);if(!!c&&c===a[b].value){return true}else if(typeof a[b].value==='undefined'&&!!OOo.readCookie(a[b].name)){return true}}}return false}function e(a){var b;for(b=a.length-1;b>=0;b-=1){if(a[b].set){OOo.createCookie(a[b].name,a[b].value,a[b].expiration)}}}OOo.extend(OOo,{checkThirdPartyCookies:d,setThirdPartyCookies:e})}());OOo.extend(Function.prototype,(function(){if(typeof Function.prototype.bind!=="undefined"){return}var e=Array.prototype.slice;function f(a,b){var c=a.length,d=b.length;while(d){d-=1;a[c+d]=b[d]}return a}function g(a,b){a=e.call(a,0);return f(a,b)}function h(b){if(arguments.length<2&&typeof b==="undefined"){return this}var c=this,d=e.call(arguments,1);return function(){var a=g(d,arguments);return c.apply(b,a)}}return{bind:h}}()));(function(){function f(a){if(!a){a=location}var b;if(a.host.search(/\.[a-z]+/)!==-1){b=a.host.split('.').reverse();if(b.length>3){return a.host}b='.'+b[1]+'.'+b[0]}else{b=a.host}return b}function g(a,b,c){var d='',e='';if(c){d=new Date();d.setTime(d.getTime()+(c*1000));e="; expires="+d.toGMTString()}if(location.host!==f()){document.cookie=a+"="+b+e+"; path=/; domain="+f()+";"}else{document.cookie=a+"="+b+e+"; path=/;"}}function h(a){var b=a+"=",c=document.cookie.split(';'),d,e;for(e=0;e<c.length;e+=1){d=c[e];while(d.charAt(0)===' '){d=d.substring(1,d.length)}if(d.indexOf(b)===0){return d.substring(b.length,d.length)}}return null}function j(a){g(a,"",-1)}OOo.extend(OOo,{getCookieDomain:f,createCookie:g,readCookie:h,eraseCookie:j})}());OOo.Ocode=function(a){var b=OOo.Browser,c,d;if(a.disableMobile&&b.isMobile){return}if(a.disableNoniOS&&(navigator.userAgent.search('Android')!==-1||b.PalmPre||b.IEMobile||b.OperaMobile||b.Fennec)){return}OOo.instanceCount+=1;this.options={tealeafCookieName:'TLTSID'};OOo.extend(this.options,a);c=this.options;c.metrics=OOo.createMetrics();this.frameName=c.onPageCard?'OnlineOpinion'+OOo.instanceCount:'OnlineOpinion';if(c.cookie&&OOo.Ocode.matchUrl(c.cookie,location)){return}if(c.thirdPartyCookies&&OOo.checkThirdPartyCookies(c.thirdPartyCookies)){return}if(c.abandonment&&!OOo.checkAbandonment(c.abandonment)){return}if(c.tunnel&&!OOo.checkTunnel(location.pathname,c.tunnel.path,c.tunnel.cookieName)){return}if(c.events&&c.events.onSingleClick){this.singProbability=Math.random()<1-c.events.onSingleClick/100}c.tealeafId=OOo.readCookie(c.tealeafCookieName)||OOo.readCookie(c.sessionCookieName);if(c.events){this.setupEvents();if(c.events.disableLinks||c.events.disableFormElements){this.setupDisableElements()}}if(c.floating){this.floating()}else if(c.bar){this.bar()}else if(c.tab){this.tab()}};OOo.Ocode.prototype={show:function(a,b){if(a==='Tab'&&b&&b.preventDefault){b.preventDefault()}if(this.onPageCardVisible){return}var c=this.options,d;if(c.events&&c.events.prompt){if(c.cookie)OOo.eraseCookie(c.cookie.name||'oo_r');OOo.hidePrompt()}if(this.interruptShow){return}if(!this.floatingLogo&&c.cookie&&OOo.Ocode.matchUrl(c.cookie)){return}if(!c.floating&&c.events&&this.singProbability){return}if(c.events&&c.events.onSingleClick){this.singProbability=true}if(c.cookie){OOo.Ocode.tagUrl(c.cookie)}if(c.thirdPartyCookies){if(OOo.checkThirdPartyCookies(c.thirdPartyCookies)){return}OOo.setThirdPartyCookies(c.thirdPartyCookies)}if(this.floatingLogo){this.floatingLogo.children[0].blur()}if(this.floatingLogo&&c.disappearOnClick){this.floatingLogo.style.display='none'}if(a){c.metrics.trigger=a}if(c.clickTalePID&&typeof window.ClickTale==='function'){c.clickTaleUID=window.ClickTaleGetUID();c.clickTaleSID=window.ClickTaleGetSID()}if(c.onPageCard){this.setupOnPageCC()}else{this.launchOOPopup()}d=c.floating||c.tab||c.bar;if(d&&typeof d.onClickCallback==='function'){d.onClickCallback()}if(OOo.Browser.IE){return false}}};OOo.extend(OOo.Ocode,{tagUrl:function(a,b){if(!b){b=location}var c=a.name||'oo_r',d=a.type==='page'?b.href:b.hostname,e=OOo.readCookie(c)||'';if(OOo.Ocode.matchUrl(a,b)){return}OOo.createCookie(c,e+OOo.sha1(d),a.expiration)},matchUrl:function(a,b){if(!b){b=location}var c=OOo.readCookie(a.name||'oo_r'),d;if(!c){return false}d=a.type==='page'?b.href:b.hostname;return c.search(OOo.sha1(d))!==-1}});(function(){var g=0;function h(){var a=this.options,b=a.newWindowSize||[545,325],c=[parseInt((a.metrics.height-b[1])/2,10),parseInt((a.metrics.width-b[0])/2,10)],d,e,f='location=no,status=no,width='+b[0]+',height='+b[1]+',top='+c[0]+',left='+c[1];ie7=OOo.Browser.IE&&navigator.userAgent.search('MSIE 7')!==-1,windowName='OnlineOpinion';if(a.newWindow)windowName=windowName+(g++);a.metrics.time2=(new Date()).getTime();a.metrics.type='Popup';if(a.asm){f+=',scrollbars=1'}d=OOo.appendOOForm(a,windowName);e=window.open(ie7?a.commentCardUrl||'https://secure.opinionlab.com/ccc01/comment_card_d.asp?'+d.children[0].value:'',windowName,f);if(e&&!ie7){d.submit()}}OOo.extend(OOo.Ocode.prototype,{launchOOPopup:h})}());(function(){function l(){var a=this.options.events,b=[false,false],c=['onExit','onEntry'],d=OOo.Browser.Opera?'unload':'beforeunload',e,f,g,h,j;if(a.prompt){OOo.extend(this.options,{promptMarkup:a.prompt.promptMarkup||'oo_event_prompt.html',neverShowAgainButton:false,pathToAssets:a.prompt.pathToAssets})}for(g=c.length-1;g>=0;g-=1){e=c[g];if(a[e]instanceof Array){h=a[e];j=h.length;while(j&&!b[g]){j-=1;if(window.location.href.search(h[j].url)!==-1&&Math.random()>=1-h[j].p/100){b[g]=true}}}else if(a[e]&&Math.random()>=1-a[e]/100){b[g]=true}}if(b[0]){OOo.addEventListener(window,d,this.show.bind(this,'onExit'),false)}if(b[1]){if(a.delayEntry){window.setTimeout(function(){if(a.prompt)this.getPrompt();else this.show()}.bind(this,'onEntry'),a.delayEntry*1000)}else{if(a.prompt)this.getPrompt();else this.show('onEntry')}}}function k(a){var b=a||window.event,c=a.target||a.srcElement,d=this.options.events,e=c.parentNode,f=5,g=0;while(e&&(c.nodeName!=='A'||c.nodeName!=='INPUT')&&g!==f){if(e.nodeName==='A'){c=e}e=e.parentNode;g+=1}if(d.disableFormElements&&(c.tagName==="INPUT"||c.tagName==="BUTTON")&&(c.type==='submit'||c.type==='image'||c.type==='reset'||c.type==='button')){this.interruptShow=true}if(d.disableLinks&&(c.nodeName==='A'||c.nodeName==='AREA')&&c.href.substr(0,4)==='http'&&c.href.search(d.disableLinks)!==-1){this.interruptShow=true}}function m(a){this.interruptShow=true}function q(){OOo.addEventListener(document.body,'mousedown',k.bind(this));if(!this.options.events.disableFormElements){return}var a=document.getElementsByTagName('form'),b;for(b=a.length-1;b>=0;b-=1){OOo.addEventListener(a[b],'submit',m.bind(this))}}OOo.extend(OOo.Ocode.prototype,{setupEvents:l,setupDisableElements:q,getPrompt:function(){OOo.getPrompt.call(this)},showPrompt:function(a){if(this.options.cookie){OOo.Ocode.tagUrl(this.options.cookie)}OOo.showPrompt.call(this,a,this.show)}})}());OOo.extend(OOo.Ocode.prototype,{floating:function(){var d=document,e=this.floatingLogo=document.createElement('div'),f=d.createElement('div'),g=d.createElement('div'),h=d.createElement('div'),j=d.createElement('span'),l=this.options.floating,k=OOo.$(l.contentId),m='10px',q=l.id,s=d.createElement('span'),t,n,r,u,o,p,w,x;function v(a){return a.offsetLeft+a.offsetWidth}function A(a){u.style.left=v(k)+'px'}s.innerHTML="Screen reader users: Please switch to forms mode for this link.";s.className="screen_reader";if(q){e.id=q}e.className='oo_feedback_float';g.className='oo_transparent';f.className='olUp';h.className='olOver';f.tabIndex=0;f.onkeyup=function(a){t=a||window.event;if(t.keyCode!==13){return}this.show()}.bind(this);f.innerHTML=l.caption||'Feedback';e.appendChild(s);e.appendChild(f);j.innerHTML=l.hoverCaption||'Click here to<br>rate this page';h.appendChild(j);e.appendChild(h);e.appendChild(g);function y(a){var b=d.documentElement.scrollTop||d.body.scrollTop,c=d.documentElement.clientHeight||document.body.clientHeight;e.style.top=(b+c-(w||0)-10)+'px'}if(OOo.Browser.MobileSafari){if(OOo.Browser.ua.search('OS 4')!==-1){n=window.innerHeight;e.style.bottom=null;e.style.top=(window.pageYOffset+window.innerHeight-60)+'px';x=function(a){r=window.pageYOffset-(n-window.innerHeight);e.style.webkitTransform='translateY('+r+'px)'};OOo.addEventListener(window,'scroll',x,false);setTimeout(x,100)}}else if(!OOo.POSITION_FIXED_SUPPORTED){e.style.position='absolute';e.style.bottom='';OOo.addEventListener(window,'scroll',y,false);OOo.addEventListener(window,'resize',y,false);if(d.compatMode==="BackCompat"){e.style.background="white"}}if(l.position&&l.position.search(/Content/)&&k){u=this.spacer=d.createElement('div');o=OOo.Browser.WebKit?d.body:d.documentElement;u.id='oo_feedback_fl_spacer';u.style.left=v(k)+'px';d.body.appendChild(u);switch(l.position){case'rightOfContent':p=function(a){e.style.left=(v(k)-o.scrollLeft)+'px';if(!OOo.POSITION_FIXED_SUPPORTED){p=null}};break;case'fixedPreserveContent':p=function(a){var b=OOo.Browser.IE?d.body.clientWidth:window.innerWidth,c=OOo.POSITION_FIXED_SUPPORTED?o.scrollLeft:0;if(b<=v(k)+e.offsetWidth+parseInt(m,10)){e.style.left=(v(k)-c)+'px'}else{e.style.left='';e.style.right=m}};break;case'fixedContentMax':p=function(a){var b=OOo.Browser.IE?d.body.clientWidth:window.innerWidth;if(b<=v(k)+e.offsetWidth+parseInt(m,10)){e.style.left='';e.style.right=m;if(!OOo.POSITION_FIXED_SUPPORTED&&a&&a.type==='scroll'){e.style.left=(d.body.clientWidth+d.body.scrollLeft-105)+'px'}}else{e.style.left=(v(k)-o.scrollLeft)+'px';e.style.right=''}};break}window.setTimeout(p,0);OOo.addEventListener(window,'scroll',p,false);OOo.addEventListener(window,'resize',p,false);OOo.addEventListener(window,'resize',A,false)}else{e.style.right=m}OOo.addEventListener(e,'click',this.show.bind(this,'Floating'),false);OOo.addEventListener(e,'touchstart',this.show.bind(this,'Floating'),false);d.body.appendChild(e);if(!OOo.POSITION_FIXED_SUPPORTED&&!OOo.Browser.MobileSafari){g.style.height=e.clientHeight+'px';w=e.clientHeight;setTimeout(y,100)}},removeFloatingLogo:function(){document.body.removeChild(this.floatingLogo);if(this.spacer){document.body.removeChild(this.spacer)}}});OOo.extend(OOo.Ocode.prototype,{bar:function(){var d=document,e=this.floatingLogo=d.createElement('div'),f=d.createElement('span'),g,h,j,l=d.documentElement.scrollTop||d.body.scrollTop,k=d.createElement('div');function m(a){var b=curtop=0;if(a.offsetParent){do{b+=a.offsetLeft;curtop+=a.offsetTop}while(a=a.offsetParent);return[b,curtop]}}function q(a){var b=document.activeElement,c;if(!b)return;c=m(b);if(!c)return;if(c[1]+b.clientHeight>(window.innerHeight||document.body.clientHeight)+(window.pageYOffset||document.body.scrollTop)-e.clientHeight)window.scrollBy(0,b.clientHeight+20)}k.innerHTML='Link opens comment card';k.className='screen_reader';e.appendChild(k);this.reflowBar=OOo.K;e.id='oo_bar';f.innerHTML=this.options.bar.caption||'Feedback';e.appendChild(f);e.tabIndex=0;e.onkeyup=function(a){var b=a||window.event;if(b.keyCode!==13){return}this.show()}.bind(this);OOo.addEventListener(e,'click',this.show.bind(this,'Bar'));document.body.className+=document.body.className<1?'oo_bar':' oo_bar';document.body.appendChild(e);if(OOo.Browser.IE){if(d.compatMode==='CSS1Compat'){g=function(a){if(a&&a.type==='resize'){setTimeout(g,50)}e.style.top=(d.documentElement.scrollTop+document.documentElement.clientHeight-e.clientHeight-1)+'px';e.style.width=(Math.max(d.documentElement.clientWidth,d.body.offsetWidth))+'px'}}else{g=function(a){e.style.top=(d.body.scrollTop+document.body.clientHeight-e.clientHeight-1)+'px';e.style.width=(Math.max(d.documentElement.clientWidth,d.body.offsetWidth)-22)+'px'}}e.style.position='absolute';OOo.addEventListener(window,'scroll',g,false);OOo.addEventListener(window,'resize',g,false);this.reflowBar=function(){e.style.display='none';g();e.style.display='block'};g()}else if(OOo.Browser.MobileSafari&&OOo.Browser.ua.search('OS 4')!==-1){h=window.innerHeight;e.style.bottom=null;e.style.top=(window.pageYOffset+window.innerHeight-22)+'px';g=function(a){j=window.pageYOffset-(h-window.innerHeight);e.style.webkitTransform='translateY('+j+'px)'};OOo.addEventListener(window,'scroll',g,false);setTimeout(g,100)}OOo.addEventListener(document.body,'keyup',q,false)}});OOo.extend(OOo.Ocode.prototype,{tab:function(){var e=document,f=this.floatingLogo=e.createElement('div'),g=e.createElement('div'),h=e.createElement('span'),j=this.options.tab;function l(a){var b=e.documentElement.scrollTop||e.body.scrollTop,c=e.documentElement.scrollLeft||e.body.scrollLeft,d=e.documentElement.clientHeight||document.body.clientHeight;f.style.top=(b+(d/2-f.clientHeight/2))+'px';if((!j.position||j.position==='right'))f.style.right=(-1*c+2)+'px'}function k(a){f.style.top=pageYOffset+(innerHeight/2-f.clientHeight/2)+'px';f.style.right=document.documentElement.clientWidth-window.innerWidth-window.pageXOffset-15+'px'}f.id='oo_tab';f.className='oo_tab_'+(j.position||'right');if(!OOo.POSITION_FIXED_SUPPORTED&&!OOo.Browser.MobileSafari){f.style.position='absolute';if((!j.position||j.position==='right')&&OOo.Browser.IE){f.className+=' oo_tab_ie_right';if(OOo.Browser.ua.search('IE 6')===-1){OOo.addEventListener(window,'scroll',l,false);OOo.addEventListener(window,'resize',l,false)}}}f.tabIndex=0;f.onkeyup=function(a){var b=a||window.event;if(b.keyCode!==13){return}this.show()}.bind(this);g.appendChild(h);f.appendChild(g);OOo.addEventListener(f,'click',this.show.bind(this,'Tab'),false);e.body.appendChild(f);if(OOo.Browser.MobileSafari&&OOo.Browser.ua.search('OS 4')!==-1){f.style.position='absolute';OOo.addEventListener(window,'scroll',k,false);setTimeout(k,100)}}});OOo.extend(OOo.Ocode.prototype,{setupOnPageCC:function(){var e=document,f=OOo.Cache.overlay||e.createElement('div'),g=this.wrapper=e.createElement('div'),h=e.createElement('div'),j=e.createElement('div'),l=e.createElement('span'),k=this.frameName,m=e.createElement(OOo.DYNAMIC_FRAME_NAME_IS_BUGGY?'<iframe name="'+k+'">':'iframe'),q=e.createDocumentFragment(),s=this.options,t=s.onPageCard,n='https://secure.opinionlab.com/ccc01/comment_card_json_4_0_b.asp',r,u,o,p=false,w=this,x,v,A,y,B,E,C,D=e.createElement('span');function z(a){if(a&&a.preventDefault){a.preventDefault()}document.body.focus();m.tabIndex=-1;m.title="empty";m['aria-hidden']='true';f.style.display='none';f.className='';e.body.removeChild(g);if(window.postMessage){OOo.removeEventListener(window,'message',B)}else{window.clearInterval(u)}p=false;w.onPageCardVisible=false;return false}B=OOo.Ocode.postMessageHandler(function(a){var b=parseInt(a,10),c,d;if(b>0){if(p){return}p=true;c=window.innerHeight||e.documentElement.clientHeight||e.body.clientHeight;d=b;C=g.offsetTop;if(d+C>c){d=c-40-C;m.style.width='555px'}m.style.height=d+'px';g.style.visibility='visible';if(l.clientHeight<20){l.style.height=g.offsetHeight+'px'}f.className="no_loading";w.onPageCardVisible=true;r&&e.body.removeChild(r)}else if(a==='submitted'){z()}if(OOo.Browser.IE&&e.compatMode==="BackCompat"){window.scrollTo(0,0)}},w.options.commentCardUrl);s.metrics.type='OnPage';OOo.Cache.overlay=f;f.id='oo_overlay';f.style.display='block';f.className='';j.className='iwrapper';g.className='oo_cc_wrapper';g.setAttribute('role','alert');g.setAttribute('aria-describedby','comment_card_description');D.className='screen_reader';D.id='comment_card_description';D.innerHTML='Please leave your feedback in the comment card you just activated';g.appendChild(D);h.className='oo_cc_close';h.innerHTML='<span class="screen_reader">Link closes comment card</span>X';h.title='Click to close comment card';g.style.visibility='hidden';h.tabIndex=0;h.onkeyup=function(a){var b=a||window.event;if(b.keyCode!==13){return}z()};if(OOo.Browser.IE){m.frameBorder='0';if(!window.XMLHttpRequest||e.compatMode==="BackCompat"){E=Math.max(e.documentElement.clientWidth,e.body.offsetWidth);f.style.position='absolute';f.style.width=e.compatMode==="BackCompat"?(E-21)+'px':E+'px';f.style.height=Math.max(e.documentElement.clientHeight,e.body.offsetHeight)+'px';g.style.position='absolute';OOo.addEventListener(window,'scroll',function(){f.style.top=(e.body.scrollTop+document.body.clientHeight-f.clientHeight)+'px';g.style.top=(e.body.scrollTop+C+25)+'px'})}}OOo.addEventListener(h,'click',z);if(t.closeWithOverlay&&!OOo.Browser.isMobile){g.appendChild(l);l.onclick=z;f.onclick=z}m.src=' ';m.name=k;m.title='Comment Card';j.appendChild(h);j.appendChild(m);g.appendChild(j);q.appendChild(g);q.appendChild(f);e.body.appendChild(q);if(window.postMessage){OOo.addEventListener(window,"message",B)}else{u=setInterval(B,500)}s.metrics.time2=(new Date()).getTime();r=OOo.appendOOForm(s,k);r.submit()}});OOo.extend(OOo.Ocode,{postMessageHandler:function(d,e,f){return function(a){var b='https://secure.opinionlab.com',c;if(!f){f=location}if((a&&!(a.origin===b||a.origin.indexOf(e)!==0))||(!a&&f.hash.search('OL=')===-1)){return false}c=a?a.data:f.hash.split('=').pop();if(!a&&location.hash){location.hash=''}d(c);return c}}});OOo.Invitation=function(a){if(OOo.Browser.isMobile){return}this.options={tunnelCookie:'oo_inv_tunnel',repromptTime:604800,responseRate:50,repromptCookie:'oo_inv_reprompt',promptMarkup:'oo_inv_prompt.html',promptStyles:'oo_inverstitial_style.css',percentageCookie:'oo_inv_percent',pagesHitCookie:'oo_inv_hit',popupType:'popunder',promptDelay:0,neverShowAgainButton:false,loadPopupInBackground:false,truncatePrevCurrentMetrics:false,disablePrevCurrentMetrics:false,tealeafCookieName:'TLTSID',monitorWindow:'oo_inv_monitor.html',beforePrompt:OOo.K};this.popupShown=false;OOo.extend(this.options,a);var b=this.options,c=parseInt(OOo.readCookie(b.pagesHitCookie),10)||0;OOo.Invitation.friendlyDomains=b.friendlyDomains||null;if(location.search.search('evs')!==-1){b.loadPopupInBackground=true;this.launchPopup();OOo.createCookie(b.repromptCookie,1,b.repromptTime===-1?0:b.repromptTime)}setTimeout(function(){if(!window.oo_inv_monitor){return}if(b.area&&location.href.search(b.area)===-1){this.options.popupType='popup';this.launchPopup()}else if(b.goal&&location.href.search(b.goal)!==-1){window.oo_inv_monitor.close()}}.bind(this),1600);if(OOo.readCookie(b.repromptCookie)){return}if(b.thirdPartyCookies&&OOo.checkThirdPartyCookies(b.thirdPartyCookies)){return}if(!OOo.readCookie(b.percentageCookie)){OOo.createCookie(b.percentageCookie,(Math.random()>1-(b.responseRate/100))?"1":"0")}if(typeof b.promptTrigger!=='undefined'){if(b.promptTrigger instanceof RegExp){if(!window.location.href.match(b.promptTrigger)){return}}else if(b.promptTrigger instanceof Array){if(!OOo.checkTunnel(location.pathname,b.promptTrigger,b.tunnelCookie)){return}}}c+=1;OOo.createCookie(b.pagesHitCookie,c);if(b.pagesHit&&c<b.pagesHit){return}OOo.eraseCookie(b.tunnelCookie);if(OOo.readCookie(b.percentageCookie)==='1'){window.setTimeout(function(){OOo.createCookie(b.repromptCookie,1,b.repromptTime);this.options.beforePrompt();this.getPrompt()}.bind(this),b.promptDelay*1000)}};OOo.Invitation.prototype={getPrompt:function(){OOo.getPrompt.call(this)},showPrompt:function(a){OOo.showPrompt.call(this,a,this.launchPopup)},launchPopup:function(){if(this.popupShown){return}this.popupShown=true;var b=this.options,c=window.location.href,d=b.popupType==='popup'?'https://secure.opinionlab.com/ccc01/comment_card.asp?':b.pathToAssets+b.monitorWindow+'?'+(new Date()).getTime()+'&',e,f=[],g=b.asm?[555,500]:[400,335],h,j=OOo.createMetrics(),l=OOo.readCookie(b.tealeafCookieName),k;if(b.clickTalePID&&window.ClickTaleGetUID&&window.ClickTaleGetSID){l+='|'+[b.clickTalePID,window.ClickTaleGetUID(),window.ClickTaleGetSID()].join('/')}g=b.newWindowSize||g;k='location=no,status=no,width='+g[0]+',height='+g[1];if(b.referrerRewrite){j.referer=OOo.referrerRewrite(b.referrerRewrite)}if(b.truncatePrevCurrentMetrics){j.prev=OOo.truncateMetric(j.prev);j.currentURL=OOo.truncateMetric(j.currentURL)}if(b.disablePrevCurrentMetrics){j.prev='';j.currentURL=''}if(b.thirdPartyCookies){OOo.setThirdPartyCookies(b.thirdPartyCookies)}e=OOo.toQueryString(j)+'&type=Invitation';if(b.customVariables){e+='&customVars='+encodeURIComponent(OOo.serialize(b.customVariables))}e+='&custom_var='+OOo.createLegacyVars(b.legacyVariables,l);if(b.asm){e+='&asm=2';k+=',scrollbars=1'}d+=e;if(d.match(/\?/g).length===2)d=d.replace(/\?([^?]*)$/,'&$1');h=window.open(d,'OnlineOpinionInvitation',k);if(!b.loadPopupInBackground&&OOo.$('oo_container')){OOo.hidePrompt()}if(b.popupType==='popunder'){if(!OOo.Browser.Chrome){h.blur();window.focus()}else{if(!b.loadPopupInBackground){window.alert(b.chromeMainWinPrompt||'Please fill out the form behind this window when you are finished.')}if(b.chromeSurveyPrompt){setTimeout(function(a){h.postMessage(b.chromeSurveyPrompt,"*")},500)}}}else if(window.oo_inv_monitor){window.blur();h.focus()}},killPrompt:function(){if(this.options.clickCallbacks&&typeof this.options.clickCallbacks.no==='function'){this.options.clickCallbacks.no()}OOo.createCookie(this.options.repromptCookie,1,157680000);OOo.hidePrompt()}};OOo.extend(OOo.Invitation,{navigateToFriendlyDomain:function(a){location.href=a}});

/* chatController.js: LiveAgent chat controller
 *
 * dependencies:
 *   -- j/userInfoDispatcher.js for cdc.userInfoDispatcher.getUserProfile()
 *
 * mingle card #10616: http://cardbot.cisco.com:8080/projects/leopard_spots/cards/10616
 *
 * 1. it must scan the page for the existance of chat component
 *    - it must support having more than one chat button on the page
 *    - the component will follow the: http://gitlab.cisco.com/id-only/liveagentmeta/blob/master/API/component-microformat.txt
 *    - it must pull in salesforce JS if it finds one
 * 2. figure out if it's going to show at all (based on entitlement from UID)
 * 3. figure out agent availability
 *    - following the use case rules given in http://gitlab.cisco.com/id-only/liveagentmeta/blob/master/DOCS/UseCases.txt
 *    - interact with UID for locale data as necessary
 *    - get the buttonID from the button mapping json
 *    - call salesforce and retreive agent availability info
 * 4. it must interact with the markup of the page to show available/unavailable state
 * 5. if an agent is available it must
 *    - populate the click event handler of the active state with a call to salesforce API for opening a chat window
 * 6. it must put the proactive button ID into the page (also comes from button mapping json)
 *    - the first proactive modal node must be moved from within the component and attached to the body element
 *    - and any subsequent proactive modals should be deleted
 * 7. it must use the stage version of the salesforce service in stage and dev; and the prod version in prod
 *
 */

// NOTE: validated by both jslint.com and jshint.com
//       - should jslint clean EXCEPT for expected error: "'execPromiseChain' is out of scope."
//       - to temporarily 'fix' this, see comments above execPromiseChain implementation

/*jslint browser: true, devel: true, white: true, this: true, multivar: true, single: true, for: true */
/*global cdc, liveagent, Promise, window, ActiveXObject CustomEvent */
/*property
 CONFIG, CustomEvent, URL, accesslevel, addCustomDetail, addEvent,
 addEventListener, all, appendChild, attachEvent, beaconInStage, body,
 buttonId, buttonInfo, buttonMapUrl, buttonOverride, c2c, c2cDebug,
 callback, cdc, chatLog, chatNode, chatNodes, chosen, clearCache,
 codeBeacon, contactInfo, cookie, country, country_code, createEvent, debug,
 deployment, deployment_id, deployment_js, detail, detailsAdded, dir,
 disconnect, dispatchEvent, display, enableLogging, entitlement,
 entitlementOverride, envConfig, environment, error, events, exit, flags,
 getAttribute, getChatInstance, getChatState, getCookie, getItem, getJson,
 getMilliseconds, getScript, getUserProfile, gotParams, hasOwnProperty,
 host, href, id, init, initCounter, initCustomEvent, initQ, initRunning,
 isAvailable, join, json, jsonOverride, jsonUrl, keyCode, lang,
 lang_unknown, language_code, length, listOfDataFields, liveAgentAdapter,
 liveAgentDeployment, liveAgentJsLoaded, liveagent, locale,
 localeDetermined, localeOverride, log, mapperJsonLoaded, match, message,
 messages, modalHeight, modalWidth, org_id, override, page, parentNode,
 parse, pathname, pop, proactiveId, proactiveModalWired, proactiveOverride,
 profile, push, querySelector, querySelectorAll, readyState, reinitialize,
 rejectChat, reload, removeChild, removeEvent, removeItem, rest_url,
 rest_version, results, search, setAttribute, setChatWindowHeight,
 setChatWindowWidth, setItem, setup, shift, showWhenOffline, showWhenOnline,
 signature, split, start, startChat, state, status, stop, stringify, style,
 substr, success, svc_url, test, then, timestamp, toString, total, trigger,
 url, userInfoDispatcher, util, verbose, version, visitor, warnUserInStage,
 wireParams
 */

// finally found a syntax that would pass jslint :-D
if (! window.hasOwnProperty("cdc")) { window.cdc = {}; }

/* the following is a chat controller class that when instantiated via 'new' exposes these methods:
 *
 * - init()
 * - getChatInstance()
 * - reinitialize()
 *
 * if the queryparam 'test=1' is set, the following method is also exposed:
 * - getChatState()
 *
 */

cdc.c2c = function () {
        "use strict"; // jslint does not allow this in global scope
        var myState = null;

        /*
         * LiveAgentAdapter - a facade to wrap the LiveAgent api, written by masridha@cisco.com
         */

        //rejectChat
        //remove
        //removeFinish
        //setState
        //disconnect

        function LiveAgentAdapter (chatlog, addEvent, getCookie) {
                chatlog("[0.4]          -- begin LiveAgentAdapter constructor...");

                function startChat () {
                        var _thisButtonId = this.getAttribute("data-wire-buttonId");
                        chatlog(" -- inside LiveAgentAdapter.startChat(" + _thisButtonId + ")...");
                        liveagent.startChat (_thisButtonId);
                }

                /*
                 * incoming object param 'p':
                 *
                 * var result = {
                 *    'chatNode'  : chatNode,
                 *    'state'     : state,
                 *    'wireParams': wireParams,
                 *    'myself'    : myself
                 * };
                 *
                 * and 'p.wireParams' is
                 *
                 * wireParams:
                 *       var wireParams = {
                 *          'buttonId'    : resolveId(chatNode, state.buttonInfo.buttonId,'button'),
                 *          'proactiveId' : resolveId(chatNode, state.buttonInfo.proactiveId,'proactive'),
                 *          'keyCode'     : chatNode.getAttribute("data-c2c-keycode"),
                 *          'modalHeight' : chatNode.getAttribute("data-c2c-survey-height") || state.buttonInfo.modalHeight,
                 *          'modalWidth'  : chatNode.getAttribute("data-c2c-survey-width")  || state.buttonInfo.modalWidth
                 *       };
                 *
                 */

                this.setup = function (p) {
                        var wire = p.wireParams,
                                proactiveNodes,
                                i;

                        chatlog("[4.4] -- begin LiveAgentAdapter.setup()");
                        chatlog("[4.4]    -- buttonId=[" + wire.buttonId + "], proactiveId=[" + wire.proactiveId + "], keyCode=[" + wire.keyCode + "]...");
                        chatlog("[4.4]    -- modalHeight=[" + wire.modalHeight + "], modalWidth=[" + wire.modalWidth + "]...");
                        chatlog("[4.4]    -- chatNode: ", p.chatNode);

                        var svcConfig     = p.state.envConfig,
                                cpGutcVal     = getCookie('CP_GUTC'),
                                chatNowButton = p.chatNode.querySelector(".c2c-active .c2c-button"); // for array use querySelectorAll

                        // add the wire button Id to the actual button itself so it can be read on click
                        chatNowButton.setAttribute("data-wire-buttonId", wire.buttonId);
                        addEvent(chatNowButton,"click", startChat, p.state);

                        // silly jslint prohibits making functions in a loop
                        function clickHandler (proactiveId, mode) {
                                if (mode === "start") {
                                        return function() {
                                                liveagent.startChat(proactiveId);
                                        };
                                }

                                if (mode === "reject") {
                                        return function() {
                                                liveagent.rejectChat(proactiveId);
                                        };
                                }
                        }

                        // Needed for proactive chat to work
                        // Note: we are only wiring up the first one we find, so ignore if proactive id is null
                        if (wire.proactiveId) {
                                chatlog("[4.4]    -- proactiveId is defined, wiring modal");
                                proactiveNodes = document.querySelectorAll(".c2c-proactive-modal");
                                for (i = 0; i < proactiveNodes.length; i+=1) {
                                        proactiveNodes[i].setAttribute("id", "liveagent_invite_button_" + wire.proactiveId);
                                }

                                proactiveNodes = document.querySelectorAll(".c2c-proactive-agree");
                                for (i = 0; i < proactiveNodes.length; i+=1) {
                                        addEvent(proactiveNodes[i],"click", clickHandler(wire.proactiveId, "start"), p.state);
                                }

                                proactiveNodes = document.querySelectorAll(".c2c-proactive-dismiss");
                                for (i = 0; i < proactiveNodes.length; i+=1) {
                                        addEvent(proactiveNodes[i],"click", clickHandler(wire.proactiveId, "reject"), p.state);
                                }

                                p.state.flags.proactiveModalWired = true;
                        }
                        else {
                                chatlog("[4.4]    -- proactive id is null, modal must be wired already, skipping");
                        }

                        // only add custom details once
                        // -- liveagent code explodes if you try to add details after the init
                        if (!p.state.flags.detailsAdded) {
                                if (wire.keyCode) {
                                        chatlog("[4.4]    -- adding keyCode=[" + wire.keyCode + "] via liveAgent.addCustomDetail()");
                                        liveagent.addCustomDetail('Keycode', wire.keyCode, true);
                                }
                                else {
                                        chatlog("[4.4]    -- keyCode is null, skipping liveAgent.addCustomDetail()");
                                }

                                if (wire["data-c2c-ecid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-ecid=[" + wire["data-c2c-ecid"] + "] via liveAgent.addCustomDetail()");
                                        liveagent.addCustomDetail('data-c2c-ecid', wire["data-c2c-ecid"], true);
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-ecid is null, skipping liveAgent.addCustomDetail()");
                                }
                                if (wire["data-c2c-oid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-oid=[" + wire["data-c2c-oid"] + "] via liveAgent.addCustomDetail()");
                                        liveagent.addCustomDetail('data-c2c-oid', wire["data-c2c-oid"], true);
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-oid is null, skipping liveAgent.addCustomDetail()");
                                }
                                if (wire["data-c2c-ccid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-ccid=[" + wire["data-c2c-ccid"] + "] via liveAgent.addCustomDetail()");
                                        liveagent.addCustomDetail('data-c2c-ccid', wire["data-c2c-ccid"], true);
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-ccid is null, skipping liveAgent.addCustomDetail()");
                                }
                                if (wire["data-c2c-dtid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-dtid=[" + wire["data-c2c-dtid"] + "] via liveAgent.addCustomDetail()");
                                        liveagent.addCustomDetail('data-c2c-dtid', wire["data-c2c-dtid"], true);
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-dtid is null, skipping liveAgent.addCustomDetail()");
                                }

                                if (wire.modalHeight) {
                                        chatlog("[4.4]    -- adding modalHeight=[" + wire.modalHeight + "] via liveAgent.setChatWindowHeight()");
                                        liveagent.setChatWindowHeight(wire.modalHeight);
                                }
                                else {
                                        chatlog("[4.4]    -- modalHeight is null, skipping liveAgent.setChatWindowHeight()");
                                }

                                if (wire.modalWidth) {
                                        chatlog("[4.4]    -- adding modalWidth=[" + wire.modalWidth + "] via liveAgent.setChatWindowWidth()");
                                        liveagent.setChatWindowWidth(wire.modalWidth);
                                }
                                else {
                                        chatlog("[4.4]    -- modalWidth is null, skipping liveAgent.setChatWindowWidth()");
                                }

                                chatlog("[4.4]    -- adding detail for CP_GUTC cookie=[" + cpGutcVal + "]");
                                liveagent.addCustomDetail('CookieInput', cpGutcVal || '', true);

                                chatlog("[4.4]    -- adding detail for doc URL=[" + document.URL + "]");
                                liveagent.addCustomDetail('OriginatingURL', document.URL, true);

                                chatlog("[4.4]    -- adding detail for visitor country=[" + p.state.locale.country.visitor + "]");
                                liveagent.addCustomDetail('CountryInput', p.state.locale.country.visitor || '', true);

                                chatlog("[4.4]    -- calling liveagent.init(); svc=[" + svcConfig.svc_url + "]; " +
                                        "depId=[" + svcConfig.deployment_id + "]; orgId=[" + svcConfig.org_id + "]");
                                liveagent.init (svcConfig.svc_url, svcConfig.deployment_id, svcConfig.org_id);
                                //liveagent.init('https://d.la4-c2-chi.salesforceliveagent.com/chat', '572340000004Cu2', '00D300000000QUu');

                                p.state.flags.detailsAdded = true;
                        }
                        else {
                                chatlog("[4.4]    -- chat.init() has run once already, not adding custom details");
                        }

                        liveagent.showWhenOnline (wire.buttonId, p.chatNode.querySelector(".c2c-active"));
                        liveagent.showWhenOffline(wire.buttonId, p.chatNode.querySelector(".c2c-inactive"));
                        chatlog("[4.4] -- end LiveAgentAdapter.setup()");
                }; // end this.setup()
                chatlog("[0.4]          -- end LiveAgentAdapter constructor");
        } // end LiveAgentAdapter()

        function getState () {
                if (!myState) {
                        myState = {
                                "version":           "8.2.5",
                                "buttonMapUrl":      "//www.cisco.com/c/dam/global/en_us/framework/buttonMapper.json",
                                "chatNodes":         null,
                                "debug":             "",
                                "entitlement":       "",
                                "environment":       "",
                                "envConfig":         null,
                                "initCounter":       0,
                                "initQ":             [],
                                "flags": {
                                        "verbose":             false,
                                        "exit":                false,
                                        "test":                false,
                                        "gotParams":           false,
                                        "localeDetermined":    false,
                                        "liveAgentJsLoaded":   false,
                                        "mapperJsonLoaded":    false,
                                        "proactiveModalWired": false,
                                        "detailsAdded":        false,
                                        "clearCache":          false,
                                        "initRunning":         false
                                },
                                "locale": {
                                        "page":     "",
                                        "visitor":  "",
                                        "chosen":   "",
                                        "country":  {}, // "page" and "visitor"
                                        "lang":     {}  // "page" and "visitor"
                                },
                                "override": {
                                        "buttonId":    "",
                                        "proactiveId": "",
                                        "entitlement": "",
                                        "locale":      ""
                                },
                                "timestamp": {
                                        "all":        {},
                                        "json":       {},
                                        "deployment": {}
                                },
                                "events": []
                        };
                }
                return myState;
        } // end of getState()

        /* Chat() is an inner class, instantiated via 'new'
         * - its 'init' method is exposed by the outer chat controller instance via 'init()'
         * - the instance itself is exposed via the outer chat controller instance via 'getChatInstance()'
         */

        function Chat (selector) {
                var state = getState(),
                        activeParams = { // handlers for the querystring params we want to react to
                                'c2cDebug':
                                        function(input) {
                                                state.debug = input;
                                                state.flags.verbose = true; // turn on verbosity if in debug mode
                                        },

                                'verbose': // can turn off debug verbosity
                                        function(input) { if (input) { state.flags.verbose = true; } else { state.flags.verbose = false; } },

                                'exit':
                                        function(input) { if (input) { state.flags.exit = true; } else { state.flags.exit = false; } },

                                'test':
                                        function(input) { if (input) { state.flags.test = true; } else { state.flags.test = false; } },

                                'clearCache':
                                        function(input) { if (input) { state.flags.clearCache = true; } else { state.flags.clearCache = false; } },

                                'buttonOverride':
                                        function(input) { state.override.buttonId = input; },

                                'proactiveOverride':
                                        function(input) { state.override.proactiveId = input; },

                                'localeOverride':
                                        function(input) { state.override.locale = input; },

                                'entitlementOverride':
                                        function(input) { state.override.entitlement = input; },

                                'jsonOverride':
                                        function(input) { state.override.jsonUrl = decodeURIComponent(input); }
                        }; // end 'activeParams' object

                /*
                 *        PRIVATE METHODS
                 *
                 */

                function chatlog (msg, msg2) {
                        if (state.flags.verbose) {
                                if(typeof msg === "object") {
                                        if (JSON) {
                                                console.dir(JSON.parse(JSON.stringify(msg)));
                                        }
                                        else {
                                                console.dir(msg);
                                        }
                                }
                                else {
                                        if (!msg2) { msg2 = ""; }
                                        console.log('[' + state.initCounter + '] ' + msg, msg2);
                                }
                        }
                }

                function logInit () {
                        chatlog("=============");
                        chatlog("chatController version " + state.version + ": initializing...");
                        chatlog("=============");
                        chatlog("log message prefixes:");
                        chatlog("  0.x -- init()/prepChain()");
                        chatlog("  1.x -- determineLocale()");
                        chatlog("  1.x -- determineAccessLevel()");
                        chatlog("  2.x -- loadButtonMap()");
                        chatlog("  3.x -- loadDeploymentJS()");
                        chatlog("  4.x -- wireButtons()");
                        chatlog("  5.x -- checkQueue()");
                        chatlog("-------------");
                }  // end logInit()

                // uses code straight from jQuery, with minor mods
                function getScript (params) {
                        var head   = document.getElementsByTagName("head")[0],
                                script = document.createElement("script"),
                                done   = false;

                        script.src = params.url;
                        if (params.scriptCharset) {
                                script.charset = params.scriptCharset;
                        }

                        // Attach handlers for all browsers
                        script.onreadystatechange = function(){
                                if ( !done && (!this.readyState ||
                                     this.readyState === "loaded" ||
                                     this.readyState === "complete")
                                ) {
                                        done = true;
                                        params.success();
                                        //complete();
                                        head.removeChild( script );
                                }
                        };
                        script.onload = script.onreadystatechange; // jslint did not like chained assignments...

                        head.appendChild(script);
                } // end getScript()

                // define a simple XHR handler to gain independence from jQuery
                function getJson (params) {
                        var xhr  = false,
                                resp = '';

                        try { xhr = new XMLHttpRequest(); } // most browsers
                        catch (ignore) {
                                // must be IE
                                try { xhr = new ActiveXObject("Msxml2.XMLHTTP"); } // IE
                                catch (ignore) { // e2
                                        // must be _old_ IE
                                        try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } // try an older version
                                        catch (ignore) { // e3
                                                return false;
                                        }
                                }
                        }
                        if (!xhr) { return false; }

                        if (typeof params.success !== 'function') { params.success = function () {}; }
                        if (typeof params.error   !== 'function') { params.error   = function () {}; }

                        xhr.onreadystatechange = function() {
                                if (xhr.readyState === 4) {
                                        if (xhr.status === 200) {
                                                try { resp = JSON.parse(xhr.responseText); }
                                                catch (syntaxError) {
                                                        return params.error(xhr, 'parsererror', syntaxError.message);
                                                }
                                                return params.success(resp,xhr.statusText,xhr);
                                        }
                                        else {
                                                return params.error(xhr,xhr.statusText,'error');
                                        }
                                }
                        };

                        xhr.open("GET", params.url, true);
                        //xhr.open('GET', params.url + '?' + new Date().getTime(), true);

                        if (params.hasOwnProperty('contentType')) {
                                xhr.setRequestHeader('Content-Type', 'application/json');
                        }

                        if (params.hasOwnProperty('authority')) {
                                xhr.setRequestHeader("Authority", params.authValue);
                        }

                        if (params.hasOwnProperty('withCredentials')) {
                                xhr.withCredentials = true;
                        }

                        if (params.headers) {
                                // jslint made me do this instead of 'for in'... *sigh*
                                Object.keys(params.headers).forEach(
                                        function(key) {
                                                xhr.setRequestHeader(key, params.headers[key]);
                                        }
                                );
                        }

                        xhr.send(null);
                        return xhr;
                } // end getJson()

                // jQuery off() replacement...
                function removeEvent (node, type, handler) {
                        if (!node) { return; }
                        if (!type && node.length) {
                                handler = node[2];
                                type    = node[1];
                                node    = node[0];
                        }

                        if (node.detachEvent) {
                                node.detachEvent('on'+type, handler);
                        }
                        else {
                                node.removeEventListener(type, handler);
                        }
                }

                // jQuery on() replacement...
                function addEvent (node, type, handler, state) {
                        if (!type && node.length) {
                                state   = node[3];
                                handler = node[2];
                                type    = node[1];
                                node    = node[0];
                        }
                        chatlog("begin addEvent() -- checking on attachEvent for node " + node);
                        if (typeof node.attachEvent !== 'undefined') {
                                chatlog("-- attachEvent exists, calling it");
                                node.attachEvent('on'+type, handler);
                        }
                        else {
                                chatlog("-- no attachEvent, using addEventListener instead");
                                node.addEventListener(type, handler);
                        }

                        if (state) {
                                state.events.push([node,type,handler]);
                        }
                }


                function setCookie (args) {
                        // LEGACY - support old signature (string, string[, int])
                        if (!args.cookieName) {
                                args = {cookieName: args, cookieValue: arguments[1]};
                                if (arguments.length > 2) { args.days = arguments[2]; }
                        }

                        var expireStr = '';
                        var pathStr = '';
                        var domainStr = '';
                        var msecs = parseInt(args.msecs);
                        if (isNaN(msecs) && args.days) {
                                msecs = args.days * 24 * 60 * 60 * 1000;
                        }

                        if (!isNaN(msecs)) {
                                var ex = new Date();
                                ex.setTime(ex.getTime() + msecs);
                                expireStr = "; expires=" + ex.toUTCString();
                        }
                        if (args.path) {
                                pathStr = "; path=" + args.path + ";";
                        } else {
                                pathStr = "; path=/;";
                        }
                        if (args.domain) { domainStr = "; domain=" + args.domain; }
                        try {
                                document.cookie = args.cookieName
                                        + "="
                                        + escape(args.cookieValue)
                                        + expireStr
                                        + pathStr
                                        + domainStr;
                        } catch (e) {
                                return false;
                        }
                        return true;
                }

                function getCookie (args) {
                        // LEGACY - if args is a string and not an object
                        if (!args.cookieName) { args = { cookieName: args }; }

                        var frags = document.cookie.split(/\s*;\s*/),
                            dict = {},
                            frag,
                            ioe,
                            name,
                            val,
                            i;

                        for (i = 0; i < frags.length && (frag = frags[i]); i++) {
                                ioe = frag.indexOf('='); // expecting "foo=bar"
                                if (ioe < 0) { continue; }
                                name = unescape(frag.substring(0, ioe));
                                val = unescape(frag.substring(ioe + 1));
                                dict[name] = val;
                        }

                        return dict[args.cookieName] || "";
                }

                function getParameter (param, url) {
                        param = param + "=";
                        var qs;
                        if (url) {
                                qs = url.slice(url.indexOf('?') + 1);
                        }
                        qs = qs || window.location.search;
                        var val = "";
                        var start = qs.indexOf(param);
                        if (start != -1) {
                                start += param.length;
                                var end = qs.indexOf("&", start);
                                if (end == -1) {
                                        end = qs.length;
                                }
                                val = qs.substring(start,end);
                        }
                        return val;
                }

                // grab any meaningful querystring params, ignore the rest
                function parseParams () {
                        var frags, keyval, i;
                        if (state.flags.gotParams) {
                                logInit();
                                chatlog("[0.1] -- begin parseParams(), already ran once, exiting.");
                                return;
                        }

                        frags = location.search.substr(1).split("&");
                        for (i = 0; i < frags.length; i+=1) {
                                keyval = frags[i].split("=");

                                if (activeParams[keyval[0]]) {
                                        activeParams[keyval[0]](keyval[1]);
                                        if (keyval[0] === "verbose") {
                                                logInit();
                                                chatlog("[0.0] begin init()", selector);
                                                chatlog("[0.0] -- calling parseParams()");
                                                chatlog("[0.1] -- begin parseParams()...");
                                        }
                                }

                                chatlog("[0.1]    -- parsed chunk #" + i + " ('" + frags[i] + "')");
                        }

                        if (state.override.jsonUrl) {
                                state.buttonMapUrl = state.override.jsonUrl;
                                chatlog("[0.1]    -- jsonOverride qparam set, changing buttonMapUrl");
                        }
                        chatlog("[0.1]    -- buttonMapUrl is [" + state.buttonMapUrl + "]");

                        state.flags.gotParams = true;   // make the method a one-timer
                        chatlog("[0.1] -- end parseParams()...");
                } // end parseParams()

                function prepareProactiveModal () {
                        // the first proactive modal node must be moved from within the component and attached to the body element
                        // and any subsequent proactive modals should be deleted
                        var i, proactiveNodes = document.querySelectorAll(".c2c-proactive-modal");

                        chatlog("[4.1] -- begin prepareProactiveModal()...");
                        chatlog("[4.1]    -- manipulating proactive modals...");
                        for (i = 0; i < proactiveNodes.length; i+=1) {
                                if (i === 0) {
                                        chatlog("[4.1]    " + (i+1) + ": moving first proactive modal to body element");
                                        document.querySelector('body').appendChild(proactiveNodes[i]);
                                }
                                else {
                                        chatlog("[4.1]    " + (i+1) + ": removing proactive modal #" + (i+1));
                                        proactiveNodes[i].parentNode.removeChild(proactiveNodes[i]);
                                }
                        }
                        chatlog("[4.1] -- end prepareProactiveModal()");
                }  // end prepareProactiveModal()

                function startTimer (key) {
                        if (! state.timestamp.hasOwnProperty(key)) {
                                state.timestamp[key] = {};
                        }
                        state.timestamp[key].start = new Date();
                }

                function stopTimer (key) {
                        state.timestamp[key].stop = new Date();
                }

                function reportInterval (key, prefix, indent) {
                        var start = state.timestamp[key].start,
                                stop  = state.timestamp[key].stop,
                                i;

                        state.timestamp[key].total = (stop - start);

                        if (prefix) {
                                prefix = '[' + prefix + '] ';
                        }
                        else {
                                prefix = '';
                        }

                        if (indent) {
                                for (i = 0; i < indent; i+=1) {
                                        prefix += '   ';
                                }
                        }

                        //chatlog("   -- start time: " + start.toISOString());
                        //chatlog("   -- stop time:  " + stop.toISOString());

                        chatlog(prefix + "-- " + key + " start time: " + start.toString() + " and " + start.getMilliseconds() + " milliseconds");
                        chatlog(prefix + "-- " + key + " stop time:  " + stop.toString()  + " and " + stop.getMilliseconds() + " milliseconds");
                        chatlog(prefix + "-- " + key + " total time: " + state.timestamp[key].total + " millisec");
                }

                function finish () {
                        stopTimer("all");
                        if (state.flags.verbose) {
                                chatlog("-------------");
                                chatlog("-- begin finish(); total execution timing info:");
                                reportInterval("all","",1);
                                chatlog("-- end finish()");
                                chatlog("----> exiting current execution chain, need to check queue");
                        }
                } // end finish()

                function loadButtonMap (ignore) {
                        return new Promise(function(resolve, reject) {
                                chatlog("-------------");
                                chatlog("[2.0] begin loadButtonMap()");
                                if (state.flags.mapperJsonLoaded) {
                                        chatlog("[2.0] -- button mapper JSON is already loaded, done");
                                        chatlog("[2.0] end loadButtonMap()");
                                        resolve(state);
                                        return;
                                }

                                startTimer("json");
                                chatlog("[2.0] -- calling ajax() to get buttonMapper.json from " + state.buttonMapUrl);
                                // QUESTION: would we want ability to turn this off, e.g., if component pulls in JSON server-side as it is being rendered...
                                getJson({
                                        url: state.buttonMapUrl,
                                        success: function(buttonMap) {  // statusStr, xhr
                                                var locale;
                                                stopTimer("json");

                                                chatlog("[2.1] -- begin callback for loadButtonMap()'s getJson()");
                                                reportInterval("json", "2.1", 1);

                                                if (!buttonMap || typeof buttonMap !== 'object') {
                                                        chatlog("[2.1]    -- ERROR, buttonMap is not defined or is empty!");
                                                        chatlog(buttonMap);
                                                        chatlog("[2.1] -- end callback for loadButtonMap()'s getJson()");
                                                        reject("ERROR, buttonMap is not defined or is empty!");
                                                }

                                                if (!buttonMap.CONFIG || typeof buttonMap.CONFIG !== 'object') {
                                                        chatlog("[2.1]    -- ERROR, buttonMap CONFIG is not defined or is empty!");
                                                        chatlog(buttonMap);
                                                        chatlog("[2.1] -- end callback for loadButtonMap()'s getJson()");
                                                        reject("ERROR, buttonMap CONFIG is not defined or is empty!");
                                                }

                                                // Question: stash entire buttonMap into Chat or not?
                                                state.envConfig = buttonMap.CONFIG;
                                                chatlog("[2.1]    -- LiveAgent config settings from JSON:", state.envConfig);
                                                chatlog(state.envConfig);
                                                state.flags.mapperJsonLoaded = true;

                                                chatlog("[2.1]    -- getting button info from buttonMapper");
                                                if (buttonMap[state.locale.chosen]) {
                                                        chatlog("[2.1]    -- found an entry for calculated locale [" + state.locale.chosen + "]");
                                                        locale = state.locale.chosen;
                                                }
                                                else if (state.locale.page && buttonMap[state.locale.page]) {
                                                        chatlog("[2.1]    -- no entry for calculated locale [" + state.locale.chosen + "]");
                                                        chatlog("[2.1]    ----> using page locale [" + state.locale.page + "]...");
                                                        locale = state.locale.page;
                                                }
                                                else {
                                                        // UC7: default to en_US
                                                        chatlog("[2.1]    -- ALERT: UC7 -- no button settings for calculated OR page locale");
                                                        chatlog("[2.1]    ----> using 'en_US' instead");
                                                        locale = 'en_US';
                                                }

                                                // pull current buttonids from map here and pass those to wireButtons()...
                                                state.buttonInfo = {
                                                        'buttonId':    buttonMap[locale]["button-id"],
                                                        'proactiveId': buttonMap[locale]["proactive-id"],
                                                        'modalHeight': buttonMap[locale]["survey-height"] || state.envConfig["default-survey-height"],
                                                        'modalWidth':  buttonMap[locale]["survey-width"]  || state.envConfig["default-survey-width"],
                                                        'ecid': buttonMap[locale].ECID,
                                                        'dtid': buttonMap[locale].DTID,
                                                        'ccid': buttonMap[locale].CCID,
                                                        'oid':  buttonMap[locale].OID
                                                };

                                                chatlog("[2.1]    -- buttonId    = [" + state.buttonInfo.buttonId + "]");
                                                chatlog("[2.1]    -- proactiveId = [" + state.buttonInfo.proactiveId + "]");
                                                chatlog("[2.1]    -- modalHeight = [" + state.buttonInfo.modalHeight + "]");
                                                chatlog("[2.1]    -- modalWidth  = [" + state.buttonInfo.modalWidth + "]");
                                                chatlog("[2.1]    -- ecid = [" + state.buttonInfo.ecid + "]");
                                                chatlog("[2.1]    -- dtid = [" + state.buttonInfo.dtid + "]");
                                                chatlog("[2.1]    -- ccid = [" + state.buttonInfo.ccid + "]");
                                                chatlog("[2.1]    -- oid  = [" + state.buttonInfo.oid + "]");
                                                chatlog("[2.1] -- end callback for loadButtonMap()'s ajax()");

                                                resolve(state); // TODO: resolve with a simple object containing buttoninfo...
                                        },

                                        error: function (ignore, statusStr, error) {   // xhr
                                                chatlog("[2.1] ***ALERT***");
                                                chatlog("[2.1] ***ALERT*** -- getJson() of buttonMapper FAILED - possible syntax error in " + state.buttonMapUrl + " ??");
                                                chatlog("[2.1] ***ALERT*** --> statusStr: " + statusStr);
                                                chatlog("[2.1] ***ALERT*** --> error: " + error);
                                                chatlog("[2.1] ***ALERT*** --> Try checking the JSON by pasting it into http://jsonlint.com/");
                                                chatlog("[2.1] ***ALERT***");
                                                reject(error);
                                        }
                                });

                                chatlog("[2.0] ----> finished calling ajax(); look for its callback [2.1] to fire...");
                                chatlog("[2.0] end loadButtonMap()");
                        }); // end Promise
                }   // end 'loadButtonMap()'

                function loadDeploymentJS (chat) {
                        return new Promise(function(resolve, ignore) { // , reject
                                chatlog("-------------");
                                chatlog("[3.0] begin loadDeploymentJS()");

                                if (state.flags.liveAgentJsLoaded) {
                                        chatlog("[3.0] -- deployment js is already loaded, done");
                                        chatlog("[3.0] end loadDeploymentJS()");
                                        resolve(state);
                                        return;
                                }
                                state.flags.liveAgentJsLoaded = true;

                                chatlog("[3.0] -- js needs to be loaded, now calling getScript(" + chat.envConfig.deployment_js + ")");
                                chatlog("[3.0] -- look for its callback [3.1] to fire...");
                                startTimer("deployment");
                                getScript({
                                        url: state.envConfig.deployment_js,
                                        success: function () {  // (data,status,xhr)
                                                stopTimer("deployment");
                                                state.flags.liveAgentJsLoaded = true;

                                                chatlog("[3.1] -- begin callback for loadDeployment()'s getScript(); js load timing:");
                                                reportInterval("deployment", "3.1",1);
                                                if (state.flags.verbose) {
                                                        chatlog("[3.1]    -- verbose is on, so calling liveagent.enableLogging()");
                                                        liveagent.enableLogging();
                                                }
                                                chatlog("[3.1] -- leaving getScript callback (loadDeploymentJS)");
                                                chatlog("[3.1] -- end callback for loadDeployment()'s getScript()");
                                                resolve(state);
                                        }
                                });
                                chatlog("[3.0] end loadDeploymentJS()");
                        }); // end Promise
                } // end loadDeploymentJS()

                function clearUidCache (key) {
                        var uid = null;
                        if (key && JSON) { // crazy MSIE...
                                uid = JSON.parse(localStorage.getItem('userInfoDispatcher'));
                                // be careful, uid (or uid.profile) might still be null
                                if (uid && uid.profile) {
                                        uid.profile[key] = null;
                                        localStorage.setItem('userInfoDispatcher',JSON.stringify(uid));
                                }
                        }
                        else {
                                localStorage.removeItem('userInfoDispatcher');
                        }
                }

                function getMetaValue (name) {
                        var metaNode = document.querySelector('meta[name='+name+']');
                        if (!metaNode) {return "unknown";}
                        return metaNode.getAttribute('content') || "unknown";
                }

                function determineAccessLevel (ignore) { // (chat)
                        return new Promise(function(resolve, reject) {
                                chatlog("-------------");
                                chatlog("[1.0] begin determineAccessLevel()");

                                if (state.flags.accessLevelDetermined) {
                                        chatlog("[1.0] this has already run, entitlement is " + state.entitlement + "; returning...");
                                        resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        chatlog("[1.0] end determineAccessLevel()");
                                        return;
                                }

                                chatlog("[1.0] -- calling userInfoDispatcher.getUserProfile(contactInfo)");
                                chatlog("[1.0] -- look for its callback [1.1] to fire...");
                                cdc.userInfoDispatcher.getUserProfile({
                                        "listOfDataFields": ["contactInfo"], // used to also get 'cps' and 'vps' but do not use them
                                        "callback": function (uid) {
                                                chatlog("[1.1] -- begin callback for userInfoDispatcher.getUserProfile()");
                                                chatlog("[1.1]    -- profile object:", uid);
                                                chatlog(uid);

                                                if (uid.contactInfo && typeof uid.contactInfo === "object") {
                                                        if (uid.contactInfo.accesslevel === "4") {
                                                                state.entitlement = "employee";
                                                        }
                                                        else {
                                                                // TODO: figure out what the other numeric codes map to...
                                                                state.entitlement = uid.contactInfo.accesslevel;
                                                        }
                                                }
                                                else {
                                                        chatlog("[1.1]    -- ALERT! uid.contactInfo is undefined or not an object!");
                                                }

                                                // debug setting to allow entitlement override
                                                if (state.override.entitlement) {
                                                        chatlog("[1.1]    -- user entitlement '" + state.entitlement + "' has been overidden to '" + state.override.entitlement + "'");
                                                        state.entitlement = state.override.entitlement;
                                                }

                                                chatlog("[1.1]    -- user entitlement is '" + state.entitlement + "'");

                                                // UC1: exit condition -- entitlement=employee
                                                if (state.entitlement) {
                                                        if (state.entitlement === "employee" || state.entitlement === 4 || state.entitlement === "4") {
                                                                chatlog("[1.1]    -- user is employee, exiting (Use Case 1)");
                                                                chatlog("[1.1]    -- [to override, use 'entitlementOverride=1' in the querystring]");
                                                                chatlog("[1.1] -- end callback for userInfoDispatcher.getUserProfile()");
                                                                reject("-- user is employee, exiting (Use Case 1)");
                                                                return;
                                                        }
                                                        chatlog("[1.1]    -- user is NOT an employee, continuing (Use Case 2)");
                                                }
                                                chatlog("[1.1] -- end callback for userInfoDispatcher.getUserProfile()");

                                                if (uid.contactInfo && typeof uid.contactInfo === "object") {
                                                        if (uid.contactInfo.accesslevel === "4") {
                                                                state.entitlement = "employee";
                                                        }
                                                        else {
                                                                // TODO: figure out what the other numeric codes map to...
                                                                state.entitlement = uid.contactInfo.accesslevel;
                                                        }
                                                }
                                                else {
                                                        chatlog("[1.1]    -- ALERT! uid.contactInfo is undefined or not an object!");
                                                }

                                                state.flags.accessLevelDetermined = true;
                                                resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        }
                                }); // end cdc.userInfoDispatcher.getUserProfile()

                                chatlog("[1.0] end determineAccessLevel()");
                        }); // end Promise
                } // end determineAccessLevel()

                // figure out the user's locale country and language codes, to derive buttonMapper key
                function determineLocale (ignore) { // (chat)
                        return new Promise(function(resolve, reject) {
                                chatlog("-------------");
                                chatlog("[1.0] begin determineLocale()");

                                if (state.flags.localeDetermined) {
                                        chatlog("[1.0] this has already run, final locale is: '" + state.locale.chosen + "'; returning...");
                                        resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        chatlog("[1.0] end determineLocale()");
                                        return;
                                }

                                // grab page locale info from page's meta tags
                                //  <meta name="language" content="en"  />
                                //  <meta name="country" content="US"  />
                                state.locale.country.page = getMetaValue('country');
                                state.locale.lang.page    = getMetaValue('language');
                                state.locale.page         = state.locale.lang.page + '_' + state.locale.country.page;
                                chatlog("[1.0] -- page locale=[" + state.locale.page + "]");

                                // in test environments and sandboxes, uid fails because the login state is unobtainable
                                state.currAuthStatus = cdc.c2c.authStatus;
                                cdc.c2c.authStatus  = "valid"; // the other useful value is "anonymous"
                                chatlog("[1.0] -- curr authStatus is: " + state.currAuthStatus);

                                // weird edge case for testers switching locales, but uid caches locale info...
                                if (state.flags.clearCache) {
                                        chatlog("[1.0] -- UID cache before clearing:");
                                        chatlog(JSON.parse(localStorage.getItem('userInfoDispatcher')));
                                        chatlog("[1.0] -- clearing userInfoDispatcher localStorage cache before calling userInfoDispatcher.getUserProfile()");
                                        clearUidCache();
                                }

                                chatlog("[1.0] -- calling userInfoDispatcher.getUserProfile(locale)");
                                chatlog("[1.0] -- look for its callback [1.1] to fire...");
                                cdc.userInfoDispatcher.getUserProfile({
                                        "listOfDataFields": ["locale"], // used to also get 'cps' and 'vps' but do not use them
                                        "callback": function (uid) {
                                                cdc.c2c.authStatus = state.currAuthStatus;
                                                chatlog("[1.1] -- begin callback for userInfoDispatcher.getUserProfile()");
                                                chatlog("[1.0]    -- curr authStatus is: " + cdc.c2c.authStatus);
                                                chatlog("[1.1]    -- profile object:", uid);
                                                chatlog(uid);

                                                if (uid.locale && typeof uid.locale === "object") {
                                                        state.locale.lang.visitor    = uid.locale.language_code || "";
                                                        state.locale.country.visitor = uid.locale.country_code  || "";

                                                        if (uid.locale.lang_unknown) {
                                                                chatlog("[1.1]    -- unknown language flag set by UID");
                                                                chatlog("[1.1]       -- UID could not find a lang for '" + state.locale.country.visitor + "'");
                                                                chatlog("[1.1]       -- UID defaulted to using '" + state.locale.lang.visitor + "'");
                                                        }

                                                }
                                                else {
                                                        chatlog("[1.1]    -- ALERT! uid.locale is undefined or not an object!");
                                                }

                                                chatlog("[1.1]    -- user's language=[" + state.locale.lang.visitor + "]");
                                                chatlog("[1.1]    -- user's country=[" + state.locale.country.visitor + "]");

                                                if (state.locale.lang.visitor && state.locale.country.visitor) {
                                                        state.locale.visitor = state.locale.lang.visitor + "_" + state.locale.country.visitor;
                                                        chatlog("[1.1]    -- user's locale=[" + state.locale.visitor + "]");
                                                        chatlog("[1.1]    ----> UC4 and UC8: use visitor's locale for button lookup");
                                                        state.locale.chosen = state.locale.visitor;
                                                }
                                                else {
                                                        state.locale.visitor = "";
                                                        chatlog("[1.1]    -- cannot determine user's locale!");
                                                        chatlog("[1.1]    ----> UC3 and UC9: use page locale for button lookup");
                                                        state.locale.chosen = state.locale.page;
                                                }

                                                if (state.override.locale) {
                                                        chatlog("[1.1]    -- locale override has been triggered [" + state.override.locale + "]");
                                                        state.locale.chosen = state.override.locale;
                                                }

                                                chatlog("[1.1]    -- final locale is: '" + state.locale.chosen + "'");
                                                chatlog("[1.1] -- end callback for userInfoDispatcher.getUserProfile()");

                                                state.flags.localeDetermined = true;
                                                resolve(state); // success, can proceed in Promise chain to determineAccessLevel
                                        }
                                }); // end cdc.userInfoDispatcher.getUserProfile()

                                chatlog("[1.0] end determineLocale()");
                        }); // end Promise
                } // end determineLocale()

                function resolveId (chatNode, id, type) {
                        var dataSelector = "data-c2c-buttonid",
                                newId;

                        if (type === "proactive") {
                                dataSelector = "data-c2c-proactive-buttonid";
                        }

                        newId = chatNode.getAttribute(dataSelector);

                        if (newId) {
                                chatlog("[4.2]    --> UC5: found markup override " + type + "-id '" + newId + "', overriding old id '" + id + "'");
                                id = newId;
                        }

                        if (state.override[type + "Id"]) {
                                chatlog("[4.2]    --> found querystring override " + type + "-id '" + state.override[type + "Id"] + "', overriding old id '" + id + "'");
                                id = state.override[type + "Id"];
                        }

                        return id;
                } // end resolveId()

                /* Read the querystring for a value override
                 * If there is a querystring value, set it into the cookie for 24 hours
                 *  If there is not querystring value, see if our cookie has any non-expired data
                 */
                function readOverrideValues() {
                        chatlog("[0.1] Reading Override Values from Querystring or Cookie");
                        var ids = ["dtid", "ecid", "ccid", "oid"];
                        var overrideIds = {};
                        for (var index = 0; index < ids.length; index++) {
                                var key = ids[index];
                                var value = getParameter(key);
                                if (value) {
                                        setCookie({cookieName: key, cookieValue: value, days: 1, domain : "cisco.com"});
                                }
                                else {
                                        value = getCookie(key);
                                }
                                if (value) {
                                        chatlog("[0.1] Key:" + key + " found with a value of " + value);
                                        overrideIds[key] = value;
                                }
                                else {
                                        chatlog("[0.1] No override found for Key:" + key);
                                }
                        }
                        return overrideIds;
                }

                /*  1. it must scan the page for the existance of chat component
                 *
                 *  - the microformat defines a wrapper class of 'c2c-component' around each chat component
                 *  - http://gitlab.cisco.com/id-only/liveagentmeta/blob/master/API/component-microformat.txt
                 *  - if at least one chat component is found, must pull in salesforce deployment js
                 *
                 */

                function wireSingleButton (index, chatNode) {
                        var nodeNum = index;
                        return new Promise(function(resolve, ignore) { // , reject
                                chatlog("[4.2] ----");
                                chatlog("[4.2] -- begin wireSingleButton() for chat node #" + (nodeNum+1) + ": ", chatNode);

                                // look for override button ids in chat nodes
                                var wireParams = {
                                                'buttonId'    : resolveId(chatNode, state.buttonInfo.buttonId,'button'),
                                                'proactiveId' : resolveId(chatNode, state.buttonInfo.proactiveId,'proactive'),
                                                'modalHeight' : chatNode.getAttribute("data-c2c-survey-height") || state.buttonInfo.modalHeight,
                                                'modalWidth'  : chatNode.getAttribute("data-c2c-survey-width")  || state.buttonInfo.modalWidth,
                                                'ecid'    : state.buttonInfo.ecid,
                                                'dtid'    : state.buttonInfo.dtid,
                                                'ccid'    : state.buttonInfo.ccid,
                                                'oid'     : state.buttonInfo.oid
                                        },
                                        query = [
                                                "deployment_id=" + state.envConfig.deployment_id,
                                                "org_id="        + state.envConfig.org_id,
                                                "headers="       + "X-LIVEAGENT-API-VERSION::"  + state.envConfig.rest_version,
                                                // SFDC uses a silly dotted param name and pseudo-json value
                                                'Availability.ids=\['  + wireParams.buttonId + '\]'
                                                //'button_ids='    + wireParams.buttonId
                                        ],
                                        lastId,
                                        restReqUrl;

                                chatlog("[4.2]    -- buttonId is: " + wireParams.buttonId);

                                // derive data-c2c-* attributes or querystring param overrides
                                var value = chatNode.getAttribute("data-c2c-keycode");
                                if (value) {
                                        wireParams.keyCode = value;
                                        chatlog("[4.2]    -- keyCode is: " + wireParams.keyCode);
                                }

                                var ids = ["dtid", "ecid", "ccid", "oid"];
                                for (var index = 0; index < ids.length; index++) {
                                        var key = ids[index];
                                        value = window.threeIdOverrideIds[key] || chatNode.getAttribute("data-c2c-"+key) || wireParams[key];
                                        if (value) {
                                                wireParams["data-c2c-"+key] = value;
                                                chatlog("[4.2]    -- data-c2c-" + key + " is: " + wireParams["data-c2c-"+key]);
                                        }
                                }

                                if (state.flags.verbose) {
                                        query.push("verbose=1");
                                }

                                // If a previous iteration wired up the modal, then proactiveModal will be true
                                // and we can skip by nulling the proactiveId

                                if (state.flags.proactiveModalWired) {
                                        chatlog("[4.2]    -- this proactive modal will not be wired, previous modal already wired");
                                        wireParams.proactiveId = null;
                                }

                                if (wireParams.proactiveId) {
                                        // UC10: Proactive Chat Rules - no proactive chat if visitors url is search.cisco.com/search
                                        if (location.host === "search.cisco.com" && location.pathname.match(/^\/(search|xsrch)/)) {
                                                chatlog("[4.2]    -- proactive chat: UC10 - visit is from tools.cisco.com/search; setting proactiveId to null");
                                                wireParams.proactiveId = null;
                                        }
                                        else {
                                                chatlog("[4.2]    -- proactive modal is about to be wired");
                                        }
                                }

                                if (! wireParams.buttonId.match(/,/)) {
                                        chatlog("[4.2]    -- id is not a list, proceeding.");
                                        resolve(
                                                function() {
                                                        state.liveAgentAdapter.setup({
                                                                'chatNode'  : chatNode,
                                                                'state'     : state,
                                                                'wireParams': wireParams
                                                        });
                                                }
                                        );
                                        return;
                                }

                                chatlog("[4.2]    -- id is a list, need to find first active id via REST API");
                                lastId = (wireParams.buttonId.split(',')).pop(); // or .shift() to get first...

                                // until the web service proxy is available, log this type of call via codebeacon as per natyoung
                                chatlog("[4.2]    -- calling codeBeacon, sig=c2c.proxy.call, href=" + location.href);
                                cdc.debug.codeBeacon ({
                                        message: "button_id list '" + wireParams.buttonId + "' on page '" + location.href + "'",
                                        signature: "c2c.proxy.call",
                                        warnUserInStage: false,
                                        beaconInStage: true
                                });

                                if (! state.envConfig.rest_url) {
                                        chatlog("[4.2]    -- NOTICE: buttonMapper has no url value for REST Availability API");
                                        chatlog("[4.2]    -- using last id in list instead: " + lastId);
                                        resolve(
                                                function() {
                                                        wireParams.buttonId = lastId;
                                                        state.liveAgentAdapter.setup({
                                                                'chatNode'  : chatNode,
                                                                'state'     : state,
                                                                'wireParams': wireParams
                                                        });
                                                }
                                        );
                                        return;
                                }

                                restReqUrl = state.envConfig.rest_url + '?' + query.join('&');
                                chatlog("[4.2]    -- with these buttonIDs: " + wireParams.buttonId);
                                chatlog("[4.2]    -- and this url: " + restReqUrl);
                                startTimer("availSvc_" + index);

                                getJson({
                                        url: restReqUrl,
                                        //headers: { "X-LIVEAGENT-API-VERSION": state.envConfig.rest_version },
                                        success: function (resp, ignore, xhr) {  // statusStr
                                                var found  = false,
                                                        i;

                                                stopTimer("availSvc_" + index);

                                                chatlog("[4.3] -- begin callback for availability service; chat node #" + (index+1) + "...");
                                                reportInterval("availSvc_" + index,"4.3",1);
                                                chatlog("[4.3]    -- result is", resp);

                                                if (xhr && xhr.status === 404) {
                                                        chatlog ("[4.3]    -- Err: 404 Not Found, setting buttonId to final id in list: '" + lastId + "'");
                                                        wireParams.buttonId = lastId;
                                                }
                                                else if (resp === "") {
                                                        chatlog("[4.3]    -- Err: Body is empty; setting buttonId to final id in list: '" + lastId + "'");
                                                        wireParams.buttonId = lastId;
                                                }
                                                else {
                                                        resp = resp.messages[0].message.results;

                                                        chatlog("[4.3]    -- Availability portion (look for 'isAvailable' property) ", resp);
                                                        chatlog(JSON.stringify(resp) + "\n");

                                                        // just grab the first true; if none are true send back the last one?
                                                        for (i = 0; i < resp.length; i+=1) {
                                                                if (resp[i].isAvailable) {
                                                                        chatlog("[4.3]    -- found an available agent, setting buttonId to '" + resp[i].id + "'");
                                                                        wireParams.buttonId = resp[i].id;
                                                                        found = true;
                                                                        break;
                                                                }
                                                        }

                                                        if (! found) {
                                                                chatlog("[4.3]    -- no active agents found, setting buttonId  " +
                                                                        "to final id in list: '" + lastId + "'");
                                                                //wireParams.buttonId = resp[(resp.length - 1)].id;
                                                                wireParams.buttonId = lastId;
                                                        }
                                                }

                                                chatlog("[4.3]    -- prepping for later LiveAgentAdapter.setup() for chat node #" + (index+1) + "...");
                                                chatlog("[4.3] -- end callback for availability service; chat node #" + (index+1) + "...");

                                                // making this an anon function to be called later,
                                                // Promise.all() will add to array of functions passed to then()
                                                resolve(
                                                        function() {
                                                                state.liveAgentAdapter.setup({
                                                                        'chatNode'  : chatNode,
                                                                        'state'     : state,
                                                                        'wireParams': wireParams
                                                                });
                                                        }
                                                );
                                        },
                                        error: function (ignore, statusStr, error) {   // xhr
                                                chatlog("[4.3] -- in callback for availability service; chat node #" + (index+1) + "...");
                                                chatlog('[4.3]    -- ERROR! ' + statusStr + ' for ' + state.envConfig.rest_url + '?' +
                                                        wireParams.buttonId + ': error=[' + error + ']', true);
                                                chatlog("[4.3]    -- setting buttonId to final id in list: '" + lastId + "'");
                                                wireParams.buttonId = lastId;
                                                chatlog("[4.3] -- end callback for availability service; chat node #" + (index+1) + "...");
                                                resolve(wireParams);
                                                return wireParams;
                                        }
                                }); // getJson()
                                chatlog("[4.2] -- end wireSingleButton() for chat node #" + (index+1));
                        }); // end new Promise
                } // end function wireSingleButton()

                function wireButtons (ignore) { // chat
                        return new Promise(function(resolve, reject) {
                                var wirePromiseList = [],
                                        d;

                                chatlog("-------------");
                                chatlog("[4.0] begin wireButtons()");
                                chatlog("[4.0] -- buttonId=[" + state.buttonInfo.buttonId + "]");
                                chatlog("[4.0] -- proactiveId=[" + state.buttonInfo.proactiveId + "]");
                                chatlog("[4.0] -- number of chat nodes=[" + state.chatNodes.length + "]");

                                // move the first proactive modal (if it exists) to the body element, nuke subsequent modals
                                prepareProactiveModal();

                                // process chatNodes as a collection of Promises
                                chatlog("[4.0] -- processing chat nodes into array of Promises that call wireSingleButton()...");

                                // create array of Promises to hand off to Promise.all() so Controller execution blocks on
                                // the completion of potentially asynch wiring
                                for (d = 0; d <  state.chatNodes.length; d+=1) {
                                        //chatlog("[4.0]    -- chatNode #" + d + " = ", state.chatNodes[d]);
                                        wirePromiseList.push(wireSingleButton(d, state.chatNodes[d]));
                                }
                                chatlog("[4.0] -- done processing chat nodes; Promise array: =", wirePromiseList);

                                // all() takes an array of promises, and waits until they are done to yield an array of the resolved promises
                                chatlog("[4.0] -- passing Promise array to Promise.all()...");
                                Promise.all(wirePromiseList).then(
                                        function (agentCallbacks) {
                                                var ind;
                                                chatlog("[4.0] -- back from wireSingleButton() calls, results list: ", agentCallbacks);
                                                for (ind = 0; ind < agentCallbacks.length; ind+=1) {
                                                        chatlog("[4.0] -- calling LiveAgentAdapter.setup() for chat node #" + (ind+1) + "...");
                                                        agentCallbacks[ind](); // this function was created in wireSingleButton(), which reolved its Promise by returning this function
                                                }
                                                finish();
                                                resolve(state);
                                        }
                                ).then(  // originally used Promise.catch(onRejected) here, but 'catch' is a keyword; then(undefined,onRejected) is equiv
                                        null,
                                        function (reason) {
                                                chatlog("[4.0] -- back from wireSingleButton() calls, something erred: " + reason);
                                                reject(reason);
                                        }
                                ); // end then()
                                chatlog("[4.0] end wireButtons()");
                        }); // end new Promise
                } // end function wireButtons

                function loopback () {
                        var buttonMsg = "Debug mode is set to '" + state.debug + "'.\n",
                                buttonNodes,
                                activeDisplay,
                                inactiveDisplay,
                                i;

                        if (state.debug === "active") {
                                chatlog("debug=active: show active, hide inactive");
                                activeDisplay   = '';
                                inactiveDisplay = 'none';
                                buttonMsg      += "Normally clicking the active button would bring up the pre-chat window from SFDC";
                        }
                        else if (state.debug === "inactive") {
                                chatlog("debug=inactive: hide active, show inactive");
                                activeDisplay   = 'none';
                                inactiveDisplay = '';
                                buttonMsg      += "\nNormally clicking the inactive button would traverse a link";
                        }
                        else if (state.debug === "all") {
                                chatlog("debug=all: show active, show inactive");
                                activeDisplay   = '';
                                inactiveDisplay = '';
                        }

                        // set display on active wrapper
                        buttonNodes = document.querySelectorAll(".c2c-active");
                        for (i = 0; i < buttonNodes.length; i+=1) {
                                buttonNodes[i].style.display = activeDisplay;
                        }

                        // set display on inactive wrapper
                        buttonNodes = document.querySelectorAll(".c2c-inactive");
                        for (i = 0; i < buttonNodes.length; i+=1) {
                                buttonNodes[i].style.display = inactiveDisplay;
                        }

                        // silly jslint prohibits making functions in a loop
                        function alertClick (msg) {
                                return function () {
                                        alert(msg);
                                        return false;
                                };
                        }

                        // now set a click handler on the 'button' to pop up an alert
                        buttonNodes = document.querySelectorAll(".c2c-button");
                        for (i = 0; i < buttonNodes.length; i+=1) {
                                addEvent(buttonNodes[i],"click", alertClick(buttonMsg), state);
                        }

                        chatlog("debug flag set, now exiting...");
                } // end loopback()


                // parse querystring and populate Chat.debug and Chat.flags.verbose
                //
                // Note: verbose will not be defined until parseParams() runs,
                //       so any calls to chatlog() before then will be no-ops

                function prepChain (selector) {
                        return new Promise(function(resolve, reject) {
                                chatlog("[0.3]    -- begin prepChain()");
                                if (!selector) {
                                        selector = 'body';
                                }

                                if (state.initCounter > 25) {
                                        chatlog("[ALERT] -- recursion alert!");
                                        reject('possible infinte recursion?');
                                }

                                state.initCounter += 1;
                                startTimer("all");

                                // get the chat nodes on this page, if any; NOTE: run on AJAXed content too
                                if (typeof selector === "string") {
                                        state.chatNodes = document.querySelectorAll(selector + " .c2c-component");
                                }
                                else {
                                        state.chatNodes = selector.querySelectorAll('.c2c-component');
                                }

                                // look for exit conditions before loading, whacking, and wiring...
                                chatlog("[0.3]       -- looking for exit conditions... (exit flag, debug flag, or no c2c components on page)");
                                if (state.flags.exit) {
                                        chatlog("[0.3]       ----> 'exit' param set, exiting.");
                                        chatlog("[0.3]    -- end prepChain()");
                                        reject("-- 'exit' param set, exiting.");
                                        return;
                                }

                                // the first real exit condition is if there are no chat components on the page...
                                if (! state.chatNodes.length) {
                                        chatlog("[0.3]       ----> no chat components on page, exiting.");
                                        chatlog("[0.3]    -- end prepChain()");
                                        finish();
                                        reject("-- no chat components on page, exiting.");
                                        return;
                                }

                                if (state.debug) {
                                        chatlog("[0.3]       ----> debug flag set ('" + state.debug + "'), skipping service call and calling loopback()");
                                        chatlog("[0.3]    -- end prepChain()");
                                        loopback();
                                        reject("-- debug flag set, skipping service call and calling loopback()");
                                        return;
                                }

                                chatlog("[0.3]       -- Found " + state.chatNodes.length + " chat components on page.");

                                // spin up a LiveAgentAdapter instace
                                //   -- NOTE: depends on JSON file being loaded first, for service URL
                                if (!state.liveAgentAdapter) {
                                        chatlog("[0.3]       -- creating LiveAgentAdapter instance for use downstream");
                                        state.liveAgentAdapter = new LiveAgentAdapter(chatlog, addEvent, getCookie);
                                }

                                // time to whack and wire!
                                // now call userInfoDispatcher to get entitlement and locale info about the user
                                chatlog("[0.3]       ----> no exit conditions found, proceeding with chat setup");
                                chatlog("[0.3]    -- end prepChain()");
                                resolve(state);
                        }); // end new Promise
                } // end 'prepChain()'

                // jslint does not like execPromiseChain() called before it is defined
                // so here is a prototype to uncomment temporarily
                // NOTE, also uncomment the alternate line at execPromiseChain below
                /*
                 function execPromiseChain() {
                 chatlog("[0.2] -- begin EMPTY execPromiseChain() -- ERROR!");
                 }
                 */

                function checkQueue () {
                        return new Promise(function(resolve, ignore) { // , reject
                                //if (state.initCounter > 25) {
                                //   chatlog("[ALERT] -- recursion alert!");
                                //   reject('possible infinte recursion?');
                                //}

                                chatlog("-------------");
                                chatlog("[5.0] begin checkQueue()...");
                                if (state.initQ.length) {
                                        chatlog("[5.0] -- execution queue has an item, calling execPromiseChain()", state.initQ);
                                        //chatlog(state.initQ);
                                        chatlog("[5.0] end checkQueue()");
                                        execPromiseChain(state.initQ.shift());
                                }
                                else {
                                        chatlog("[5.0] -- execution queue is empty, done.");
                                        state.flags.initRunning = false;
                                        chatlog("[5.0] end checkQueue()");
                                        chatlog("----> EXIT CHAT CONTROLLER");
                                        chatlog("=============");
                                }
                                resolve(state);
                        }); // end Promise
                }

                // any reject()s in prepChain() will come here; they should checkQueue() for ajaxed stuff Q'ed up
                function logErrorMessage (error) {
                        chatlog('Interruption in chained Promises: ', error);
                        finish();
                        checkQueue();
                }

                //
                // jslint does not like execPromiseChain() called before it is defined
                // so uncomment the following line and comment the function declaration line...
                // AND add a semicolon below. and cross your fingers and wiggle your toes!
                // this.execPromiseChain = function (selector) {
                // NOTE, also uncomment the alternate line at execPromiseChain below

                // using chained Promises for asynch operations; see comment above about jslint and execPromiseChain...
                function execPromiseChain (selector) {
                        chatlog("[0.2] -- begin execPromiseChain(), calling prepChain()...");
                        prepChain(selector)
                                .then(determineLocale)
                                .then(determineAccessLevel)
                                .then(loadButtonMap)
                                .then(loadDeploymentJS)
                                .then(wireButtons)
                                .then(checkQueue, logErrorMessage);
                        chatlog("[0.2] -- end execPromiseChain()");
                } //; // for jslint add the semicolon after the brace. sheesh.

                /*
                 *     PUBLIC
                 *
                 */

                // chicken and egg - need to parse qstring before debug logging will work
                // so these next two logging calls are in parseParams()...
                //chatlog("[0.0] begin init()", selector);
                //chatlog("[0.0] -- calling parseParams()");

                // grab any meaningful querystring params, ignore the rest
                parseParams();

                // expose for onready handler to use
                this.chatLog = chatlog;
                this.events  = state.events;
                this.removeEvent  = removeEvent;

                // if jasmine tests are being run, expose the state object
                // NOTE: this relies on parseParams() running first
                if (state.flags.test) {
                        this.state = state;
                }

                //this.overrideIds = readOverrideValues();
                window.threeIdOverrideIds = readOverrideValues();

                // use js to set display=none on c2c-active content
                // --> this used to happen in the css, but the deployment.js methods set display
                //     via empty string, so need to set display via js
                chatlog("[0.0] -- setting .c2c-active nodes to display=none for selector: ", selector);
                var i, buttonNodes;
                if (typeof selector !== "string") {
                        buttonNodes = selector.querySelectorAll('.c2c-active');
                }
                else {
                        buttonNodes = document.querySelectorAll(selector + " .c2c-active");
                }

                for (i = 0; i < buttonNodes.length; i+=1) {
                        buttonNodes[i].style.display = 'none';
                }

                // if a promise chain is already running, push selector onto state.initQ array;
                // final then() in execPromiseChain() should shift initQ and
                //    -->  if there is a selector, run another execPromiseChain()

                if (state.flags.initRunning) {
                        chatlog("[0.0] -- another init is already running, adding this one to initQ");
                        state.initQ.push(selector);
                }
                else {
                        chatlog("[0.0] -- this is the first init, calling execPromiseChain()");
                        state.flags.initRunning = true;
                        execPromiseChain(selector);
                }
                chatlog("[0.0] end init()", selector);
        } // end defn of Chat class

        // we are still in the chatController class here
        // - this is to expose the inner 'init()' and also the instance itself (for jasmine testing)
        var chatInstance = null;
        this.init = function (selector) {
                chatInstance = new Chat(selector);
        };

        this.getChatInstance = function () {
                return chatInstance;
        };

}; // end cdc.c2c(), a.k.a. Chat Controller class

/* On ready:
 *
 * - create a Chat Controller instance
 * - add to the cdc.c2c namespace:
 *   - cdc.c2c.getChatState(): the inner chat instance's state object, if 'test=1' is in querystring
 *   - cdc.c2c.reinitialize(): the Chat Controller instance's init() method
 *   - cdc.c2c.reload():
 *     - tear down all existing liveagent connections,
 *     - create new Chat Controller instance,
 *     - call new Chat Controller instance's init() method
 * - bind a custom event handler 'loadC2C' to aid with ajaxed content
 * - call 'init()' on the body to wire up loaded chat buttons
 *
 */

// replacement for jQuery(document).ready()... NOTE: does not support IE <= 8
(function (fn) {
        "use strict"; // thanks, jslint!
        if (document.readyState === "complete" || document.readyState === "interactive") {
                fn();
        }
        else {
                document.addEventListener('DOMContentLoaded', fn, false);
        }
}(
        function() {
                "use strict"; // jslint is INSANE!
                var i, btnNodes = document.querySelectorAll(".c2c-active"); //, body = document.querySelector('body');
                for (i = 0; i < btnNodes.length; i+=1) {
                        btnNodes[i].style.display = 'none';
                }

                //var chatController = new cdc.c2c();
                var Chat = cdc.c2c, // thanks, JSLint!
                        chatController = new Chat();

                // return the state object from within the chat instance
                // NOTE: this will be undefined UNLESS 'test=1' is in querystring
                cdc.c2c.getChatState = function() {
                        return chatController.getChatInstance().state;
                };

                // we will provide two ways for ajaxed content to be processed:
                // - call a simple function call
                cdc.c2c.reinitialize = function(scopeSelector) {
                        var idx, buttonNodes = document.querySelectorAll(".c2c-active");
                        chatController.getChatInstance().chatLog("reinitialize: cdc.c2c.reinitialize() called ", scopeSelector);
                        for (idx = 0; idx < buttonNodes.length; idx+=1) {
                                buttonNodes[idx].style.display = 'none';
                        }
                        chatController.init(scopeSelector); // interface to inner chat instance
                };

                // - or fire an event
                function loadC2C (ignore, scopeSelector) { // triggerEvent
                        scopeSelector = scopeSelector || 'body';
                        chatController.getChatInstance().chatLog("reinitialize: loadc2c event triggered", arguments);
                        chatController.init(scopeSelector); // interface to inner chat instance
                }

                // disconnect from liveagent and re-wire the entire page
                // (because their code does not allow adding buttons to an existing connection...)
                cdc.c2c.reload = function(scopeSelector) {
                        var chat = chatController.getChatInstance(),
                                idx, buttonNodes;

                        chat.chatLog("reload: cdc.c2c.reload() called ", scopeSelector);
                        // jslint did not like using 'typeof' in the following 'if'...
                        if (typeof liveagent === "undefined") {
                                chat.chatLog(" -- liveagent code has not run, do not need sledgehammer...");
                        }
                        else {
                                chat.chatLog(" -- setting .c2c-active to display=none...");
                                buttonNodes = document.querySelectorAll(".c2c-active");
                                for (idx = 0; idx < buttonNodes.length; idx+=1) {
                                        buttonNodes[idx].style.display = 'none';
                                }

                                chat.chatLog(" -- removing all event handlers set by chat controller...");
                                for (idx = 0; idx < chat.events.length; idx += 1) {
                                        chat.removeEvent(chat.events[i]);
                                }
                                delete chat.events;

                                chat.chatLog(" -- calling liveagent.disconnect()...");
                                liveagent.disconnect();
                                delete window.liveAgentDeployment;
                                delete window.liveagent;

                                chat.chatLog(" -- calling cdc.c2c constructor...");
                                //chatController = new cdc.c2c();
                                chatController = new Chat();
                        }
                        chat.chatLog(" -- calling cdc.c2c.init()...");
                        chatController.init(scopeSelector); // interface to inner chat instance
                };

                // used for debugging in the console
                cdc.c2c.trigger = function (elem, eventName, dataObj) {
                        var event;
                        eventName = eventName || 'loadC2C';

                        if (window.CustomEvent) {
                                event = new CustomEvent(eventName, {detail: dataObj});
                        }
                        else {
                                event = document.createEvent('CustomEvent');
                                event.initCustomEvent(eventName, true, true, dataObj);
                        }

                        elem.dispatchEvent(event);
                };

                // replacement for jQuery bind()
                try {
                   if (typeof document.body.attachEvent !== 'undefined') {
                      document.body.attachEvent('onloadC2C',loadC2C);
                   }
                   else {
                      document.body.addEventListener('loadC2C',loadC2C);
                   }
                } catch (evt) {
                    console.log("Warning: could not add onloadC2C event (" + evt.message + ")");
                }

                // finally, kick off the processing of the newly ready page
                chatController.init('body');
        }
));


//  temporarily added for Beige release - will add to official subdomain after Beige.

cdc.includer.addSubDomain(['tools-dev', 'tools-stage']);

cdc.util.getAssetEnvironment = function(platform) {
	var subdomain = 'www';
	var environment = cdc.util.findEnvironment();

	if (environment == 'dev') {
		if (platform == 'wp') {
			subdomain = 'www-dev';
		}
		else {
			subdomain = 'fdk-devint';
		}
	}
	else if (environment == 'stage') {
		if (platform == 'wp') {
			subdomain = 'www-stage';
		}
		else {
			subdomain = 'fdk-stage';
		}
	}

	return subdomain;
};
/**
 * _cookie_informer.js
 * $Revision: 1.2 $
 *
 * cookie informer: displays a localized banner informing users that cisco.com uses cookies
 *
 * step 1:
 *    /web/fw/c/masterbrand_frag/_cisco_informer.css
 *    /web/fw/j/masterbrand_frag/_cisco_informer.js
 *       - check if the client has already acknowledged the banner
 *       - check if client has any stored banner data from a previous visit
 *       - none of the above, make call to userInfoDispatcher.js
 *         to obtain client location via Akamai response header
 *       - if "country_code" retrieved, load step 2 via includer.js
 * step 2:
 *    /etc/designs/cdc/fw/j/cdc.cookie.informer.js
 *       - this should only run once
 *       - test current location against master list of required countries
 *       - localize banner content if RB generated variable are found
 *       - display banner
 *       - set banner content & client location to local storage for next visit
 *
 * dependencies:
 *    /web/fw/co/i/s.gif
 *       - delivers the akamai custom response header: "X-Akamai-Edgescape"
 *       - must remain cors enabled/exposed (currently done with .htaccess)
 *    /etc/designs/cdc/fw/j/userInfoDispatcher.js
 *       - determine client's physical location via akamai response header
 *       - notes: this functionality will be available to the whole framework
 *       -     only works outside the firewall,
 *       -     or if local machine's hosts file forwarded to akamai staging server
 *    /etc/designs/cdc/fw/co/cookie_informer_countries.js
 *       - master list of which countries currently require cookie usage disclosure
 *    /etc/designs/cdc/fw/j/util_core.js
 *       - fw local storage methods
 *    /etc/designs/cdc/fw/j/cdc.cookie.js
 *       - fw cookie methods
 *
 * (c) 1992-2013 Cisco Systems, Inc. All rights reserved.
 * Terms and Conditions: http://www.cisco.com/web/siteassets/legal/terms_condition.html
 *
**/

cdc.util.ensureNamespace('cdc.cookie.informer');

cdc.cookie.informer.isInitiated = false;

cdc.cookie.informer.showBanner = function() {

   if(!cdc.cookie.informer.isInitiated) {

      // uncomment below to reset cookie banner on page load
      // console.log(JSON.stringify(localStorage));
      // cdc.util.ls.deleteConfigInfo('cdc_cookie_informed');
      // cdc.util.ls.deleteConfigInfo('cdc_cookie_informed_banner');
      // cdc.util.ls.deleteConfigInfo('cdc_cookie_informed_country');
      // cdc.userInfoDispatcher.clearCache();
      // console.log(JSON.stringify(localStorage));

      cdc.cookie.informer.displayBanner = function(banner){
         if (jQuery('body').hasClass('fw-res') || jQuery('body').hasClass('fw-satellite')) {
            jQuery("#fw-masthead").after(banner);  // append banner after - fw responsive
            // note: this did not got to responsive on the initial 8/30 rollout. see breakpoint handler below.
         } else {
            jQuery("#fw-banner").append(banner);   // append banner to    - fw masterbrand
         }
      };

      cdc.cookie.informer.status = function(){
         // test for previous acknowledgement
         if(cdc.util.ls.getConfigInfo('cdc_cookie_informed') === false && cdc.cookie.getCookie({ cookieName: 'cdc.cookie.informed' }) === ''){
            // check if banner data was saved to local storage during a previous visit
            banner = cdc.util.ls.getConfigInfo('cdc_cookie_informed_banner');
            country_code = cdc.util.ls.getConfigInfo('cdc_cookie_informed_country');
            if (banner !== false){
               cdc.cookie.informer.displayBanner(banner);
            } else {
               // get client location
               cdc.userInfoDispatcher.getUserProfile ({
                  "listOfDataFields": [
                     'locale.country_code'
                  ],
                  "callback": function (userProfile) {
                     if (userProfile.locale.country_code) { // only proceed if userInfoDispatcher returns something
                        // if first run and locale found, call banner setup code
                        country_code = userProfile.locale.country_code;
                        cdc.includer.loadJs("/etc/designs/cdc/fw/j/cdc.cookie.informer.js", { callback: function () {
                           cdc.cookie.informer.matchCountry(country_code);
                        }});
                     }
                  }
               });
            }

            // user ackowledges cookie statement (clicks the "X")
            jQuery('body').delegate("#cookie_set", "click", country_code, function() {
               cdc.util.ls.setConfigInfo('cdc_cookie_informed', country_code + ' - required on ' + Date()); // store cookie acknowledgement true
               cdc.util.ls.deleteConfigInfo('cdc_cookie_informed_banner');    // delete stored banner
               cdc.util.ls.deleteConfigInfo('cdc_cookie_informed_country');   // delete stored country
               jQuery('#cookie_informer').slideUp('slow', function(){ jQuery(this).remove(); });
               //set cookie, if needed. fallback for legacy browsers
               if (cdc.util.ls.getConfigInfo('cdc_cookie_informed') === false){
                  cdc.cookie.setCookie({
                     cookieName: 'cdc.cookie.informed',
                     cookieValue: country_code + ' - required on ' + Date()
                  });
               }
            }); // end delegate
         } // end if informed check
      }; // status

      cdc.cookie.informer.status(); //init
      cdc.cookie.informer.isInitiated = true;
   }
};

jQuery(document).ready(function() {
      cdc.cookie.informer.showBanner();
});


if (typeof (cdc) == "undefined") cdc = {};
if (typeof (cdc.util) == "undefined") cdc.util = {};

cdc.util.jsEscape = function (aString) {
	if (!cdc.util._jsEscapeRE) cdc.util._jsEscapeRE = /[\r\n\\']/gm; // ' for emacs
	return aString.replace (cdc.util._jsEscapeRE, function (t) { return "\\" + t; });
};


/**
 * JSP-like templates is JavaScript.
 *
 * Typical usage:
 *
 * First, compile a string into a template:
 *
 *    var myTemplate = new cdc.util.JsTemplate (templateString);
 *
 * And later, use the template as many times as necessary:
 *
 *    var htmlString = myTemplate.process (myDataObject);
 *
 * Thus templates can be cached in a suitable caching mechanism.
 * The implementation uses only raw JavaScript; no dependence on jQuery or other libraries.
 *
 * The second parameter is optional, and if provided, should be a 2-element array of strings containing the starting and ending tags
 * for demarcating a scriptlet. For example, you can say:
 *
 *        var templateStr = "It is now {% var now = new Date(); %}${now}";
 *        var tmpl = new cdc.util.JsTemplate (templateStr, ["{%", "%}"]);
 *
 * and use {% and %} as markers. This feature lets us get around issues when JsTemplate code is interspersed with JSP code.
 *
 * ALTERNATELY: A developer can escape the default tags as follows to use the existing tag syntax and not interefere
 * with JSP code tags
 *
 *       <\%   code here  %>
 *
 */
cdc.util.JsTemplate = function (aString, tagStringPair) {
	var openTagString = "<%", closeTagString = "%>";
	if (tagStringPair instanceof Array && tagStringPair.length == 2) {
		openTagString = tagStringPair[0];
		closeTagString = tagStringPair[1];
	}
	var start = 0;
	var codeParts = ["var result = [];\nwith (jsTemplateDataObject){\n"], dataStr = "";
	var re =  new RegExp (openTagString + "([\\s\\S]*?)" + closeTagString + "|\\$\\{(.*?[^\\\\])\\}", "g");//adding this as a fix for an IE8 bug.
	aString.replace (re, function (fullMatch, g1, g2, index) {
		dataStr = aString.substring (start, index);
		if (g1) {
			codeParts.push ("result.push ('" + cdc.util.jsEscape (dataStr) + "');\n");
			if (g1.substring (0,2) != "--" && g1.substring (g1.length-2, g1.length) !=  "--") {
				// It's not a comment, it's a code fragment
				codeParts.push (g1 + "\n");
			}
			start = index + g1.length + 4;
		} else { // g2 matched
			codeParts.push ("result.push ('" + cdc.util.jsEscape (dataStr) + "');\n");
			codeParts.push ("result.push (" + g2 + ");\n");
			start = index + g2.length + 3;
		}
	});
	codeParts.push ("result.push ('" + cdc.util.jsEscape (aString.substring (start)) + "');\n}\nreturn result.join ('');");
	var _codeStr = codeParts.join ("");
	try {
		this.process = new Function ("jsTemplateDataObject", _codeStr);
	} catch (e) {
		alert ("Template expansion error:\n" + e.message + "\n"  + _codeStr); // Could use better error reporting
	}

	// Debugging support:  examine the template parts
	this.codeString = function () {
		return _codeStr;
	};

};

/**
 * widgets.js
 * $Revision: 1.1 $
 *
 *   (c) 1992-2014 Cisco Systems, Inc. All rights reserved.
 *   Terms and Conditions: http://cisco.com/en/US/swassets/sw293/sitewide_important_notices.html
 *
 */
cdc.util.ensureNamespace('cdc.widget');

cdc.widget.spinner = (function(){
  'use strict';
  var spinnerObj = function(locationEl, identifier, spinnerColor){
    var defaultSettings = {
      lines: 12,        // The number of lines to draw
      corners: 1,       // Corner roundness (0..1)
      rotate: 0,        // The rotation offset
      direction: 1,       // 1: clockwise, -1: counterclockwise
      speed: 1,         // Rounds per second
      trail: 60,        // Afterglow percentage
      shadow: false,      // Whether to render a shadow
      hwaccel: false,     // Whether to use hardware acceleration
      className: 'spinner',   // The CSS class to assign to the spinner
      zIndex: 2e9,      // The z-index (defaults to 2000000000)
      top: 'auto',      // Top position relative to parent in px
      left: 'auto'      // Left position relative to parent in px
    };

    var defaultSpinner = {
      // spin.js does not have any default - these are required to create a spinner
      length: 6,        // The length of each line
      width: 3,         // The line thickness
      radius: 8,        // The radius of the inner circle
      color: spinnerColor
    };

    //  medium is just a placeholder - not implemented yet anywhere
    var mediumSpinner = {
      length: 4,
      width: 3,
      radius: 6,
      color: spinnerColor
    };

    // create a square box to contain the spinner as seen on CDC login
    var spinnerFrame = document.createElement('div');
    spinnerFrame.setAttribute('class', 'spinner-frame') ;

    var options = (identifier == 'default') ? defaultSpinner : mediumSpinner;
    options = jQuery.extend(defaultSettings, options);
    var spinner = new Spinner(options).spin(spinnerFrame);

    var parentEl = document.getElementById(locationEl);
    parentEl.appendChild(spinnerFrame);

    return{
      spinnerRemove: function(){
        spinnerFrame.parentNode.removeChild(spinnerFrame);
      },

      spinnerHide: function(){
        spinnerFrame.style.display = 'none';
      },

      spinnerShow: function(){
        spinnerFrame.style.display = 'block';
      },

      spinnerToggle: function(){
        if (spinnerFrame.style.display == 'none') {
          this.spinnerShow();
        }
        else {
          this.spinnerHide();
        }
      }
    };
  };

  return {
    init: function(locationEl, identifier, color){
      if (identifier == undefined || identifier == null) {
        var identifier = 'default';
      }
      if (color == undefined || color == null) {
        color = '#fff';
      }
      return spinnerObj(locationEl, identifier, color);
    },

    SpinnerType: {
      _default: 'default'
      //  medium is a placeholde only
      //,medium: 'medium'
    }
  }
})();
/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-discovery-federation.js: Ping Federated Login - User Discovery Functions
 */

cdc.util.ensureNamespace('cdc.login.discovery');


cdc.login.discovery = (function() {

	// main vars - init
	var apiVersion = "v3.0";
	var jsVersion = "v3.0";
	var maxWait = 5000;
	var appId = '';
	var apiServer = null;
	var apiSuccess = null;
	var localized = false;
	var userid = null;
	var isCcoUser = null;
	var isCiUser = null;
	var idpId = null;
	var isUserStale = null;
	var idpUrl = null;
	var goRefUrl = '';
    var goCiUrl = '';
    var coiingTimeout = 800;

	// check for previous user pref
	var linkPref = cdc.util.ls.getConfigInfo('loginFed_linkPref');

	// note: there are concerns about having auth creds exposed
	//       this is what we were asked to use by the backend team
	// 		 will remain for time being
	var setEnv = function() {
		var env_type = cdc.util.findEnvironment();
		if (env_type === "dev") {
			// dev
			appId = "?apikey=qfsyd3yvat336hmzvyvznzhn";
			apiServer = "https://api-dev.cisco.com";
		} else if (env_type === "stage") {
			// stage
			appId = "?apikey=rkhbnpx25wvd42enu4terbzq";
			apiServer = "https://api-test.cisco.com";
		} else {
			// prod
			appId = "?apikey=u5tgjxvz8vt9zubq38he5m6p";
			apiServer = "https://api.cisco.com";
		}
	};

	var idLookup = function() {
		// encoding doublecheck on submit
		// - infosec request stemming from DAVA security scan
		// - on submit, doublecheck that the form's "action" & the "pf.TargetResource" input field's values are still encoded.
		// - this is meant thwart potential <script> triggers, and the like, manipulated in form posts
		// - target chars referenced: > < ( ) [ ] ' " ; : / |
		var encCheck = function(encUrl) {
			var encUrlArr = encUrl.split('?');
			encUrl = encUrlArr[0];
			encUrlArr.shift();
			return encUrl + '?' + encodeURIComponent( encUrlArr.join('%3F') ); // join with encoded '?' just in case there were multiples
		};

		var submitToSso = function() {
			jQuery('#fw-overlay-spinner').removeClass('spinner-bg'); // all ajax calls are now finished - hide spinner
			jQuery('#containPass').show();
			jQuery('#passwordInput').prop('disabled', false);
			jQuery('#containUser .forget').hide();

			if (cdc.login.prefsObj.login_discovery === false || linkPref === "never" || apiSuccess === false) {
				jQuery('#userInput').prop('disabled', false);
				jQuery('#back-link').hide();
				jQuery('#register').show();
			} else {
				jQuery('#login-button').val( jQuery('#login-button-submit').text() );
				jQuery('#userInput').prop('disabled', true);
				jQuery('#passwordInput').focus();
				jQuery('#register').hide();
				jQuery('#back-link').show();
				if (jQuery('#usertype').val() === "cco") {
					jQuery('.info-hidden').show();
				}
			}

			if (jQuery('.alert-close')){
				jQuery('.alert-close').show();
			}

			// submit to sso
			var loginFormObj = jQuery("#login-form");

			jQuery('#login-form :submit').prop('disabled', false); // re-enable before submit
			jQuery("#login-form").unbind('submit');

			jQuery("#login-form").on('submit', function(e) {

				var passObj = jQuery('#passwordInput');
				var passVal = passObj.val();
				var passLabelVal = passObj.parent().find('label').text();

				if ( passVal !== "" && passVal !== passLabelVal ) {

					// double check url encoding before submit
					jQuery("#login-form").attr('action', encCheck( jQuery("#login-form").attr('action') ) );
					jQuery('#targetresource').val( encCheck( jQuery('#targetresource').val() ) );

					// submit
					jQuery('#userInput').prop('disabled', false); // re-enable before submit
					jQuery("#login-form").unbind('submit').submit();

				} else {
					return false;
				}

				e.preventDefault();
				e.returnValue = false;
			});
		};

		var submitToCi = function() {
			jQuery('.cancel').val('clicked'); // needed by ping
			jQuery("#login-form").attr('action', encCheck( jQuery("#login-form").attr('action') ) );
			setTimeout(function () { jQuery("#login-form").unbind('submit').submit() }, coiingTimeout * 1);
		};

		var errorHandler = function(err, url) {
			jQuery('#usertype').val('cco');
			apiSuccess = false;
			submitToSso(); // lookup failed. submit as cco-only user
		};


		var successHandler = function(xhr){
			// set vars
      apiSuccess = true;
      isCcoUser = parseInt(xhr.count);    // is cco

      if (typeof xhr.idpId !== 'undefined') { // is ci
        isCiUser = true;
        idpId = xhr.idpId;
        jQuery('#idpId').val(idpId);
      }

      if (typeof xhr.isUserStale !== 'undefined') { // US164897
        isUserStale = xhr.isUserStale;
        jQuery('#isUserStale').val(isUserStale);
      }

      // store the current page as the login re-start point should the user opt for an alternate login later
      cdc.util.ls.setConfigInfo('loginInitUrl', window.location, true);

      // append redirect parameter to idpUrl
      var targetUrl =  encodeURIComponent( jQuery('#targetresource').val() );

      // note: use of "%26" and "&" for the different targets is a requirement
      if (xhr.idpUrl) {
        if (xhr.idpUrl && xhr.idpUrl.indexOf('webex.com') !== -1) {
          idpUrl = xhr.idpUrl + '%26RelayState=' + targetUrl;     // ci
        } else {
          idpUrl = xhr.idpUrl + '&TargetResource=' + targetUrl;   // other
        }
      }

      //  Add this to cookie later Secure; HttpOnly
      if(xhr.t)
        document.cookie = "discovery="+xhr.t+"; Domain=.cisco.com; path=/;";

      // decide user type
      if (xhr.isFederated === true) {
        jQuery('#usertype').val('federated');
        submitToCi();
      } else {
        if (isCcoUser === 1){
          // populate form hidden fields
          if (idpUrl !== null) {
            jQuery('#idpurl, #link_idpurl').val(idpUrl);
          }

          jQuery('#usertype').val('cco');
          jQuery('#containPass .forget a').prop("href", "https://pwreset.cisco.com").prop("data-url", "https://pwreset.cisco.com")
          submitToSso();

        } else {
          if (isCiUser === true) {
            jQuery('#usertype').val('ci');
            submitToCi();
          } else {
            // un-discovered
            jQuery('#containUser .idNull').show();
            jQuery('.msg').show();

            // reset form
            jQuery('#fw-overlay-spinner').removeClass('spinner-bg');
            jQuery('#login-form :submit').prop('disabled', false);
            setForNewLookup();
          }
        }
      }
        };

        var endpoint = '/api/v1/fingerprinting/create';

        var coiPaths = {
            "prod": "https://identity.cisco.com" + endpoint,
            "stage": "https://stg-identity.cisco.com" + endpoint,
            "dev": "https://dev-identity.cisco.com" + endpoint
        }

        var getcoiPath = function() {
            var environment = cdc.util.findEnvironment();
            var paths = coiPaths;
            return paths[environment] ? paths[environment] : paths["stage"];
        }

		var setForNewLookup = function() {
			jQuery("#login-form").unbind('submit');

			jQuery("#login-form").on('submit', function(e) {
				jQuery('.msg, #warning-msg').hide(); // hide/reset any previously triggered inline error msgs

				var userObj = jQuery('#userInput');
					userid = userObj.val().trim(); // trim here as well as on blur()
				var userLabelVal = userObj.parent().find('label').text();
                var coiPath = getcoiPath()

				// test for user input
				if ( userid !== "" && userid !== userLabelVal) {

					jQuery('#fw-overlay-spinner').addClass('spinner-bg'); // show spinner

					// get user profile
					var requestUnique =  apiServer + '/api/v3/endpoint/discover/' + userid + appId;
					jQuery.ajax({
						url: requestUnique,
						type: 'GET',
						dataType: 'json',
						success: function(xhr){
                            coiService(coiPath, coi('loginNext_Ping', userid)); // from keyclockService.js
							successHandler(xhr);
						},
						error:   function(err){
							errorHandler(err, requestUnique);
						},
						timeout: maxWait
					});

				} else {
					return false;
				}

				e.preventDefault();

			});

        };
        
    var b64DecodeUnicode = function(str) {
        return decodeURIComponent(Array.prototype.map.call(atob(str), function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
        }).join(''))
    }

    var b64EncodeUnicode = function(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
            return String.fromCharCode(parseInt(p1, 16))
        }))
    }

    var isBase64 = function(str) {
      if(str.length < 1) {
        return false;
      }
      try {
        return b64EncodeUnicode(b64DecodeUnicode(str)) == str;
      } catch (err) {
        return false;
      }
    }

    var convertStrToBool = function(str) {
      if(str === 'true') {
        return true
      }
      if(str === 'false') {
        return false
      }
    }

    // coi user
    function coi(coiType, email) {
        var coi = coiUser();
        coi['fingerprintType'] = coiType;
        coi['email'] = email;
        return coi
    }

    // Decodes it from base64
    var handleBase64Encode = function() {
      var userName = jQuery("#userInput").val();
      if(isBase64(userName)) {
        var decodeValue = atob(userName);
        var decoupleArray = decodeValue.substring(1, decodeValue.length-1).split(',')
        var i;
        var object = {};

        for(i = 0; i < decoupleArray.length; i++) {
          var entry = decoupleArray[i].trim().split('=');  // everything is returned as a string
          var value = entry[1];

          // If value is a number
          if(!isNaN(value)) {
            value = parseInt(value);
          } else if(value === 'true' || value === 'false') {
            // If value is a boolean
            value = convertStrToBool(value);
          }
          object[entry[0]] = value;
        }

        // jQuery("#userInput").val(object.subject);
        jQuery("input[name='pf.username']").attr('value', object.subject);
        successHandler(object);

        // If pingid stuff is set, break the user out of getSessionStatus
        return true;
      }
    }

		// discovery status
		var getSessionStatus = function() {

      // Handle if there's a cookie before showing any ping form
      if(handleBase64Encode()) {
        return;
      }

			// show traditional login form
			if (cdc.login.prefsObj.login_discovery !== true) {
                jQuery('#usertype').val('cco');
				submitToSso();

			// show ping discovery form
			} else {
				// get status by checking for ping rendered elements
				if (jQuery('#login').length > 0) {								// not authenticated

					jQuery('#login-button').val( jQuery('#login-button-next').text() );

					if (jQuery('#warning-msg').length === 0 && linkPref !== "never") {
						setForNewLookup();
					} else {
						submitToSso();											// discovered + auth failed
					}

				} else if (jQuery('#link-accounts').length > 0) {				// user authenticated + user ci/webex
					goCiUrl = jQuery('#link_idpurl').val();

					// track user account linking prefs
					// - temporary, to help decide whether we should give users the choice
					var campaign = "CDC Login Federated Inbound";
					var itemId = "account_linking_pref";
					var trackLinkingChoice = function(choice, callback) {
						jQuery('.linkChoice').val(choice); // set for ping
						if (trackEvent !== undefined) {
							trackEvent.event("link", {
								linking_product: campaign,
								linking_id: itemId,
								linking_choice: choice
								},
								callback()
							);
						} else {
							callback();
						}
					};

					// button - link accts
					jQuery(document).on('click', '#link-accts-btn-link', function(e) {
						trackLinkingChoice('link', function() {
							//window.location.href = goCiUrl;
							jQuery('#link-accounts-form').submit();
						});
						e.preventDefault();
					});

					// button - link later
					jQuery(document).on('click', '#link-accts-btn-link-later', function(e) {
						trackLinkingChoice('later', function() {
							jQuery('#link-accounts-form').submit();
						});
						e.preventDefault();
					});

					// button - link never
					jQuery(document).on('click', '#link-accts-btn-link-never', function(e) {
						cdc.util.ls.setConfigInfo('loginFed_linkPref','never'); // set for future visits
						trackLinkingChoice('never', function() {
							jQuery('#link-accounts-form').submit();
						});
						e.preventDefault();
					});


				} else if (jQuery('#redirect-msg').length > 0) {
					jQuery(document).on('click', '#redirect-btn', function(e) {
						window.location.href = jQuery('#link_idpurl').val();
					});
				}
			}
        };

		getSessionStatus(); // init session

		// back button - form reset
		var uiReset = function(e) {
			e.preventDefault();

			// reset - main vars
			userid = null;
			apiEmail = null;
			isCcoUser = null;
			idpUrl = null;
			isCi = null;
			apiSuccess = null;
			isCiUrl = null;
			goCiUrl = '';

			// reset - hidden fields
			jQuery('#usertype').val('');
			jQuery('#idpurl').val('');
			jQuery('#idpId').val('');
			jQuery('#link_idpurl').val('');
			jQuery('#isUserStale').val('');

			// reset - ui
			jQuery(this).hide();
			jQuery('.msg, .warning-msg').hide();
			jQuery('#userInput').prop('disabled', false);
			jQuery('#passwordInput').val('');

			if (cdc.login.prefsObj.login_discovery === false) {
				showDigital();
			} else {
				jQuery('#warning-msg').remove(); // remove for discovery
				jQuery('#login-button').val( jQuery('#login-button-next').text() );
				jQuery('#containPass').hide();
				jQuery('#containUser .forget').show();
				jQuery('#back-link').hide();
				jQuery('.info-hidden').hide();
				jQuery('#passwordInput').prop('disabled', true);
				jQuery('#register').show();

				setForNewLookup();
			}

			// reset inits
			cdc.login.focus.init();
			jQuery('#userInput').focus();

		};


		// TODO: add keyboard nav where needed

		// button controls: mfa/digital

		jQuery(document).on('click', '#alert-close-link', function(e){
			jQuery('#alert').hide();
		});

		// TODO: duplicated?
		jQuery(document).on('click', '#alert-close-link', function(e){
			jQuery('#alert').hide();
		});

		// button controls: discovery/ping

		jQuery(document).on('click', '#back-link', function(e) {
			uiReset(e);
		});

		// info text/pop-up controls
		// 		these are all class selected.
		// 		no need to target specic id's, because only one
		// 		screen/section will be rendered/visible at a time,
		// 		and only 1 info button is spec'd per screen/section.

		// clicks
		jQuery(".info-btn").on('click', function(e){
			if (jQuery(".info-text").hasClass('info-show') === "true"){
				jQuery(".info-text").removeClass('info-show');
			} else {
				jQuery(".info-text").addClass('info-show');
			}
		});
		jQuery(".close span").on('click', function(e){
			jQuery(".info-text").removeClass('info-show');
		});

		// keys
		jQuery(".info-btn").on('keydown', function(e){
			if (e.keyCode === 13) { // enter/return
				jQuery(".info-text").addClass('info-show');
				jQuery(".close span").focus();
			}
			if (e.keyCode === 27) { // escape
				jQuery(".info-text").removeClass('info-show');
				jQuery(".info-btn").focus();
			}
		});
		jQuery(".close span").on('keydown', function(e){
			if (e.keyCode === 13 || e.keyCode === 27) { // enter/return/escape
				jQuery(".info-text").removeClass('info-show');
				jQuery(".info-btn").focus();
			}
		});

		// ask screens toggle
		jQuery(".ask-btn").on('click', function(e){
			jQuery("#ask-a").removeClass('active');
			jQuery("#ask-b").addClass('active');
		});
		jQuery(".ask-btn").on('keydown', function(e){
			if (e.keyCode === 13) { // enter/return
				jQuery("#ask-a").removeClass('active');
				jQuery("#ask-b").addClass('active');
			}
		});
	};

	return {
		init: function(){

			setEnv();

			if (jQuery('body.discovery').length > 0) {
				jQuery('#login-button').val( jQuery('#login-button-next').text() );
			}

			// wait for localization to complete or step through
			// - ensures form buttons get localized before any other changes are performed
			jQuery(document).bind('localizationComplete', function(){
				idLookup();
			});
		}
	};
})();

/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-localization-federation.js: Ping Federated Login - Page Localization Functions
 */

if(cdc.login === undefined) {cdc.login = {};}
cdc.login.loginLocalization = (function() {

  // localization fallback json: en-us
  // - 2017/08/25 - the following is a copy of the en-us json output from the staged login data dictionary:
  // - devint: http://wemapp-stg5-01.cisco.com:4502/etc/designs/cdc/fw/j/responsive_frag/login/i18n/en-us.1.json
  var enUsJson = ({
    "jcr:primaryType": "nt:folder",
    "jcr:mixinTypes": ["mix:language"],
    "jcr:createdBy": "admin",
    "jcr:language": "en-us",
    "jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500",
    "Cisco_Login_Local_Content_Existing_User": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Log into an Existing Account","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Footer_Help": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Help","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Footer_Terms_And_Conditions": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Terms & Conditions","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "CISCO_LOGIN_AREA_PRODUCTS_SERVICES_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/c/en/us/products/index.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Btn_Next": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Next","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Skip_To_Home": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Home","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "CISCO_LOGIN_FOOTER_PRIVACY_STATEMENT_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/legal/privacy-full.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Info_Linking": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Linking your accounts enables you to access secure Cisco, WebEx, and Spark resources using your WebEx/Spark login information in the future.","jcr:created": "Tue Aug 22 2017 19:35:35 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Header_Create_Cdc": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "We need your Cisco.com account","jcr:created": "Tue Aug 22 2017 19:32:10 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I1": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "If you recently changed your email address, check your email for a validation link from us. <a href=\"mailto:web-help@cisco.com\">Contact Cisco Support</a> for help.","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_3","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Content_Password": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Password","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Error_Message": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Your login was unsuccessful for one of the following reasons:","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Id_Null": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "We couldn't find that. Try again.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Footer_Contacts": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Contacts","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Btn_Link_Later": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Ask me later","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_FOOTER_TRADEMARK_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/legal/trademarks.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Msg_Wait": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Something went wrong. Please try again after sometime or <a href=\"mailto:web-help@cisco.com\">contact web-help@cisco.com</a>","jcr:created": "Tue Aug 22 2017 19:38:36 GMT-0400"},
    "Cisco_Login_Area_Products_Services": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Products & Services","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "CISCO_LOGIN_AREA_PARTNERS_RESELLERS_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/c/en/us/partners.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Header_Link": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Link your accounts","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Cdc_Not_Found": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "We don't see a Cisco.com account associated with your WebEx/Spark account.","jcr:created": "Tue Aug 22 2017 19:29:32 GMT-0400"},
    "Cisco_Login_Local_Login_Language_Short": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Language:","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Content_Forgot_Password": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Forgot your user ID and/or password?","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Btn_Link_Never_2": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "I'm sure, don't ask again","jcr:created": "Tue Aug 22 2017 19:26:34 GMT-0400"},
    "Cisco_Login_Local_Content_New_User_Desc": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "There are various levels of access depending on your relationship with Cisco. Review the <a href=\"//www.cisco.com/c/en/us/applicat/content/cdcrgstr/applications_overview.html\">benefits of registration</a> and find the level that is most appropriate for you.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Skip_To_Content": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Skip to Content","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Msg_Update_Email": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "<a class=\"modref\" href=\"//rpfa.cloudapps.cisco.com/rpfa/profile/profile_management.do\">Log in and update your email address.</a> (Update your Cisco.com account with your WebEx/Spark account email so that you can link your accounts in the future.)","jcr:created": "Tue Aug 22 2017 19:37:28 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Password": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Password","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Content_New_User": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Create A New Account","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Error_Message_Item2": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "You recently changed your password, and the system is updating your information. Please try again in a few minutes, or contact <a href=\"mailto:web-help@cisco.com\">Cisco support</a>.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Content_User_Name": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "User Name","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Footer_Privacy": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Privacy Statement","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Footer_Sitemap": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Site Map","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Incorrect password. Try again.","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_1","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Footer_Cookies_Short": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Cookies","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Footer_Feedback": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Feedback","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "CISCO_LOGIN_AREA_LEARNING_EVENTS_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/c/en/us/training-events.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "CISCO_LOGIN_FOOTER_COOKIES_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/legal/privacy-full.html#cookies","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_User_Name": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Username or email","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_FOOTER_FEEDBACK_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "https://secure.opinionlab.com/ccc01/o.asp?id=jBjOhqOJ","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Local_Content_Btn_Login": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Log In","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_AREA_ORDERING_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/c/en/us/buy.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Msg_Try_Cdc": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Or, just <a class=\"loginInitUrl\" href=\"//www.cisco.com\">go back and log in to your Cisco.com account.</a> (But you may see this screen again later.)","jcr:created": "Tue Aug 22 2017 19:36:43 GMT-0400"},
    "Cisco_Login_Fed_Local_Info_Future": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "If you don't want to be asked again, but you do want to link your accounts in the future, <a href=\"mailto:web-help@cisco.com\">contact Cisco Support</a>.","jcr:created": "Tue Aug 22 2017 19:34:10 GMT-0400"},
    "CISCO_LOGIN_AREA_TAC_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/c/en/us/support/index.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I4": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "<a href=\"mailto:web-help@cisco.com\">Contact Cisco Support</a> for help.","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_6","jcr:created": "Tue Aug 22 2017 19:31:40 GMT-0400"},
    "Cisco_Login_Local_Error_Message_Item3": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "You recently changed your email address, and you still need to validate it. Check your inbox or spam folder for the validation email and link. If you did not receive it, contact <a href=\"mailto:web-help@cisco.com\">Cisco support</a>.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Message_Redirecting": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "We are linking your Cisco and organization accounts. We'll ask you to log in with your organization username and password and that's it.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Footer_Trademarks": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Trademarks","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Header_Redirecting": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Redirecting to your organization","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Local_Btn_Register_Now": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Register Now","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_LOCAL_BTN_REGISTER_NOW_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//idreg.cloudapps.cisco.com/idreg/guestRegistration.do?locale=en_US","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Msg_Update_Email_3": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "If you <a class=\"modref\" href=\"//rpfa.cloudapps.cisco.com/rpfa/profile/profile_management.do\">update your Cisco.com account with your WebEx/Spark email address</a>, you can link your accounts in the future (which enables you to access secure Cisco, WebEx, and Spark resources using your WebEx/Spark login)","jcr:created": "Tue Aug 22 2017 19:38:02 GMT-0400"},
    "Cisco_Login_Fed_Local_Btn_Register": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Create account","jcr:created": "Tue Aug 22 2017 19:42:02 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "That login didn't work:","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_LOCAL_CONTENT_FORGOT_PASSWORD_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//idpswd.cloudapps.cisco.com/emailSubmitAction.do","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_FOOTER_HELP_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/help.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Local_Error_Message_Item1": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "You entered your user name or password incorrectly. Please try again.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Id_Multi": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "We found multiple accounts for that email. Try a username.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_FOOTER_TERMS_AND_CONDITIONS_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/legal/terms-conditions.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Local_Content_Header_Login": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Log In","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Skip_To_Footer": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Skip to Footer","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Footer_Cookies": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Cookie Policy","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Area_Ordering": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "How to Buy","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Header_Have_Cdc": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Already have a Cisco.com account?","jcr:created": "Tue Aug 22 2017 19:32:35 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I2": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Try entering your username (if you haven't tried that already).","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_4","jcr:created": "Tue Aug 22 2017 19:30:04 GMT-0400"},
    "Cisco_Login_Fed_Local_Btn_Link": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Link my accounts","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Area_Partners_Resellers": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Partners","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Area_Learning_Events": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Training & Events","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Message_Link": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Would you like to link your Cisco and WebEx/Spark accounts so it's easier next time? We'll ask you to log in to your WebEx/Spark account and that's it.","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Header_You_Sure": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Are you sure?","jcr:created": "Tue Aug 22 2017 19:33:02 GMT-0400"},
    "CISCO_LOGIN_FOOTER_SITEMAP_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "//www.cisco.com/c/en/us/about/sitemap.html","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Footer_Privacy_Short": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Privacy","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Forgot_Username": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Forgot username?","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I3": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "If you recently created your account or changed your email address, check your email for a validation link from us.","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_5","jcr:created": "Tue Aug 22 2017 19:30:33 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Btn_Login": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Log in","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Area_Tac": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Support","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Info_Also_Have": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "sakurati","sling:message": "Also have a WebEx or Spark account?","jcr:created": "Tue Aug 22 2017 19:33:34 GMT-0400"},
    "Cisco_Login_Fed_Local_Btn_Register_Now": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Create a new account","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Forgot_Password": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Forgot password?","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "CISCO_LOGIN_FOOTER_CONTACTS_URL": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "/cisco/web/siteassets/contacts/ ","jcr:created": "Fri Mar 31 2017 08:52:56 GMT-0400"},
    "Cisco_Login_Fed_Local_Content_Error_Msg_Password_I0": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "If you recently changed your password, wait a few minutes for the system to update and try again.","sling:key": "Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_2","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Back_Link": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Back","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Btn_Link_Never": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Don't ask me again","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"},
    "Cisco_Login_Fed_Local_Content_Header_Login": {"jcr:primaryType": "nt:folder","jcr:mixinTypes": ["sling:Message"],"jcr:createdBy": "admin","sling:message": "Log in to your account","jcr:created": "Sun Mar 05 2017 22:34:43 GMT-0500"}
  });


  var supportLanguages = {
    "zh-cn": "Chinese Simplified (\u7b80\u4f53\u4e2d\u6587)",
    "cs-cz": "Czech (\u010c\u0065\u0161\u0074\u0069\u006e\u0061)",
    "en-us": "United States - English" ,
    "fr-ca": "French (Fran\u00e7ais Canada)",
    "fr-fr": "French (Fran\u00e7ais)",
    "de-de": "German (Deutsch)",
    "it-it": "Italian (Italiano)",
    "ja-jp": "Japanese (\u65e5\u672c\u8a9e)",
    "ko-kr": "Korean (\ud55c\uad6d\uc5b4)",
    "pl-pl": "Polish (Polski)",
    "pt-br": "Portuguese Brazil (Portugu\u00eas)",
    "ru-ru": "Russian (\u0420\u0443\u0441\u0441\u043a\u0438\u0439)",
    "es-es": "Spanish EURO (Espa\u00f1ol europeo)",
    "es-mx": "Spanish LATAM (Espa\u00f1ol)",
    "th-th": "Thai (\u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22)",
    "tr-tr": "Turkish (\u0054\u00fc\u0072\u006b\u00e7\u0065)",
    "vi-vn": "Vietnamese (\u0054\u0069\u1ebf\u006e\u0067 \u0056\u0069\u1ec7\u0074)"
  };


  /**
  * When given a locale and a callback, it should get the values for the locale and call the callback with those values as a parameter.
  * This API is exposed through cdc.login.getLocalizedLoginValues({locale:'en/US',callback:function(dictionary){/use dictionary here /}}).
  * it must get localized values from the static service deswcribed here:
  * https://www.cisco.com/etc/designs/cdc/fw/co/local/{LOCALE:'en_US'}/login_values.js
  */
  getLocalizedLoginValues = function(loginLocale, callBackFun){

    if(!(loginLocale in supportLanguages)){
      loginLocale = "en-us";
    }

    // get data dictionary json
    var subdomain = 'www';
    var environment = cdc.util.findEnvironment();
    if (environment == 'dev') {
      subdomain = 'fdk-author-stage';
    } else if (environment == 'stage') {
      subdomain = 'cloudsso-test';
    }
    var serviceURL = "//" + subdomain + ".cisco.com/etc/designs/cdc/fw/j/responsive_frag/login/i18n/" + loginLocale + ".1.json";

    // setting waiting period to display login in default language
    var loginLocaleWaitTime = 2000;
    cdc.login.showDefaultLogin = setTimeout( localizeDefaultLogin, loginLocaleWaitTime );
    cdc.login.loginLocalPendingCallCanceled = false;

    jQuery.ajax({
      url     : serviceURL,
      type    : "get",
      dataType: "json",
      success : callBackFun // { callback: localizeLogin }
    });

  };

  /**
   * detect locale from local storage
   * if not found detect locale by parameter passed in
   * if not found detect locale by URL of referring page (see patterns)
   * if not found detect locale in browser
   */
  getLoginLocale = function(passedLocale) {

      var locale = "";

      if ( cdc.util.ls.getConfigInfo('localeinfo') === false || cdc.util.ls.getConfigInfo('localeinfo') === '' ) {

        var localeCountryObj = cdc.util.locale.getLocale(passedLocale); // if nothing passed, returns window.navigator.language
        var language = localeCountryObj.getLanguage;
            language = (language !== false) ? language : 'en';
        var country =  (language === 'en') ? 'us' : localeCountryObj.getCountry;

        locale = language + '-' + country;
        locale = locale.toLowerCase(); // 'en-us';

        cdc.util.ls.setConfigInfo("localeinfo", locale); // set value as identified locale

      } else {

        locale = cdc.util.ls.getConfigInfo("localeinfo");
        // set lowercase, if stored before data dictionary cutover: "en_US" -vs- "en-us"
        // - added dec 1, 2016. can be removed after 'sufficient' time has passed
        locale = locale.toLowerCase().replace('_', '-');
        cdc.util.ls.setConfigInfo("localeinfo", locale);

      }

      return locale;
  };

  /**
   * This function is called if an error is encounterd in ajax request or if locale service takes more than 2 seconds to respond
   */
  localizeDefaultLogin = function(){
    localizeLogin( enUsJson  );
    cdc.login.loginLocalPendingCallCanceled = true;
    if(cdc.login.showDefaultLogin){
      clearTimeout(cdc.login.showDefaultLogin);
    }
    jQuery('.dropdown-header').text( jQuery('.dropdown-content li.' + 'en-us' ).text() ); // fallback
  };

  /////// language selector

  // navigation - show dropdown - mouse
  jQuery('.dropdown-header, ul.dropdown-content').on('mousedown', function(){
    jQuery('.dropdown-content').addClass('show');
  });
  jQuery('.dropdown-header, ul.dropdown-content').on('blur', function(){
    jQuery('.dropdown-content').removeClass('show');
  });

  // navigation - show dropdown on header focus + enter
  jQuery(document).on('keypress', '.dropdown-header', function (e) {
    if (e.which == 13) {
      jQuery('.dropdown-content').addClass('show');
      jQuery('.dropdown-content li:first').focus();
    }
  });

  // navigation - dropdown - arrows up/down
  jQuery(document).on('keydown', function(e){
    if ( jQuery('.dropdown-content').hasClass('show') ) {
      if (e.keyCode == 40){
          jQuery(document.activeElement).next().focus();
        }
      if (e.keyCode == 38){
        jQuery(document.activeElement).prev().focus();
      }
    }
  });

  // navigation - dropdown - escape
  jQuery(document).keyup(function(e) {
    if (e.keyCode === 27) {
        jQuery('.dropdown-content').removeClass('show');
    }
  });

  // navigation - dropdown - mouse click
  jQuery(document).on('mousedown', '.dropdown-content li', function () {
    var selectedLocale = jQuery(this).attr('class');                  // locale values selected from dropdown
    resetLocal(selectedLocale);
  });

  // navigation - dropdown - key enter
  jQuery(document).on('keypress', '.dropdown-content li', function (e) {
    if (e.which == 13) {
      var selectedLocale = jQuery(document.activeElement).attr('class');
      resetLocal(selectedLocale);
      jQuery('.dropdown-content').removeClass('show');                // hide dropdown after selection
    }
  });

  // navigation - dropdown - reset language
  resetLocal = function(newLocal){
    jQuery('.dropdown-header').text( jQuery('.' + newLocal).text() ); // update current language in hdr
    cdc.util.ls.setConfigInfo('localeinfo', newLocal);                // setting the selected locale value
    jQuery('.dropdown-content').removeClass('show');                  // hide dropdown after selection
    getLocalizedLoginValues(newLocal, localizeLogin);                 // updating the page..
  };

  /**
   * Localizes the login page with the passed in dictionary.
   */
  localizeLogin = function(jsnResponse){

    if(cdc.login.showDefaultLogin){
      clearTimeout(cdc.login.showDefaultLogin);
    }

    if (cdc.login.loginLocalPendingCallCanceled) {
      login.afterLocalization();
      return;
    }

    if (jsnResponse && typeof jsnResponse['jcr:language'] !== 'undefined'){

      // handle data dictionary long keys defect:
      // when a key is too long, or has illegal chars, the dd shortens & renames it with an index.
      //    example: Cisco_Login_Fed_Local_Content_Error_Msg_Password_Item_1
      //             Cisco_Login_Fed_Local_Content_Error_Msg_Password_I0
      // as a fallback, dd adds the original to a "sling:key" node inside the renamed parent.
      // note: the new keys were vetted by the dd team, but this issue had not been identified yet.
      // - long  term fix: dd team will place a cap on key length.
      // - short term fix: look for the 'sling:key' nodes and tack them then their sling:message on to the jsnResponse as parents
      for (var i in jsnResponse) {
        if (jsnResponse[i]['sling:key']) {
          jsnResponse[jsnResponse[i]['sling:key']] = { 'sling:message' : jsnResponse[i]['sling:message'] };
        }
      }

      // test for valid dd/json responses by searching through the page's data-* node

      var dataTextArr = jQuery("[data-text]");
      for (var j = 0; j < dataTextArr.length; j++) {
        var dataText = dataTextArr[j];
        var dataTextKey = jQuery(dataText).data("text");
        if (jsnResponse[dataTextKey]) {
          jQuery(dataText).html(jsnResponse[dataTextKey]["sling:message"]);
        }
      }

      var dataUrlArr = jQuery("[data-url]");
      for (var k = 0; k < dataUrlArr.length; k++) {
        var dataUrl = dataUrlArr[k];
        var dataUrlKey = jQuery(dataUrl).data("url");
        if (jsnResponse[dataUrlKey]) {
          jQuery(dataUrl).prop("href", jsnResponse[dataUrlKey]["sling:message"]);
        }
      }

      var dataValueArr = jQuery("[data-value]");
      for (var l = 0; l < dataValueArr.length; l++) {
        var dataValue = dataValueArr[l];
        var dataValueKey = jQuery(dataValue).data("value");
        if (jsnResponse[dataValueKey]) {
          jQuery(dataValue).val( jsnResponse[dataValueKey]["sling:message"] );
        }
      }

      // populating the language dropdown with supported languages
      if(jQuery("#fw-language-select .dropdown-content")) {
        jQuery("#fw-language-select .dropdown-content").empty();
        var tabnum = 7; // add tabindex to list items to enable tab focus
        jQuery.each(supportLanguages, function(code, name) {
          jQuery("#fw-language-select .dropdown-content").append(jQuery("<li>", {
            class : code,
            tabindex : tabnum++,
            text : name
          }));
        });

        // highlight the current selected Language
        var headerLocale = cdc.util.ls.getConfigInfo("localeinfo");
        if (headerLocale !== false) {
            jQuery('.dropdown-header').text( jQuery('.dropdown-content li.' + headerLocale ).text() );
        }

      }

    }

    login.afterLocalization();

  };

  return {
    getLoginLocale: function(locale) {
      return getLoginLocale(locale);
    },
    getLocalizedLoginValues: function(url, isErrorPage) {
      getLocalizedLoginValues(url, isErrorPage);
    },
    localizeLogin: function(jsnResponse) {
      localizeLogin(jsnResponse);
    }
  };

})();

/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-registration-federation.js: Ping Federated Login - User Registration Functions
 */

cdc.util.ensureNamespace('cdc.login.loginReferrerUrl');

// note: these methods were originally named for manipulating the "register" link.
// the names have persisted as the code has evolved to encompass other staging requirements.

cdc.login.loginReferrerUrl={
	getReferrerUrl:"", // variable for getting referrer URL from where user came on login page.

	init: function(){

		// store document.referrer

		if (jQuery('#login-form').length === 1 && jQuery('#warning-msg').length === 0) { // checking whether it is login page (not login error page)
			this.getReferrerUrl = document.referrer; // URL from where user came on login page
			if (this.getReferrerUrl !== "") {
				cdc.util.ls.setConfigInfo('referrerUrl', this.getReferrerUrl);
			} else {
				cdc.util.ls.deleteConfigInfo('referrerUrl'); // delete stale referrer
			}
		} else {
			this.getReferrerUrl = cdc.util.ls.getConfigInfo('referrerUrl'); // if on login error page
			if (this.getReferrerUrl === false) { // value will be false if direct go to login error page
				this.getReferrerUrl = ''; // team consuming exit_url= expects blank, if false
			}
		}
	},

	registerReferrerUrl:function(){

		// modify content urls as needed

		if ( jQuery('body').hasClass('cec-login') ) {
			return;
		}

		var refUrl = this.getReferrerUrl;
		var env = cdc.util.findEnvironment();

		jQuery('a.modref').each(function(){

			var currUrl = jQuery(this).attr('href');

			// if dev/stage append '-stage' to subdom for testing
			if (env == 'dev' || env == 'stage') {
				currUrl = currUrl.replace(/(idreg|idpswd|rpfa)\./i, '$1-stage.');
				currUrl = currUrl.replace(/(cloudsso)\./i, '$1-test.');
			}

			// append 'exit_url=' to search string
			// note: this may only be needed for the register link, but will continue to riding along, for now.
			if (currUrl.indexOf('TargetResource=') === -1) {
				var currQuery = (currUrl.indexOf("?") != -1) ? "&" : "?";
				currUrl = currUrl + currQuery + "exit_url=" + encodeURIComponent(refUrl) ;
			}

			// replace with updated curl
			jQuery(this).attr("href", currUrl);

		});

		// set help links to non-prod email address on dev/stage envs
		if (env == 'dev' || env == 'stage') {
			jQuery('a[href^="mailto:web-help@cisco.com"]').each(function(){
				jQuery(this).attr('href', 'mailto:cpr-ops@cisco.com');
			});
		}

		// retrieve session stored login starting point and populate all user login re-start option links
		var currLoginInitUrl = cdc.util.ls.getConfigInfo('loginInitUrl', true);
		if (currLoginInitUrl !== false) {
			jQuery('.loginInitUrl').each(function(){ // link may appear in multiple screens within the template
				jQuery(this).attr('href', currLoginInitUrl.href);
			});
		}

	}
};




/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-focus-federation.js: Ping Federated Login - User Input Focus Functions
 */

cdc.util.ensureNamespace('cdc.login.focus');

cdc.login.focus = (function() {

	var setFocus = function() {

		jQuery('#userInput, #passwordInput').each(function() {

			jQuery(this).unbind(); // reset in case language change

			var inputObj = jQuery(this);

			// copy label text to the placeholder. this picks up any localization that has occurred
			inputObj.attr('placeholder', inputObj.prev('label').text());

			if (inputObj.val() === '' || inputObj.hasClass('hint') === true) {
				inputObj.addClass('hint');
				inputObj.prev('label').removeClass('hint');
			}

			jQuery(inputObj).focus(function() {

				jQuery(this).removeClass('hint');
				jQuery(this).prev('label').addClass('hint');

			}).blur(function(){

				if (jQuery(this).val() === '' || jQuery(this).val().length === 0) {
					jQuery(this).addClass('hint');
					jQuery(this).prev('label').removeClass('hint');
				} else {
					jQuery(this).removeClass('hint');
					jQuery(this).val( jQuery(this).val().trim() ); // trim whitespace
				}

			});
		});
	};

	return {
		init: function(){
			setFocus();
		}
	};

})();

/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-positioning-federation.js: Ping Federated Login - Footer Positioning Functions
 */

cdc.util.ensureNamespace('cdc.login.positioning');

// for elements that need positioning variants at different breakpoints
cdc.login.positioning = (function() {

	var smallEntered = true;

	var positionFooter = function() {

		if (jQuery('.digital-signin').length === 0){

			if (smallEntered === true) {

				// get current positions
		        fwContentBot =  Math.floor(document.getElementById('fw-content').getBoundingClientRect().bottom);
		        fwFooterHeight  = jQuery('#fw-footer').height();
		        contentMaxHeight = fwContentBot + fwFooterHeight;
		        windowHeight  = jQuery(window).height();

		        if (contentMaxHeight <= windowHeight) {
					jQuery('#fw-footer').addClass('pinned');
		        } else {
					jQuery('#fw-footer').removeClass('pinned');
		        }
			} else {
				jQuery('#fw-footer').removeClass('pinned');

			}
		}

	};

	// only position at small and above
    var breakpointHandlerSmall = function () {
    	smallEntered = true;
    	    	positionFooter();

    };
    cdc.breakpoint.onEnter(breakpointHandlerSmall, cdc.breakpoint.breakpoints.tall);

    var breakpointHandlerSmallExit = function () {
    	smallEntered = false;
    	    	positionFooter();

    };
    cdc.breakpoint.onExit(breakpointHandlerSmallExit, cdc.breakpoint.breakpoints.tall);

    // do position check
    // - for desktop
	jQuery(window).resize(function(event) {
    	positionFooter();
	});

    // - for mobile
    jQuery(window).on("touchend", function(event) {
        positionFooter();
    });

    jQuery(window).on("scroll", function(event) {
    	positionFooter();
    });

	// - init
    positionFooter();

	return {
		execute: function() {
			positionFooter();
		}
	};

})();

/**
 *  Copyright (C) 2016 Cisco Systems, Inc. All rights reserved.
 *  $Revision: 2.0 $
 *  _login-federation.js: Ping Federated Login - Functions
 */

var login = (function() {

	var runLocalizationSetup = function() {

		var locale =        cdc.login.loginLocalization.getLoginLocale("");
		var callbackFunct = cdc.login.loginLocalization.localizeLogin;
		cdc.login.loginLocalization.getLocalizedLoginValues(locale, callbackFunct);

	};

	return {

		afterLocalization: function() {
			cdc.login.focus.init();
			login.showForm();
			cdc.login.loginReferrerUrl.registerReferrerUrl();
			cdc.login.positioning.execute();
			jQuery(document).trigger('localizationComplete');
		},

		showForm: function() {
			document.body.className += ' show';
		},

		setAnchorvalueCookie: function() {
			if (jQuery('#login-form').length === 1 && ( jQuery('#warning-msg').length === 0 || jQuery('#warning-msg').is(":hidden") ) ) {
				document.cookie = "anchorvalue=" + window.location.hash + "; path=/; domain=.cisco.com";
			}
		},

		execute: function() {

			login.setAnchorvalueCookie();

			if (cdc.login.prefsObj.login_localize === true) {
				document.body.className += ' localize';
			}

			if (cdc.login.prefsObj.login_discovery === true) {
				document.body.className += ' discovery';
			}

			cdc.login.discovery.init(); // non-discovery pages leverage parts of the discovery code
			cdc.login.loginReferrerUrl.init();

			if (jQuery('#fw-language-select').length === 0 || cdc.login.prefsObj.login_localize === false) {
				jQuery('#fw-language-select').css('visibility','hidden'); // hide when not in use, but keep spacing
				login.afterLocalization(); // step through for non-localizing forms
			} else {
				runLocalizationSetup();
			}
		}
	};

})();

jQuery(document).ready(function(){
	login.execute();
});

/**
 * rule-lib.js
 *
 * $Revision: 1.4 $
 *A library for getting and setting metrics-related info.
*/

(function($){

	/**
	 * @param cond = if a string, will be treated as a jQuery DOM selector.
	 *    if a function, must accept a dom element and return a boolean.
	 * @param vals = if an object, will be treated as names/values.
	 *    if a function, must accept a dom element and return an object
	 *    containing names/values. optional. if falsy, will be ignored.
	 * @param addSubs = optional. if provided must be a function that
	 *    accepts a single param. param has a method .subrule() with the
	 *    same signature as this. subrules will only apply if the parent
	 *    rule applies.
	 *
	 * examples:
	 *    cdc.util.addMetricsRule('a#foo', {lpos:'foo'});
	 *    cdc.util.addMetricsRule('div#baz *', {lpos:'baz'}, function(rule){
	 *        rule.subrule('a.products', {lid:'Products'});
	 *        rule.subrule('a.services', {lid:'Services'});
	 *    });
	 */
	cdc.util.addMetricsRule = function(cond, vals, addSubs) {
		return addRule(cond, vals, addSubs);
	};

	/**
	 * @param domElmt = any dom element.
	 * @returns = an object containing names/values.
	 *
	 * example:
	 *    var info = cdc.util.getMetricsInfo(document.getElementById('foo'));
	 *    console.log(info.lpos); // "foo"
	 *    console.log(info.lid); // undefined
	 */
	cdc.util.getMetricsInfo = function(domElmt) {
		var res = getInf(domElmt);

		// support legacy hard-coded name attributes
		// TODO: when can we remove this?
		var n = domElmt.name;
		if (n && n.indexOf('&lpos=')===0) {
			$(n.split('&')).each(function(){
				var pair = $(this.split('=')).map(function(){return unescape(this);});
				if(pair[0]==='lpos'&&!res.lpos){res.lpos=pair[1];}
				if(pair[0]==='lid'&&!res.lid){res.lid=pair[1];}
			});
		}

		//console.log("Dom element Info before HTML setAttribute", res);
		//Metrics attributes and their corresponding HTML attributes for Links and button
		var htmlAttrMap ={
				"data-config-metrics-group": "lpos",
				"data-config-metrics-title": "lid",
				"data-config-metrics-item": "linktext"
		}
		res = setHtmlAttr(domElmt,htmlAttrMap,res);
		//console.log("metrics obj after set Attribute", res);
		return res;
	};

	// END PUBLIC
	// ########################################################################
	// BEGIN PRIVATE

	var theRules = [],
		isFunc = function(x){return typeof x === 'function';};

	// get metrics info
	function getInf(elmt, rules) {
		var res = {}; // result to be returned
		rules = rules || theRules;
		$(rules).each(function(){
			var cond = this.cond,
				vals = this.vals,
				subs = this.subs;
			if (!(isFunc(cond) ? cond(elmt) : $(elmt).is(cond))) { return; }
			$.extend(res, isFunc(vals) ? vals(elmt) : vals);
			if (subs.length < 1) { return; }
			$.extend(res, getInf(elmt, subs));
		});
		return res;
	}

	// add metrics rule
	function addRule(cond, vals, subadder, rules) {
		vals = vals || {};
		rules = rules || theRules;
		var subs = [];
		var ruleItem = {
			cond:cond,
			vals:vals,
			subs:subs
		};
		rules.push(ruleItem);
		if (isFunc(subadder)) {
			subadder({
				subrule:function(cond, vals, subadder){
					return addRule(cond, vals, subadder, subs);
				}
			});
		}
	}

	// Function to set HTML attributes (if present) that override the previously set 'lpos','lid' and 'linktext'
	function setHtmlAttr(elmt,attrMap,metricsObj){
		for( var attrb in attrMap){
			var attr = $(elmt).attr(attrb); //checking whether the attribute is defined in the element or not
			//for some browser, 'attr' is undefined and for some others it is 'false', hence check for both
			if (typeof attr !== typeof undefined && attr !== false) {
				metricsObj[attrMap[attrb]] = $(elmt).attr(attrb);
			}
		}
		return metricsObj;
	}

})(jQuery);






/**
 * liveManager.js
 * $Revision: 1.19 $
 * universal tag - liveManager.js 2.0.20100703.1200, Copyright 2010 Tealium.com Inc. All Rights Reserved.
*/
if (typeof cdcPageTimers !=="undefined") {
	cdcPageTimers.utloader=new Date();
}

if (typeof(cdc) == "undefined") cdc = new Object();
if (typeof(cdc.util) == "undefined") cdc.util = new Object();
if (typeof(cdc.util.ensureNamespace) == "undefined"){
    cdc.util.ensureNamespace = function(namespaceStr) {
        if (!namespaceStr) return;
        var parts = namespaceStr.split(".");
        var o = window;
        for (var i = 0; i < parts.length; i++) {
            var aPart = parts[i];
            if (typeof(o[aPart]) != "object") {
                o[aPart] = new Object();
            }
            o = o[aPart];
        }
    }
}

/* Ensure Namespace */
cdc.util.ensureNamespace("cdc.ut.liveManager");
cdc.util.ensureNamespace("cdc.ut.trackEvent");
cdc.util.ensureNamespace("cdc.ut.eventqueue");

/* Global UT config object */
cdc.util.ensureNamespace("cdc.ut.config");

/*
 Method: cdc.ut.config.set()

 Description:
	*Page Level Customization*
    Set the properties of <config> object directly on the page.
	We can On/Off metric call on the page. Need to pass variable name and value to this method for page level customization. Internally this method set this variable and their value to <config> object.
	Once <cdc.ut.liveManager.ONLOAD()> method invoke then first it checks the config object if any variable/object present there then it updates the same variable/object in to <cdc.ut.liveManager.config> object.

 Sample Usage:
	>	cdc.ut.config.set("send",{dop:true,s_code:false});
	>	cdc.ut.config.set({
	>		rs_map_src:"//cdn.tealium.com/deployment_toolkit/cisco/v3/rs_map.js",
	>		trackevent_src:"//cdn.tealium.com/deployment_toolkit/cisco/v3/trackEvent.js",
	>		ntpagetag_src:"//cdn.tealium.com/deployment_toolkit/cisco/v3/ntpagetag.js",
	>		s_code_ut_src:"//cdn.tealium.com/deployment_toolkit/cisco/v3/s_code_ut.js"
	>	});

 Params:
	-	There two parameters reqiured for this method. Need to pass the variable name & value.
	-	a - It holds the two types of value. Either it could be string or object.
	-	b - b value is depend on a, if a holds string type of value then b holds the object otherwise it not hold any value.

*/

cdc.ut.config.set=function(a,b,c){
	c={};
	if(typeof a=="string"){
		c[a]=b;
	}
	else c=a;

	for(a in c){
		if(typeof c[a]!="undefined"){
			cdc.ut.config[a]=c[a];
		}
	}
}

/*

Class: cdc.ut.liveManager

Description:
	*Object cdc.ut.liveManager*
	- holds configuration parameters
	- collects data from page
	- loads metric vendor libraries
	- loads trackEvent
	- tries to stop vendor code duplication

Overview:
	1 At the end of this file is a try / catch block that will run the <cdc.ut.liveManager.ONLOAD> method
		- Either when the jQuery ready event happens (if jQuery is loaded)
		- Or after a 3 second timeout if not.

	2 The <cdc.ut.liveManager.ONLOAD> method first checks a few details of the <cdc.ut.config> object if specified
		- Should probably add a check to not load specific libraries if not going to be used, not just not call them
		- Also ime the no-load didn't work.

	3 Then calls <loadFiles> method in set synchronous order for each other file to load
		-	Files are loaded by adding a script tag to the head
		-	Then a callback function can be triggered,
		-	Calls dop.INIT for dop, nothing for site catalyst
		-	When trackEvent has been loaded then callback functions are triggered it calls <PT()>, then <trackEvent.INIT> (earlier calls <cdc.ut.liveManager.LOAD> I think it tracks if it's been loaded, and evals the callback anything else???)
		-	And then sends a "view" event to <trackEvent.event> sending the params in liveManager.

	4 <PT> parses the page
		-	Saves all meta tag info,
		-	Parses hinav and/or treecrumb if present and uses that for sitearea info if so,
		-	Also has ability to save and pass thru arbitrary name/values in a track object if one is found in the page.
			(Cisco is currently not using this as we're trying to avoid things that require page level content changes, but the capability apparently exists.)

	5 <trackEvent.INIT> steps through the "plugins" in order and runs their _I methods if they have any commands in them (most don't)
		-	Then it runs any events that have been stored in a livemanager queue  (if any).

	6 Plugins are an array of pl[#] object (members of trackEvent)  _I methods <trackEvent.pl[]>
		-	Currently only <trackEvent.pl[3]> has an _I method... it uses this to attach a mousedown listener to the window and it tracks BAM impressions if applicable.

	See OVERVIEW section in LiveManager for what happens when initial "view" or other event is triggered.


Properties:
----------
-	q{}				:	Temporary queue object for trackEvent object calls made before the trackEvent library is loaded.
-	filesToLoad[]	:	The list of synchronous libraries to be loaded. This is built in cdc.ut.liveManager.loadFiles. The push order of this array is the order they will be initialized.
-	fileIsLoaded{}	:	*This is just used as a boolean flag?* this is used to make sure <cdc.ut.liveManager.LOAD> only runs once per library.
-	loadedFileCount :	Counter to store the number of libraries loaded synchronously.
-	o				:	Onload flag for the individual loaded synchronous libraries.
-	lmIsLoaded		:	Onload flag for liveManager to ensure the onload is called only once. We attach to the window onload and also set a 3 second timeout for loading in case the window onload is never triggered.
-	i				:	Utility image object for sending immediate tracking from liveManager directly.

*/


cdc.ut.liveManager = {
    q: {},
    filesToLoad: [],
    fileIsLoaded: {},
    loadedFileCount: 0,
    o: 0,
    lmIsLoaded: 0,
    img: [],

/*
Method: cdc.ut.liveManager.loadFiles()

Description:
loadFile is the dom injection routine for creating a new script element in the head of the document.

Sample Usage:
Notice only one param passed in, it is a json object with 5 members. Structure like below:
	>	cdc.ut.liveManager.loadFiles({
	>		nodeIdSuffix:"dop",
	>		fileURL:"//cdn.tealium.com/deployment_toolkit/cisco/v2/release/dop.js?v="+cdc.ut.liveManager.trackingVariables["tag"],
	>		notAsync:1,
	>		callback:"cdc.ut.liveManager.dop.INIT()",
	>		initScript:"cdc.ut.liveManager.dop.ONLOAD()"
	>	});


Params:
fileInformation	is a json object with 5 members. Each member contains the metric library information.

	-	fileInformation.nodeIdSuffix	:	Name of Library (namespace),
	-	fileInformation.fileURL			:	URI location to JS file,
	-	fileInformation.notAsync		:	Synchronous flag(0-async, 1-sync),
	-	fileInformation.callback		:	Code to be evaluated in <cdc.ut.liveManager.LOAD()> when the script element is loaded. Each synchronous file loaded should have a <cdc.ut.liveManager.LOAD> trigger
											calling back to cdc.ut.liveManager with the appropriate namespace value. Only called in synchronous mode.
	-	fileInformation.initScript		:	Code to be evaluated when the script element is created.

*/

	loadFiles: function (fileInformation) {

		if(fileInformation.notAsync)
		{
			this.filesToLoad.push(fileInformation);
		}
		if(document.createElement)
		{
			var nodeId = "Lm_" + fileInformation.nodeIdSuffix;
			if (!document.getElementById (nodeId))
			{
				try{
					eval(fileInformation.initScript)
				} catch(exceptionObj) {};

				var scriptNode = document.createElement('script');
				scriptNode.language = 'javascript';
				scriptNode.type = 'text/javascript';
				scriptNode.src = fileInformation.fileURL;
				scriptNode.id = nodeId;
				document.getElementsByTagName("head")[0].appendChild (scriptNode);
			}
		}
	},

/*
Method: cdc.ut.liveManager.LOAD()

Description:
	When <loadFiles()> loads a library synchronously, Then callback function get trigger and call this function.
	looks more like this function is what triggers the callback??


	Sample Usage:
	try{cdc.ut.liveManager.LOAD("MYLIB")}catch(e){}

	Params:
	- libraryName : namespace of the library to load

	Utility Variables:
	- count : Length of the cdc.ut.liveManager.loadedFileCount
	- aFile : Reference to object passed in the cdc.ut.liveManager.loadFiles call

*/

    LOAD: function (libraryName) {
        this.fileIsLoaded[libraryName] = 0;
        var count = this.filesToLoad.length;
        for (var i = this.loadedFileCount; i<count; i++)
		{
            var aFile = this.filesToLoad[i];
            if (this.fileIsLoaded[aFile.nodeIdSuffix] == 0)
			{
                this.fileIsLoaded[aFile.nodeIdSuffix] = ++this.loadedFileCount;
                try
				{
                    eval(aFile.callback);
                } catch(e){
				}
            }else{
				return;
			}
        }
        if(this.loadedFileCount == count && this.o == 0)
		{
			this.o = 1;
		}
    },


/*
Method: cdc.ut.liveManager.bindEvent()

Description:
	Utility addEventListener / attachEvent function.
	The prefix "on" for Internet Explorer attachEvent handling is explicitly added.

Sample Usage:
cdc.ut.liveManager.bindEvent("window","load",myLoadFunction)

Params:
-	domElement	:	Event object
-	eventName	:	Event name
-	callback	:	Event handler
-	useOnPrevix	:	Flag if set to 1 will not prefix the "on" substring to the event name.
					This is used for any event to attach to that does not start with the prefix "on"

*/

    bindEvent: function(domElement, eventName, callback, dontUseOnPrefix) {
        if(domElement.addEventListener)
		{
            domElement.addEventListener(eventName, callback, false)
        }
		else if(domElement.attachEvent)
		{
            domElement.attachEvent(((dontUseOnPrefix == 1)?"":"on")+eventName, callback)
        }
    }
}

/*
Property: cdc.ut.liveManager.getEnvConfig :{
	domainURL: "//www.cisco.com", // asset loading domain
	ntpage_domain:"//cisco-tags.cisco.com" // sensor path domain for ntapge
}
Description:
This defines various environment domain configurations like dev, stage, prod etc.,
which in turn are used in loading UT assets for the respective environments.
** If Environment is not detected, UT assets are loaded relative to the domain, it is accessed on
*/
cdc.ut.liveManager.getEnvConfig =(function(){
	try{
		if(typeof cdc !== "undefined" && typeof cdc.util.findEnvironment !== "undefined" ) {
         var currentEnv = cdc.util.findEnvironment();
        //  console.log("Current Environment", currentEnv);
         switch (currentEnv) {
             case "dev":
             return{
             	domainUrl:"//fdk-devint.cisco.com",
             	ntpage_domain:"//cisco-tags-stg.cisco.com"
             };
             break;
             case "stage":
             return{
             	domainUrl: cdc.util.matchesTrueWemEnv() ? "" : "//fdk-stage.cisco.com",
             	ntpage_domain:"//cisco-tags-stg.cisco.com"
             };
             break;
             case "prod":
             return{
             	domainUrl:"//www.cisco.com",
             	ntpage_domain:"//cisco-tags.cisco.com"
             };
             break;
             case "unknown":
             return{
             	domainUrl:"",
             	ntpage_domain:""
             };
             break;
         }
      	}else{
      		return{
             	domainUrl:"",
             	ntpage_domain:""
            };
      	}
	}catch(e) {
		return{
             	domainUrl:"",
             	ntpage_domain:""
           };
	}

})();

/*
 Property: cdc.ut.liveManager.config

 Description:
 *main configuration variable*, sets defaults that can be overridden in page markup by <set()>.

 -	domain					:	Holds cookie domain value (typically cosco.com)
 -	passthru				:	Determine if any unmapped attribute is passed through to Omniture Insight.
 -	sc_acct					:	Default SiteCatalyst account.
 -	sc_test					:	Test mode for SiteCatalyst. In test mode all SiteCatalyst traffic goes to cisco-dev, suite value is sent into prop46.
 -	sc_testaccount			:	Report suite to use for test mode
  -	dop_src					:	Relative path to a dop.js file to use in lieu of the livemanager configuration.
 -	dop_sensor				:
 -	s_code_src				:	Relative path to a s_code.js file to use in lieu of the livemanager configuration.
 -	s_code_ut_src			:	Relative path to a s_code_ut.js file to use in lieu of the livemanager configuration.
 -	trackevent_src			:	Relative path to a trackEvent.js file to use in lieu of the livemanager configuration.
 -	rs_map_src				:	Relative path to a rs_map.js file to use in lieu of the livemanager configuration.
 -	visualsciences_ut_src	:	Relative path to a visualsciences_ut.js file to use in lieu of the livemanager configuration.
 -	dev_domain				:	Array of the domain list
 -	send					:	Object to turn on individual vendors: s_code and dop

 -	ntpagetag_src			:	Disabled for the moment.
 -	ntpagetag_sensor		:	Disabled for the moment.
 -	ntpagetag_sensor_secure	:	Disabled for the moment.


 - dop_ is : visual science parameters
 - sc_ is : site catalyst parameters

*/
cdc.ut.liveManager.config = {
    domain: ".cisco.com",
    exit_domain: ".cisco.com",
    passthru: true,
    sc_acct: "cisco-us",
    sc_test: false,
    sc_testaccount: "cisco-dev",
	s_code_src: cdc.ut.liveManager.getEnvConfig.domainUrl+"/etc/designs/cdc/fw/m/s_code.min.js",
	s_code_ut_src: cdc.ut.liveManager.getEnvConfig.domainUrl+"/etc/designs/cdc/fw/m/s_code_ut.min.js",
	trackevent_src: cdc.ut.liveManager.getEnvConfig.domainUrl+"/etc/designs/cdc/fw/m/trackEvent.min.js",
    rs_map_src: cdc.ut.liveManager.getEnvConfig.domainUrl+"/web/fw/m/rs_map.min.js",
	ntpagetag_src: cdc.ut.liveManager.getEnvConfig.domainUrl+"/etc/designs/cdc/fw/m/ntpagetag.min.js",
    ntpagetag_sensor: cdc.ut.liveManager.getEnvConfig.ntpage_domain+"/tag/ntpagetag.gif",
    ntpagetag_sensor_secure: cdc.ut.liveManager.getEnvConfig.ntpage_domain+"/tag/ntpagetag.gif",
// to do see if this dev_domain param can be eliminated entirely along with the function below at line 345 that calls it.
    dev_domain: [],
    send: {
        s_code: true,
        tnt: true,
        ntpagetag: false
    }
}
/* ** HOMEPAGE - override code library locations for home page as needed (if there is a divergence)** */
if (typeof cdc.homepage!= "undefined" && cdc.homepage.isHomepage == true) {
	cdc.ut.liveManager.config.rs_map_src = cdc.ut.liveManager.getEnvConfig.domainUrl+"/web/fw/m/rs_map.home.min.js";
	cdc.ut.liveManager.config.rs_map_src_cache = cdc.ut.liveManager.getEnvConfig.domainUrl+"/web/fw/m/rs_map.min.js";
}

/*
  Property: lh - Runtime init code (not in function)

  Description:
  Adds some values to <config> based on location.hostname
*/
cdc.ut.liveManager.lh = location.hostname;
/*
for (cdc.ut.liveManager.i = 0; cdc.ut.liveManager.i < cdc.ut.liveManager.config["dev_domain"].length; cdc.ut.liveManager.i++) {
    if (cdc.ut.liveManager.lh.indexOf(cdc.ut.liveManager.config["dev_domain"][cdc.ut.liveManager.i]) == 0) {
        cdc.ut.liveManager.config.preview = true;
        cdc.ut.liveManager.config.dop_sensor = "//preview.cisco.com/web/fw/tools/mktg_metrics/flashtag.txt?Log=1";
        for(var i in cdc.ut.liveManager.config){
            var j=cdc.ut.liveManager.config[i];
            if(typeof j=="string"&&i.indexOf("_src")>0){
                cdc.ut.liveManager.config[i]=j.replace("www.","preview.");
            }
        }
        break;
    }
}
*/
/*
  Property: localConfig - Runtime init code (not in function)

  Description:
  Makes a call to cdc.util.ut.getConfigInfo to retrieve override configuration values for testability
*/
try{
    cdc.ut.liveManager.localConfig = cdc.util.ut.getConfigInfo();
    if(cdc.ut.liveManager.localConfig !== false){
	for(var i in cdc.ut.liveManager.localConfig){
	    if(typeof cdc.ut.liveManager.localConfig[i]!='function'){
		if(i!='send'&&i!='dopconfig'&&i!='ntconfig') cdc.ut.liveManager.config[i] = cdc.ut.liveManager.localConfig[i];
	    }
	}
	//Bookmarklet feature to override location of rs_map.home.js
	if (typeof cdc.homepage!= "undefined" && cdc.homepage.isHomepage == true) {
		cdc.ut.liveManager.config.rs_map_src = cdc.ut.liveManager.localConfig['rs_map_home_src'];
	}
	//ignore ntconfig and dopconfig
	try{cdc.ut.liveManager.config.ntpagetag_sensor=cdc.ut.liveManager.localConfig.ntconfig.send.ntpagetag_sensor;}catch(e){}
	try{cdc.ut.liveManager.config.ntpagetag_sensor_secure=cdc.ut.liveManager.localConfig.ntconfig.send.ntpagetag_sensor_secure;}catch(e){}

	//merge send
	if(typeof cdc.ut.liveManager.localConfig['send']!='undefined'){
	    for(var i in cdc.ut.liveManager.localConfig.send){
		if(typeof cdc.ut.liveManager.localConfig.send[i]!='function'){
		    cdc.ut.liveManager.config.send[i] = cdc.ut.liveManager.localConfig.send[i];
		}
	    }
	}
    }
}catch(e){}

cdc.ut.liveManager.storeRequest=function(id,url){
    try{
	if(cdc.ut.liveManager.config.store_requests[id]==true && sessionStorage){
	    var requestCounter = sessionStorage.getItem(id+'_rc');
	    if(!requestCounter){
	        requestCounter = 0;
	    }
	    sessionStorage.setItem(id+'_r'+requestCounter,url);
	    sessionStorage.setItem(id+'_rc',parseInt(requestCounter)+1);
	}
    }catch(e){}
}

/*
Object: cdc.ut.trackEvent

Description:
	Creates the trackEvent.event queue
	- for handling <trackEvent.event> calls that come before the trackEvent library is loaded
	- called any time trackEvent is called before the onLoad event
	- uses .t["tag"] which is ut code version id for result sniffing purposes
*/
if(typeof cdc.ut.eventqueue.q=="undefined")cdc.ut.eventqueue.q=[];
//Check if trackEvent.event (queue functionality) is not defined on the page
if (typeof cdc.ut.trackEvent.event == "undefined") {
	cdc.ut.trackEvent = {
		event: function(a, b) {
			var d = "";
			for (var c in b) {
				d += "&" + c + "=" + b[c];
			}
			b["tag"] = cdc.ut.liveManager.trackingVariables["tag"];
			cdc.ut.eventqueue.q.push({
				a: a,
				b: b
			});
		}
	};
}


//FIX flash coded videos to reference cdc.ut.trackEvent instead of trackEvent. this is a timing issue that needs to be handled carefully
/* this line is used for backwards compatibility with flash tracking that tries to access the trackEvent object directly */
var trackEvent = cdc.ut.trackEvent;

/*
Procedure:
Stripping subdomains (code block not a function).

Description:
used to strip certain subdomains from the basepage dimension, used in setting cdc.ut.liveManager.trackingVariables.basepage value

-	pageLocation	:	pageLocation is holds the page path with hostname.
-	subDomains		:	subDomains is array type property and it holds the list of subdomains.

*/

cdc.ut.liveManager.pageLocation = location.hostname + location.pathname;
cdc.ut.liveManager.du = (document.URL.split("?"))[0];
if(cdc.ut.liveManager.du.indexOf("#")>0&&cdc.ut.liveManager.du.lastIndexOf("/") > cdc.ut.liveManager.du.indexOf("#")){
	cdc.ut.liveManager.pageLocation += location.hash;
}

/* need to investigate use of this array and eliminating it!! ajb */
cdc.ut.liveManager.subDomains = new Array('www.', 'ecmx-wip.', 'ecmx-staging.', 'ecmx-active.', 'wwwin-tools-stage.', 'cco-rtp-1.', 'dev-stage.', 'tools-stage.', 'wwwin-tools-dev.');

for (cdc.ut.liveManager.i = 0; cdc.ut.liveManager.i < cdc.ut.liveManager.subDomains.length; cdc.ut.liveManager.i++){
	cdc.ut.liveManager.pageLocation = cdc.ut.liveManager.pageLocation.replace(cdc.ut.liveManager.subDomains[cdc.ut.liveManager.i], '');
}

if (cdc.ut.liveManager.pageLocation.lastIndexOf('/') == cdc.ut.liveManager.pageLocation.length - 1){
	cdc.ut.liveManager.pageLocation = cdc.ut.liveManager.pageLocation.substring(0, cdc.ut.liveManager.pageLocation.length - 1);
}

/*
Properties: cdc.ut.liveManager.trackingVariables

Description:
-	Holds main page tracking variables.
-	tag, basepage, elementtype, title, url, property, referrer, linktrack are set as default variables. these variable contains page level information.
-	As per the HTML page additional variable are set. These variables contains meta tags information and few page level data.


Examples:
http://cdc-site-dev.cisco.com:2013/API-examples/base-cdc-page.shtml

*These are set as defaults variables*
- tag					:	"ut2.2.20100128.00000.8625082555471705"
- basepage			:	"localhost/univeral_tagging/API-examples/base-cdc-page.shtml"
- elementtype			:	"page"
- title				:	"Universal Tagging - API Examples - Support IA path - Cisco Systems"
- url					:	"http://localhost/univeral_tagging/API-examples/base-cdc-page.shtml"
- property			:	"Cisco"
- referrer			:	"http://localhost/univeral_tagging/API-examples/"
- linktrack			:	"linkpage"

*Additinal variables set according to page*

- d_h1				:	"products/cisco products/cisco interfaces and modules/cisco physical security modules for routers/cisco integrated storage system module"
- d_h2				:	"products"
- d_h3				:	"products/cisco products"
- d_h4				:	"products/cisco products/cisco interfaces and modules"
- d_h5				:	"products/cisco products/cisco interfaces and modules/cisco physical security modules for routers"
- d_lc				:	"en-us"
- hinav				:	"index"
- loc					:	"http://localhost/univeral_tagging/API-examples/base-cdc-page.shtml"

- meta.accesslevel	:	"guest"
- meta.acronym		:	"iss"
- meta.concept		:	"cisco integrated storage system module"
- meta.contenttype	:	"cisco.com#us#postsales"
- meta.country		:	"us"
- meta.doctype		:	"tsd products support model home"
- meta.iapath			:	"products/cisco products/cisco interfaces and modules/cisco physical security modules for routers/cisco integrated storage system module"
- meta.language		:	"en"
- meta.locale			:	"us"
- meta.synonym		:	"video storage"
- meta.title			:	"cisco integrated storage system module - support"

- prevpage			:	""
- repeat				:	"Repeat"
- sa_source			:	"meta.iapath"
- site				:	"products"
- sitearea			:	"cisco.com#products#cisco products#cisco interfaces and modules#cisco physical security modules for routers#cisco integrated storage system module"
- suite				:	"cisco-us,cisco-usprodinterfaces"
- treecrumb			:	""
- vid					:	""

*/

cdc.ut.liveManager.trackingVariables = {
    //base variables
    basepage: cdc.ut.liveManager.pageLocation,
    property: "Cisco",
    tag: "ut2.0.20100823.1200",
    title: document.title,
    url: document.URL,
    referrer: eval("document." + "referrer"),
    linktrack: "linkpage",
    elementtype: "page"
};

// Logic to set document.referrer which is lost because of the login redirect
try {
	if ( typeof cdc.login == 'undefined') {
		//If user was on a login page, rely on cookie for referrer
		if (cdc.cookie.getCookie('wasOnLoginPage') == 'true') {
			cdc.ut.liveManager.trackingVariables.referrer = cdc.cookie.getCookie('loginPageReferrer');
			cdc.cookie.setCookie({cookieName : 'wasOnLoginPage',cookieValue : 'false',domain : '.cisco.com'});
		}
	} else {
		//If it is on a login page save the referrer in a cookie
		cdc.cookie.setCookie({cookieName : 'wasOnLoginPage',cookieValue : 'true',domain : '.cisco.com'});
		cdc.cookie.setCookie({cookieName : 'loginPageReferrer',cookieValue : document.referrer,domain : '.cisco.com'});
	}
} catch(e) {}

cdc.ut.liveManager.trackingVariables["loc"] = "http://" + cdc.ut.liveManager.trackingVariables["basepage"];
/*
Method: cdc.ut.liveManager.getCookieData()

Description:
- Read prev page cookie information.

Params:
-	cookieName : Cookie name

Utility Variables:
- equalindex	: Contains the index for cookiename=.
- colenIndex	: Contains the index of semicolen;
*/

cdc.ut.liveManager.getCookieData = function(cookieName) {
    var equalIndex = document.cookie.indexOf(cookieName + "=");
    var colenIndex = "";
    if (equalIndex > -1)
	{
        colenIndex = document.cookie.indexOf(";", equalIndex + 1);
        colenIndex = (colenIndex > 0)? colenIndex : document.cookie.length;
        colenIndex = (colenIndex > equalIndex)? document.cookie.substring(equalIndex + cookieName.length + 1, colenIndex) : ""
    }
    return colenIndex;
};

cdc.ut.liveManager.getPrevpage = function(){
    var x=eval("document."+"referrer");

    x = x.replace(/^https:\/\/|^http:\/\//,"");
    x = x.replace(/^www\./,"");
    var a = x.split("?");
    x = a[0];
    if(x.charAt(x.length-1)=='/'){
    	x=x.substring(0,x.length-1);
    }
    if(x.length > 255){
        x = x.substring(0,255);
    }
    return x;
}

cdc.ut.liveManager.trackingVariables["prevpage"] = cdc.ut.liveManager.getPrevpage();


/*
Method:cdc.ut.liveManager.presend()

Description:
-	Referring site tracking function called in line.
-	If a name-value pair for referring_site, position, campaign, keyword, creative or country is in this page's URL querystring, this lets visual sciences know.
-	The check for existence of "referring_site" is case insensitive.

Additional Variables:
-	referringSiteName is Array of referring site names to check for. The order is important as it's the hierarchy order for sitecatalyst
-	searchString is the search string value.
-	a,b,d are utility variables.
- e is a utility array to store the campaign values that will be joined and sent to sitecatalyst
-	c - 1st life as utility variable, reincarnated as the tag sent to VS

*/

cdc.ut.liveManager.presend=function(){
    try {
		var referringSiteName = ["campaign", "country_site", "position", "referring_site", "creative", "keyword"];
		var searchString = location.search;
		if(searchString == ""){
			var du=document.URL;
			var i1=du.indexOf("#");
			var i2=du.indexOf("?");
			if(i2>i1){
				searchString = "?" + (du.split("?"))[1];
			}
		}
		searchString = searchString.toLowerCase();
		cdc.ut.liveManager.searchString = searchString;
        var a, b, c, d, e=[];

        for(a=0; a < referringSiteName.length; a++)
		{
            if(searchString.indexOf(referringSiteName[a]) > 0)
			{
                a = searchString.substring(1).split('&');
                b={};
                for (d = 0; d < a.length; d++)
				{
                    c = a[d].split("=");
                    b[c[0]] = unescape(c[1]);
                }

				c = "&tag=" + cdc.ut.liveManager.trackingVariables["tag"] + "&vs_basepage=" + escape(cdc.ut.liveManager.trackingVariables["basepage"]) + "&vs_elementtype=page&vs_event=campaign&vs_url=" + escape(document.URL);

				for (d = 0; d < referringSiteName.length; d++)
				{
                    if (typeof b[referringSiteName[d]] != "undefined")
					{
						c += "&" + referringSiteName[d] + "=" + escape(b[referringSiteName[d]]);
						e.push(escape(b[referringSiteName[d]]));
					}
                }

                d=document.cookie;
                var d1=d.indexOf("CP_GUTC"),d2=d.indexOf(";",d1),vid="";
                if(d2>d1&&d1>=0){
                    vid=d.substring(d1+8,d2);
                }
				c+="&vs_vid="+vid;

				var g=cdc.ut.liveManager.config.dop_sensor.split(",");
				var idx=0;
				for(var f=0;f<g.length;f++){
	                idx=cdc.ut.liveManager.img.push(new Image());
	                cdc.ut.liveManager.img[idx-1].src = g[f] + c;
				}

				break;
            }
        }
    } catch(e) {}
}

if (typeof lm_libloadedflag == "undefined") {
    cdc.ut.liveManager.presend();
}

/*
Method: cdc.ut.liveManager.ONLOAD()

Description:
-	Main ONLOAD handler of liveManager.
-	This queues the cdc.ut.liveManager.loadFiles calls
-	Ensures we load the libraries after the document body is loaded,
-	The supporting libraries are loaded when this handler is invoked.

Notes:
- Avoids repeat loading of Site Catalyst code
- If there is already the instance of an s_account variable (SiteCatalyst) the s_code_ut.js is not loaded and the s_code send flag is set to false to allow the existing implementation to handle the SiteCatalyst tracking.

Sample Usage:
cdc.ut.liveManager.ONLOAD();

 Additional Variables Used:
 -	<cdc.ut.liveManager.lmIsLoaded> : onload flag used to ensure the cdc.ut.liveManager.ONLOAD handler is loaded only once.
 */

cdc.ut.liveManager.ONLOAD = function() {
    /* cdc.ut.config overrides */

	if(typeof cdc.ut.config!="undefined"){
        for(a in cdc.ut.config){
            if(typeof cdc.ut.config[a]!="function"){
                b=a.split(".");
                if(b.length==2&&typeof cdc.ut.liveManager.config[b[0]][b[1]]!="undefined"){
					cdc.ut.liveManager.config[b[0]][b[1]]=cdc.ut.config[a];
				}else if(b.length==1&&typeof cdc.ut.liveManager.config[b[0]]!="undefined"){
					cdc.ut.liveManager.config[b[0]]=cdc.ut.config[a];
				}
            }
        }

        if(typeof cdc.ut.config["tag"]!="undefined"){
			cdc.ut.liveManager.t["tag"]=cdc.ut.config["tag"];
		}

        if(typeof cdc.ut.config["noload"]!="undefined"&&(cdc.ut.config["noload"]=="true"||cdc.ut.config["noload"]==true)){
			cdc.ut.liveManager.lmIsLoaded=1;
		}
    }

    /* ensure liveManager only loads the onload directives only once */
    if (cdc.ut.liveManager.lmIsLoaded == 1){
		return;
	}

    cdc.ut.liveManager.lmIsLoaded = 1;

    /* load rs_map support */
    if(cdc.ut.liveManager.config['rs_map_src'] != ''){
	cdc.ut.liveManager.loadFiles({
	    nodeIdSuffix: "rs_map",
	    fileURL: cdc.ut.liveManager.config["rs_map_src"]+"?v=" + cdc.ut.liveManager.trackingVariables["tag"],
	    notAsync: 0
	});
    }

	if (typeof cdc.homepage!= "undefined" && cdc.homepage.isHomepage == true) {
       try{
           if(cdc.ut.liveManager.config["rs_map_src_cache"]){
            cdc.ut.liveManager.loadFiles({
                nodeIdSuffix: "rs_map_cache",
                fileURL: cdc.ut.liveManager.config["rs_map_src_cache"]+"?v=" + cdc.ut.liveManager.trackingVariables["tag"],
                notAsync: 0
            });}
        }catch(e){}
    }

    /* load sitecatalyst support - if s_code.js is already loaded on the page, do not load again unless we are on a webex page */
    if ((typeof s_account == "undefined") || (s.visitorNamespace == "webex")){
        var src=cdc.ut.liveManager.config["s_code_ut_src"];
    /* use s_code_ut_src as default, but if from one of below theaters use s_code_src instead */
        var lp=(""+location.pathname).toLowerCase();
        var m=(new RegExp(/\/web\/\w{2}\//)).exec(lp);
        if(m!=null){
            m=m.toString();
            if(m.indexOf("/web/us/")==-1&&m.indexOf("/web/fw/")==-1)src=cdc.ut.liveManager.config["s_code_src"];
        }
	if(src != ''){
	    cdc.ut.liveManager.loadFiles({
	        nodeIdSuffix: "s_code",
	        fileURL: src+"?v=" + cdc.ut.liveManager.trackingVariables["tag"],
	        notAsync: 1
	    });
	}
    }else{
        /* set the following flag to false when testing with no data to be sent to sitecatalyst or s_account is defined */
        cdc.ut.liveManager.config.send["s_code"] = false;
    }

    /* load ntpagetag support */
    if(cdc.ut.liveManager.config['ntpagetag_src'] != ''){
	if(typeof NTPT_IMGSRC == "undefined"){
	    cdc.ut.liveManager.loadFiles({
	    	nodeIdSuffix: "ntpagetag",
		fileURL: cdc.ut.liveManager.config["ntpagetag_src"]+"?v=" + cdc.ut.liveManager.trackingVariables["tag"],
		notAsync: 1,
		callback: "NTPT_UT.init()",
		initScript: "NTPT_NOINITIALTAG='true'"
	    });
	}
    }

    /* load trackEvent support */
    if(cdc.ut.liveManager.config['trackevent_src'] != ''){
	cdc.ut.liveManager.loadFiles({
	    nodeIdSuffix: "trackEvent",
	    fileURL: cdc.ut.liveManager.config["trackevent_src"]+"?v=" + cdc.ut.liveManager.trackingVariables["tag"],
	    notAsync: 1,
	    callback: "cdc.ut.liveManager.getPageData();cdc.ut.trackEvent.INIT();if(typeof cdcPageTimers!='undefined')cdcPageTimers.utsent=new Date();cdc.ut.trackEvent.event('view',cdc.ut.liveManager.trackingVariables)"
	});
    }

    if(typeof cdcPageTimers!="undefined")cdcPageTimers.utloaded=new Date();
    /* BazaarVoice Integration Functionality - ratingsDisplayed callback
    ratingsDisplayed = function(totalReviewCount, avgRating, totalRatingOnlyCount, buyAgainPercentage) {
        if (totalReviewCount > 0 || totalRatingOnlyCount > 0) {
            cdc.ut.trackEvent.event("custom", {
                bv_event: "bv_ratingdisplayed",
                bv_reviewcount: totalReviewCount,
                bv_avgrating: avgRating,
                bv_rating_only: totalRatingOnlyCount,
                bv_buyagain: buyAgainPercentage
            });
        }
    }

     BazaarVoice Integration Functionality - pageChanged callback
    pageChanged = function(pageName, pageStatus) {
        cdc.ut.trackEvent.event("custom", {
            bv_event: "bv_pagechanged",
            bv_page: pageName,
            bv_status: pageStatus
        });
    }
    */
}

/*
 Method: ONERROR

 Description:
*Custom error handler*
    - adds value of error message to cdc.ut.liveManager.error,
    - sets cdc.ut.liveManager.erf flag to guarantee only first error processed
    - this function is then attachaed to the window.error handler
    -  not sure why needed???

 Sample Usage:
 This is triggered if there is an error. Does nothing if it's been called already.

 Params:
  - a - error string object
  - b - url of the invoking error
  - c - error line number

 Additional Variables Used:
  - cdc.ut.liveManager.erf - error flag
  - cdc.ut.liveManager.error - error message
*/
cdc.ut.liveManager.ONERROR = function(a, b, c) {
    if (cdc.ut.liveManager.erf != 1)
	{
        cdc.ut.liveManager.error = (typeof a == "string") ? (a + "-" + c) : "Unknown";
        cdc.ut.liveManager.erf = 1
    }
}

/* Attach cdc.ut.liveManager.ONERROR to the window.error event */
cdc.ut.liveManager.bindEvent(window, "error", cdc.ut.liveManager.ONERROR);

/*
Method: cdc.ut.liveManager.getPageData()

Description:
-	 //set by cdtm.js This is a callback method of trackEvent.js.
-	First <cdc.ut.liveManager.loadFiles()> method load the trackEvent library in the head section of the page.
-	Once trackEvent.js is loaded then it load the callback methods through <cdc.ut.liveManager.LOAD()> method.
	try{cdc.ut.liveManager.LOAD("trackEvent")}catch(e){}
-	<cdc.ut.liveManager.LOAD()> method calls <cdc.ut.liveManager.getPageData()> method. This method analyzes page data to find site area and more and stores them in <t> object.

Details:
-	Collects data from meta tags that aren't in the ignore list (ignores description, keywords, date, pubdate, pushdate, docRequest, synonym)
-	Looks for site area in hinav
-	Looks for site area in treecrumb
-	If an object called track is in page the info is caputred here
-	Uses site area from meta.iapath if present, then hinav or treecrumb if no iapath and these exist, records which was used.


Utility Variables:
-	metaElementsList:	Variable that hold the all meta tags information on the page. It contains the values of meta attributes name & content
-	divElementsList	:	Variable that hold the all div tags information on the page.
-	contentArr		:	Array variable holds divElementsList contents which contains class 'hinav'.
-	linkArr			:	Array varibale holds the name of link from contentArr elements.
-	startIndex		:	Hold the start position of given value.
-	endIndex		:	Hold the end position of given value.

*/

cdc.ut.liveManager.getPageData = function() {

/* Meta data variables to be read and loaded into the cdc.ut.liveManager.trackingVariables object. Meta data keys that exist in the ex object are ignored */
    var ignoredMetaTagList = {
        description: 1,
        keywords: 1,
        date: 1,
        pubdate: 1,
        pushdate: 1,
        docRequest: 1,
        synonym: 1
    }
    var metaElementsList = document.getElementsByTagName("meta");

    for(var b = 0; b < metaElementsList.length; b++)
	{
        if (metaElementsList[b].name && metaElementsList[b].name != "" && typeof ignoredMetaTagList[metaElementsList[b].name] == "undefined")
		{
            cdc.ut.liveManager.trackingVariables["meta." + metaElementsList[b].name.toLowerCase()] = metaElementsList[b].content.toLowerCase()
        }
    }

/*

Description:
Dom parsing for the hinav value. The parsed value is added to the cdc.ut.liveManager.trackingVariables["hinav"] attribute

Utility Variables:
-	divElementsList	:	It is a DOM Object and it is holding all DIV tag information on the page.
-	contentArr		:	It is an Array type variable and it is holding the content of div which contains the class name 'hinav'.
-	divContent		:	It is obejct type utility variable. It holds the string value for div which contains the class name 'hinav'.
-	linkArr			:	It is array type utility variable. Arrya elements holds the name of the href link.
-	startIndex		:	Utility variable holds the position of this symbol '>' in the specified string.
-	endIndex		:	Utility variable holds the position of this symbol '<' in the specified string.

*/
    var divElementsList = document.getElementsByTagName("div");
    var contentArr = [];
    for(var c = 0; c < divElementsList.length; c++)
	{
        if (divElementsList[c].className == "hinav")
		{
			var divContent = divElementsList[c].innerHTML.split("<a");

			for (var f = 0; f < divContent.length; f++)
			{
                if (divContent[f].indexOf('class="parent"') > -1 || divContent[f].indexOf('class="selected"') > -1)
				{
					contentArr.push(divContent[f]);
				}
            }

            var linkArr = [];
            for (var e = 0; e < contentArr.length; e++)
			{
                contentArr[e] = (contentArr[e].split("&amp;")).join("&");
                contentArr[e] = contentArr[e].toLowerCase();
                var startIndex = contentArr[e].indexOf(">");
                var endIndex = contentArr[e].indexOf("<", f);
                linkArr.push(contentArr[e].substring(startIndex + 1, endIndex));
            }
            cdc.ut.liveManager.trackingVariables["hinav"] = linkArr.join("/");
            break;
        }
    }


/*

Description:
-	Dom parsing for the nav-treecrumb value. The parsed value is added to the cdc.ut.liveManager.trackingVariables["treecrumb"] attribute.

Utility Variable:
-	listObject		:	This a DOM object for all List elemets on the markup page.
-	parsedValue		:	Array contains the name of nav-treecrumb.
-	domClassName	:	Contains the class name of each list item.
-	domClassId		:	Contains the parent node ID of each list item.
-	tagEndPos		:	Holds the position of symbol '>' in specified string.
-	tagStartPos		:	Holds the position of symbol '<' in specified string.

*/

    if (typeof document.getElementById("nav-treecrumb") != "undefined")
	{
        var listObject = document.getElementsByTagName("li");
        var parsedValue = [];
        for (c = 0; c < listObject.length; c++)
		{
            var domClassName = listObject[c].className;
            var domClassId = listObject[c].parentNode.id;

			if (domClassId == "nav-treecrumb")
			{
                domClassId = listObject[c].innerHTML;
                if(domClassId){
					var tagEndPos = domClassId.indexOf('>');
					var tagStartPos = domClassId.indexOf('<', f);
					domClassId = domClassId.substring(tagEndPos + 1, tagStartPos);
					parsedValue.push((domClassId.split("&amp;")).join("&"))
				}
            }

			if (domClassName == "crumb-selected")
			{
				break
			}
        }
        cdc.ut.liveManager.trackingVariables["treecrumb"] = parsedValue.join("/")
    }

/*
Description:
Page level variables (not currently used). If an object named track exists on the page, its attributes will be read and added to the cdc.ut.liveManager.trackingVariables object.
*/

	if (typeof track != "undefined")
	{
        for (var a in track)
		{
            if (typeof a != "function")
			{
				cdc.ut.liveManager.trackingVariables[a] = track[a];
			}
        }
    }

/*
Description:
Sets the sitearea and sa_source values off either the meta.iapath, hinav or treecrumb values. This is used for measurement to determine which pages have an iapath. For those that don't they will be categorized by either the hinav or treecrumb value in that order.

Utility Variable:
- elements	:	An array type of variable holds name of meta.iapath element, hinav dom ID and treecrumb dom ID.
*/

    var elements = ["meta.iapath", "hinav", "treecrumb"];
    for (f = 0; f < elements.length; elements++)
	{
        if (typeof cdc.ut.liveManager.trackingVariables[elements[f]] != "undefined")
		{
            cdc.ut.liveManager.trackingVariables["sitearea"] = cdc.ut.liveManager.trackingVariables[elements[f]];
            cdc.ut.liveManager.trackingVariables["sa_source"] = elements[f];
            break;
        }
    }

/*
Description:
- livePerson keycode reader.
*/

    if(typeof lpMTagConfig != "undefined" && typeof lpMTagConfig.sessionVar != "undefined")
	{
		lpMTagConfig.sessionVarBackup = new Array();
        lpMTagConfig.sessionVarBackup = lpMTagConfig.sessionVar;
    }
}


/*
Method: cdc.ut.liveManager.getRSMapFileData()

Description:
- Analyzes the content in the rs_map.js file to determine SiteCatalyst Report Suite Values <t>

Details:
- Reads data from the ut_rs_map variable declared in the rs_map.js
- Looks for filter match in the url which matches to a SiteCatalyst report suites or an "exclude" directive

Sample Usage:
- This is called by trackEvent.js during the plugin that determines SiteCatalyst report suite.

Utility Variables:
- docURL = contains the URL of document.

*/

cdc.ut.liveManager.getRSMapFileData = function() {
    if (typeof ut_rs_map != "undefined")
	{
        var docURL = document.URL;
        for (i in ut_rs_map)
		{
            if (typeof ut_rs_map[i] == "string")
			{
                if (docURL.indexOf(i) > -1)
				{
					return ut_rs_map[i];
				}
            }
        }
    }
    return "";
};

/*
	Code Block: Calling cdc.ut.liveManager.ONLOAD
		- Try to call the cdc.ut.liveManager.ONLOAD handler when the jQuery document.ready is invoked.
		- If the handler fails, catch the error and attach to the window.load event, and also set a 3 second timeout to call cdc.ut.liveManager.ONLOAD.
		- These two are used to guarantee the cdc.ut.liveManager.ONLOAD function is invoked.
*/

// (function() {
//     // this loader is for cdtm.js only.
//     // It changes the source of cdtm.js based on envirnment.
//     // Switching the file source ensures that auth mechanism of the file
//     // matches the auth mechanism of the environment.
//     // This code will be deployed in WEM, 2.x, Portals, and miscellaneous micro sites.
//         var domain = location.hostname;
//         var filePath = "/c/dam/cdc/t/ctm.js";
//        var loadPath = "";
//        var loadDev = "//fdk-devint.cisco.com";
//        var loadStage = "//cloudsso-test.cisco.com";
//        var loadProd = "//www.cisco.com";
    
//        function load (src) {
//           var script = document.createElement('script');
//           script.src = src;
//           script.async = false;
//           script.setAttribute("data-config-src", "framework"); //added to capture the metrics source initiation info
//           document.getElementsByTagName('head')[0].appendChild(script);
//        }
//        function setPath () {
//           if(typeof cdc !== "undefined" && typeof cdc.util.findEnvironment !== "undefined" ) {
//              var currentEnvironment = cdc.util.findEnvironment();
//              switch (currentEnvironment) {
//                  case "dev":
//                  loadPath = loadDev;
//                  break;
//                  case "stage":
//                              loadPath = cdc.util.matchesTrueWemEnv() ? "" : loadStage;
//                  break;
//                  case "prod":
//                  loadPath = loadProd;
//                  break;
//                  case "unknown":
//                  loadPath = "";
//                  break;
//              }
//           } else {
//              loadPath = "";
//           }
    
//           var loadVar = loadPath + filePath; //Chrome hid my globals, FF didn't, so I just made a new local.
//           load(loadVar);
//        }
//        setPath();
//     })();

/*
 * this section has moved to cdtm.js
 */
/*
try {
    jQuery(document).ready(function() {
	if(typeof cdcPageTimers!='undefined')cdcPageTimers.utready=new Date();
        cdc.ut.liveManager.ONLOAD();
    })
} catch(e) {
    cdc.ut.liveManager.bindEvent(window, "load", cdc.ut.liveManager.ONLOAD);
    setTimeout("cdc.ut.liveManager.ONLOAD", 3000);
}
*/
var lm_libloadedflag = 1;



/*
Method: cdc.ut.liveManager.debugThis()

Description:
- Debug script that creates a pixel request containing a debug message

Sample Usage:
cdc.ut.liveManager.DB("my debug message");

Params:
- debugMsg - incoming debug message

Utility Variables:
- imgObj - local utility image object

*/

cdc.ut.liveManager.debugThis = function(debugMsg, imgObj) {
    imgObj = new Image();
    imgObj.src = "//cdn.tealium.com/track.gif?tag=ut2.0&msg=" + debugMsg;
}

cdc.ut.liveManager.t = cdc.ut.liveManager.trackingVariables;
cdc.ut.liveManager.A = cdc.ut.liveManager.loadFiles;
cdc.ut.liveManager.l = cdc.ut.liveManager.filesToLoad;

for(var i=0; i<cdc.ut.liveManager.filesToLoad.length; i++){
    cdc.ut.liveManager.filesToLoad[i].a=cdc.ut.liveManager.filesToLoad[i].nodeIdSuffix;
    cdc.ut.liveManager.filesToLoad[i].b=cdc.ut.liveManager.filesToLoad[i].fileURL;
    cdc.ut.liveManager.filesToLoad[i].c=cdc.ut.liveManager.filesToLoad[i].notAsync;
    cdc.ut.liveManager.filesToLoad[i].d=cdc.ut.liveManager.filesToLoad[i].initScript;
    cdc.ut.liveManager.filesToLoad[i].e=cdc.ut.liveManager.filesToLoad[i].callback;
}

cdc.ut.liveManager.cleanCookies=function(){
    var dc=document.cookie;
    var a=dc.split("; ");
    for(var i=0;i<a.length;i++){
		var b=a[i].split("=");
		//expire cookies that have a space in them
		if((b[0].indexOf("dgad_")==0) && (b[0].indexOf(" ")>-1)){
		    document.cookie = b[0] + "=;path=/;domain=.cisco.com;expires=Thu, 31 Dec 2009 00:00:00 GMT";
		    b[0]=(b[0].split(" ")).join("_");
		    document.cookie = b[0] + "=" + b[1] + ";path=/;domain=.cisco.com;";
			//reset dgad cookies to session
		}else if(b[0].indexOf("dgad_")==0){
		    document.cookie = b[0] + "=;path=/;domain=.cisco.com;expires=Thu, 31 Dec 2009 00:00:00 GMT";
		    document.cookie = b[0] + "=" + b[1] + ";path=/;domain=.cisco.com;";
		}
    }


	if(dc.length > 3500){
		var cObj = {};
		cdc.util.ensureNamespace("cdc.ut.cdcLargeCookies");
		dc = dc.split("; ");
		// create an object of large cookies over 250k to be tracked later
		for(var i=0;i<dc.length;i++){
			var j=dc[i].split("=");
			cObj[j[0]] = j[1];
			if(j[1].length > 250) {
				cdc.ut.cdcLargeCookies[j[0]]=j[1].length;
			}
		}
		cdc.ut.cdcLargeCookies["cdc_ut"] = 0;
		cdc.ut.cdcLargeCookies["mbox"] = 0;
		cdc.ut.cdcLargeCookies["dgad"] = 0;
		cdc.ut.cdcLargeCookies["sc"] = 0;
		cdc.ut.cdcLargeCookies["utm"] = 0;

		for(var i in cObj){
			if(typeof cObj[i] != "function"){
				if((i=="cdc_ut") || (i=="mbox") || (i.indexOf("dgad_")==0) || (i.indexOf("s_")==0) || (i.indexOf("__utm")==0)) {
					var cClass = i;
					//create useable class names
					if (cClass.indexOf("dgad_") == 0) {
						cClass = "dgad";
					}
					if (cClass.indexOf("s_") == 0) {
						cClass = "sc";
					}
					if (cClass.indexOf("__utm") == 0) {
						cClass = "utm";
					}


					if((typeof cdc.ut.cdcLargeCookies[i]!='undefined') && (cdc.ut.cdcLargeCookies[i]!= 0)) {
						cdc.ut.cdcLargeCookies[i]+=':d';
						// always send for large cookies already in largeCookies obj
					} else {
						// send total size of each cookie class
						cdc.ut.cdcLargeCookies[cClass] += cObj[i].length;
					}
					document.cookie=i+"=;path=/;domain=.cisco.com;expires=Thu, 31 Dec 2009 00:00:00 GMT";
				}
			}
		}
	}
};
try{cdc.ut.liveManager.cleanCookies();}catch(e){};

/*
 * rfw-rules.js
 * $Revision: 1.2.4.3 $ <-meaningless revision numbers
 * Metrics rules for responsive homepage
 * Parts of mb-rules will be added here, as the header and footer will now be forked from masterbrand
 * until all of masterbrand is converted to responsive.
 */


(function ($) {

	// parent rule for the entire banner
	cdc.util.addMetricsRule('li[id$="-mm-item"] a[href]', function(a){
	return {
		lpos:'header_mb_'+$(a).closest('li[id$="-mm-item"]').attr('id').replace('-mm-item',''),
		lid:'header_mb_'+$(a).closest('li[id$="-mm-item"]').attr('id').replace('-mm-item','')
	};
	})

	cdc.util.addMetricsRule('.mmt-container a[href]', function (a) {
	return {
		lid: $(a).closest('div.mmt-container').attr('id').replace('-mmt-container','')
	};
	})

				// for support menu store "tab" in lid area to conform with other MM tagging.
	cdc.util.addMetricsRule('#support-mm-menu a[href]', function (a) {
	return {
		lid: $(a).closest('div.mm-col').attr('id')
	};
	})
	cdc.util.addMetricsRule('.mmt-container .mm-h a[href]',	function (a) {
	return {
		lid: $(a).closest('div.mmt-container').attr('id').replace('-mmt-container','') + ' - Title: ' +$(a).text()
	};
	})

	cdc.util.addMetricsRule('.mmt-container .mm-himg a[href].mm-himg-img',	function(a){
	return {
		lid: $(a).closest('div.mmt-container').attr('id').replace('-mmt-container','') + ' - Image: ' +$(a).text()
	};
	})

	cdc.util.addMetricsRule('.mmt-container .mm-scol li a[href]',	function (a) {
	var sublid = ($(a).closest('div.mm-scol').find('h5').text()) ? $(a).closest('div.mm-scol').find('h5').text() + ' - ' : '';
	return {
		lid:sublid + $(a).closest('div.mmt-container').attr('id').replace('-mmt-container','')};
	}
	)
		// parent rule for utility links
		// logo, floating toolbar

	cdc.util.addMetricsRule('#fw-mbl a[href]',
	{lpos:'header_mb_hdr'}
	);

	cdc.util.addMetricsRule('#fw-logo a[href]',
	{lpos: 'header_mb_hdr'}
	);

	cdc.util.addMetricsRule('#fw-treenav ul#tn-actions a[href]',
	function(a) {
		return {lpos:'treenav-actions'};
	});

	cdc.util.addMetricsRule('#fw-treenav div#tn-mycisco a[href]',
	function(a) {
		return {lpos:'treenav-mycisco'};
	});

	cdc.util.addMetricsRule('#fw-treenav ul#tn-language a[href]',
	function(a) {
		return {lpos:'treenav-language'};
	});

	cdc.util.addMetricsRule('#fw-treenav ul#treenav-primary li a[href]',
	function(a) {
		return {lpos:'treenav-primary', lid:$(a).text()};
	});

	// Addresses treenav categorization issue.
	cdc.util.addMetricsRule('#treenav-secondary li a[href]',
	function(a) {
		return {lpos:'treenav-secondary-' + $('div[id="treenav-back"]').text(), lid:$(a).closest("li").prevUntil("ul").children("div:first").text()}
	});

	// util links
	cdc.util.addMetricsRule('nav#fw-utility a[href]',
	function(a) {
		return {lpos:'header_mb_hdr'};
	});

	// EmbeddedNav Links

	cdc.util.addMetricsRule('#fw-embeddednav ul li a[href]',
	function(a) {
	   return {lpos:'embeddednav',lid:$(a).text()};
	});

	// Breadcrumbs

	cdc.util.addMetricsRule('#fw-breadcrumb a[href]',
		function(a) {
			return {lpos: 'model_breadcrumb',
				lid: 'model_breadcrumb'};
		}
	);

	// Blank div ids differentiate FF list items from those in the flyout menus.
	cdc.util.addMetricsRule('#fw-fatfooter div[class!=""] li a[href]',
	function(a) {
	   return {lpos:'ff',lid:$(a).closest('ul').prev('h4').text()};
	});
	// fat footer header links for homepage
	cdc.util.addMetricsRule('#fw-fatfooter div[class!=""] h4 a[href]',
	function(a) {
	   return {lpos:'ff',lid:$(a).text()};
	});
	// FF flyout menu items
	cdc.util.addMetricsRule('.fatfooter-button li a[href]',
	function(a) {
	   return {lpos:'ff',lid:$(a).closest('div').prev('h4').text()};
	});

	// FF flyout headers
	cdc.util.addMetricsRule('.fatfooter-button h4 a[href]',
	function(a) {
	   return {lpos:'ff',lid:$(a).text()};
	});

	// Combined footer
	cdc.util.addMetricsRule('#fw-footer a[href]',
	function(a) {
		return {lpos:'fl', lid: $(a).text()};
	});

	// Amendments to Support MM
	cdc.util.addMetricsRule('#pssubmitbutton', function(a){return {lpos:"header_mb_support",lid:"mm_products_find",linktext:"support search",ntpagetag: {searchPhrase: jQuery('#support-searchstring').val()}}});
	cdc.util.addMetricsRule('#mm-support-download-submitbutton', function(a){return {lpos:"header_mb_support",lid:"mm_downloads_find",linktext:"download search",ntpagetag: {searchPhrase: jQuery('#mm-support-download-searchstring').val()}}});
	if (typeof cdc.homepage !== "undefined" && cdc.homepage.isHomepage === true) {
		// Set all onDemand for homepage:
		cdc.util.addMetricsRule('a', {
			onDemand: true
		});

		//spotlight
		cdc.util.addMetricsRule('.button-cta',
		function(a) {
			return {linktext:$(a).attr('name')};
		});

		cdc.util.addMetricsRule('#spotlight-marker li a',
		function(a) {
			return {lpos:'SL'}
		});

		// follow us/newsticker
		cdc.util.addMetricsRule('#fw-newsticker h3 a[href],#fw-newsticker li a[href]', {lpos:'nws_hp'});
		cdc.util.addMetricsRule('div.fw-followus a[href]', {lpos:'sm_hp'});
		cdc.util.addMetricsRule('#fw-spotlight li a',
		function(a) {
	   		return {lpos:'SL',lid:$(a).attr('name')};
		});

		// featured products
		cdc.util.addMetricsRule('section#fw-featureads a[href]',
		function(a) {
			return {lpos:'fp_hp', linktext:$(a).attr('name')};
		});

		// Blank div ids differentiate FF list items from those in the flyout menus.
		cdc.util.addMetricsRule('#fw-fatfooter div[class!=""] li a[href]',
		function(a) {
		   return {lpos:'ff_hp',lid:$(a).closest('ul').prev('h4').text()};
		});
		// fat footer header links for homepage
		cdc.util.addMetricsRule('#fw-fatfooter div[class!=""] h4 a[href]',
		function(a) {
	   		return {lpos:'ff_hp',lid:$(a).text()};
		});
		// FF flyout menu items
		cdc.util.addMetricsRule('.fatfooter-button li a[href]',
		function(a) {
	   		return {lpos:'ff_hp',lid:$(a).closest('div').prev('h4').text()};
		});

		// FF flyout headers
		cdc.util.addMetricsRule('.fatfooter-button h4 a[href]',
		function(a) {
	   		return {lpos:'ff_hp',lid:$(a).text()};
		});
	}

})(jQuery);